module het.algorithm; 
import het, het.draw2d; 
version(/+$DIDE_REGION+/all)
{
	
	
	
	//////////////////////////////////////////////////////////////////////
	///  FloodFill, Blob detection                                     ///
	//////////////////////////////////////////////////////////////////////
	
	struct Blob
	{
		ivec2 pos; 
		uint id; 
		uint area; 
		
		auto calcBounds(T)(T im)
		{
			//Note: image must be the one generated by findBlobs()!!! The image is filled with 0's and id's.
			auto bnd = ibounds2(pos, pos+1); 
			
			bool growUp()
			{
				const res = bnd.top>0 && im[bnd.left..bnd.right, bnd.top-1].asArray.any!(a => a==id); 
				if(res) bnd.top --; 
				return res; 
			} 
			
			bool growDown()
			{
				const res = bnd.bottom<im.height && im[bnd.left..bnd.right, bnd.bottom].asArray.any!(a => a==id); 
				if(res) bnd.bottom ++; 
				return res; 
			} 
			
			bool growLeft()
			{
				const res = bnd.left>0 && im[bnd.left-1, bnd.top..bnd.bottom].asArray.any!(a => a==id); 
				if(res) bnd.left --; 
				return res; 
			} 
			
			bool growRight()
			{
				const res = bnd.right<im.width && im[bnd.right, bnd.top..bnd.bottom].asArray.any!(a => a==id); 
				if(res) bnd.right ++; 
				return res; 
			} 
			
			while(1) {
				bool any; 
				if(growDown) any = true; 
				if(growRight) any = true; 
				if(growUp) any = true; 
				if(growLeft) any = true; 
				if(!any) break; 
			}
			
			return bnd; 
		} 
	} 
	
	version(/+$DIDE_REGION Blob detect+/all)
	{
		auto findBlobs(alias pred = "a", T1)(Image!(T1, 2) src)
		{
			struct Res {
				Image!(int, 2) img; 
				Blob[int] blobs; 
				alias blobs this; 
			} 
			
			Res res; 	res.img = image2D(src.size, 0); 
			int[int] map_; 	int map(int i) { if(auto a = i in map_) return *a; else return i; } 
			
			
			
			version(/+$DIDE_REGION Find the blobs based on top and left neighbors+/all)
			{
				auto actId=0, ofs=0, w = src.width, pSrc = src.ptr, pDst = res.img.ptr; 
				
				//cached stuff:
				uint* pArea; uint pArea_lastP; 
				int lastMappedTopId, lastMappedTopId_topId; 
				void resetLastP() { lastMappedTopId_topId = pArea_lastP = 0; } 
				foreach(y; 0..src.height)
				{
					auto leftSet = false; 
					foreach(x; 0..src.width)
					{
						const centerSet = !!(*(pSrc)).unaryFun!pred; 
						if(centerSet)
						{
							bool topSet ()
							{ return y ? !!(*(pSrc-w)).unaryFun!pred : false; } 
							int leftId()
							{ return *(pDst-1); } int topId ()
							{ return *(pDst-w); } 
							
							int mappedTopId()
							{
								const tid = topId; 
								if(lastMappedTopId_topId.chkSet(tid))
								lastMappedTopId = map(tid); 
								return lastMappedTopId; 
							} 
							
							int newBlob()
							{
								actId++; 
								res.blobs[actId] = Blob(ivec2(x, y), actId); 
								resetLastP; //Because AA can be reorganized.
								return actId; 
							} 
							
							int joinBlobs(int p, int l)
							{
								if(p!=l) {
									sort(p, l); //sort is to eliminate cyclic loops im map_[]
									map_[l] = p; 	//from unmapped to mapped is good
									resetLastP; 
								}
								return p; 
							} 
							
							int p; 
							if(leftSet)	{
								if(topSet)	{ p = joinBlobs(leftId, mappedTopId); }
								else	{ p = leftId; /+leftId is already mapped+/}
							}
							else	{
								if(topSet)	{ p = mappedTopId; }
								else	{ p = newBlob; }
							}
							
							*pDst = p; 
							if(pArea_lastP.chkSet(p)) { pArea = &res.blobs[p].area; }
							(*pArea)++; 
							
							static if(is(findBlobsDebug))
							findBlobsDebug.log(ivec2(x, y), src.dup, res.img.dup, map_.dup, res.blobs.dup); 
						}
						
						//advance
						leftSet = centerSet; //left = last
						pSrc ++; pDst++; 
					}
				}
			}
			
			{
				//make the map recursive
				int map_recursive(int id)
				{
					while(1) if(auto a = id in map_) id = *a; else break; 
					return id; 
				} 
				foreach(k; map_.keys) map_[k] = map_recursive(k); 
				//remap the result id image
				map_.rehash; 
				int lastp, mappedp; 
				mixin(求each(q{ref p},q{res.img},q{
					if(p) {
						if(lastp.chkSet(p))
						mappedp = map(p); 
						if(p!=mappedp)
						p = mappedp; 
					}
				})); 
			}
			
			{
				//remap the result blobs
				int[] rem; 
				mixin(求each(q{k},q{res.blobs.keys},q{
					{
						int p = map(k); 
						if(p!=k) {
							res.blobs[p].area += res.blobs[k].area; 
							rem ~= k; 
						}
					}
				})); 
				mixin(求each(q{k},q{rem},q{res.blobs.remove(k)})); 
			}
			
			static if(is(findBlobsDebug))
			findBlobsDebug.log(ivec2(-1), src.dup, res.img.dup, map_.dup, res.blobs.dup); 
			
			return res; 
		} 
		
		static if(0)
		struct findBlobsDebug
		{
			import het.draw2d, het.ui; static: 
			struct Event
			{
				ivec2 actPos; 
				Image!(ubyte, 2) src; 
				Image!(int, 2) dst; 
				int[int] idMap; 
				Blob[int] blobs; 
				
				void draw(Drawing dr)
				{
					with(dr) {
						fontHeight = .8; 
						
						void setColor(int i)
						{ color = hsvToRgb(([i].xxh32&255)/255.0f, 1, 1).to_unorm; } 
						
						foreach(y; 0..src.height)
						foreach(x; 0..src.width)
						{
							translate(x, y); 
							
							if(src[x, y]) setColor(dst[x, y]); else color = clBlack; 
							drawRect(0.05, 0.05, 0.95, 0.95); 
							
							if(dst[x, y]) textOut(0.1, 0.1, dst[x, y].to!string(36)); 
							
							pop; 
						}
						
						
						color = clWhite; 
						foreach(i, k; idMap.keys.sort.array)
						{
							translate(src.width+2, i); 
							textOut(0, 0, k.to!string(36) ~ " -> " ~ idMap[k].to!string(36)); 
							pop; 
						}
						
						
						foreach(k, v; blobs)
						{
							translate(v.pos); 
							setColor(k); 
							fontHeight = 0.8; 
							textOut(0.1, 0.1, k.to!string(36)); 
							color = clWhite; 
							fontHeight = 0.3; 
							textOut(0.1, 0.7, v.area.text); 
							circle(vec2(.5), 0.7); 
							pop; 
						}
						
					}
				} 
			} 
			
			Event[] events; 
			
			void log(A...)(A a)
			{ events ~= Event(a); } 
			
			int actEventIdx; 
			
			void UI()
			{
				with(im)
				Row(
					{
						Text("FindBlobs debug idx:"); 
						const r = range(0, events.length.to!int-1); 
						IncDec(actEventIdx, r); 
						Slider(actEventIdx, r, { width = fh*32; }); 
					}
				); 
				
				
			} 
			
			void draw(Drawing dr)
			{ events.get(actEventIdx).draw(dr); } 
		} 
		version(/+$DIDE_REGION Largest Blob + Erode +/all)
		{
			auto isolateLargestBlob(char chn)(Image2D!RGBA img)
			{
				auto blobs = findBlobs!("a."~chn)(img); 
				if(blobs.length)
				{
					const largestBlobId = blobs.values.maxElement!(a => a.area).id; 
					
					foreach(ofs, id; blobs.img.asArray)
					if(
						id && id!=largestBlobId
						/+It's a blob, but not the largest.+/
					)
					mixin("(*(img.ptr+ofs))."~chn) = 0; 
				}
				return blobs; 
			} 
			
			void convexizeH(char chn)(Image2D!RGBA img, int len, ubyte alpha=255)
			{
				if(len<=0) return; 
				foreach(y; 0..img.height)
				{
					bool lastState; 
					int lastPos = -1; 
					foreach(x; 0..img.width)
					{
						const actState = mixin("img[x, y]."~chn)>0; 
						if(lastState!=actState)
						{
							//fill holes
							if(actState && lastPos>=0 && lastPos+len>=x)
							foreach(x2; lastPos..x) mixin("img[x2, y]."~chn) = alpha; 
							
							lastPos = x; lastState = actState; 
						}
					}
				}
			}  void convexizeV(char chn)(Image2D!RGBA img, int len, ubyte alpha=255)
			{
				if(len<=0) return; 
				foreach(x; 0..img.width)
				{
					bool lastState; 
					int lastPos = -1; 
					foreach(y; 0..img.height)
					{
						const actState = mixin("img[x, y]."~chn)>0; 
						if(lastState!=actState)
						{
							//fill holes
							if(actState && lastPos>=0 && lastPos+len>=y)
							foreach(y2; lastPos..y) mixin("img[x, y2]."~chn) = alpha; 
							
							lastPos = y; lastState = actState; 
						}
					}
				}
			} 
			
			///Fills large holes on horizontal and vertical scanlines.  Works on alpha channel.
			void convexize(char chn)(Image2D!RGBA img, int len, ubyte alpha=255)
			{
				convexizeH!chn(img, len, alpha); 
				convexizeV!chn(img, len, alpha); 
			} 
			
			void deflateBlobH(char chn)(Image2D!RGBA img, int len1, int len2)
			{
				int[3][] indices; 
				foreach(y; 0..img.height)
				{
					auto arr() { return img.rows[y].map!("a."~chn~"!=0"); } 
					const i0 = arr.countUntil(true).to!int; 
					if(i0>=0)
					{
						const i1 = arr.retro.countUntil(true).to!int; 
						if(i1>=0)
						indices ~= [y, i0, img.width - i1]; 
					}
				}
				
				//smooth
				const indices2 = indices.dup; 
				foreach(i; 1..indices.length.to!int-1)
				{
					foreach(j; 1..3)
					indices[i][j] = (indices2[i-1][j] + indices2[i+1][j])/2; 
				}
				
				//adjust
				foreach(ref ind; indices)
				{
					ind[1] += len1; 
					ind[2] -= len2; 
				}
				
				//execute
				foreach(const ind; indices)
				foreach(x; 0..img.width)
				if(!(x>=ind[1] && x<ind[2]))
				mixin("img[x, ind[0]]."~chn) = 0; 
			}  void deflateBlobV(char chn)(Image2D!RGBA img, int len1, int len2)
			{
				int[3][] indices; 
				foreach(x; 0..img.width)
				{
					auto arr() { return img.columns[x].map!("a."~chn~"!=0"); } 
					const i0 = arr.countUntil(true).to!int; 
					if(i0>=0)
					{
						const i1 = arr.retro.countUntil(true).to!int; 
						if(i1>=0)
						indices ~= [x, i0, img.height - i1]; 
					}
				}
				
				//smooth
				const indices2 = indices.dup; 
				foreach(i; 1..indices.length.to!int-1)
				{
					foreach(j; 1..3)
					indices[i][j] = (indices2[i-1][j] + indices2[i+1][j])/2; 
				}
				
				//adjust
				foreach(ref ind; indices)
				{
					ind[1] += len1; 
					ind[2] -= len2; 
				}
				
				//execute
				foreach(const ind; indices)
				foreach(y; 0..img.height)
				if(!(y>=ind[1] && y<ind[2]))
				mixin("img[ind[0], y]."~chn) = 0; 
			} 
			
			void deflateBlob(char chn)(Image2D!RGBA img, int top, int right, int bottom, int left)
			{
				deflateBlobH!chn(img, left, right); 
				deflateBlobV!chn(img, top, bottom); 
			} 
			
		}
	}
	
	//////////////////////////////////////////////////////////////////////
	///  2D MaxRects Bin Packer                                        ///
	//////////////////////////////////////////////////////////////////////
	
	/*
			2D MaxRects Bin Packer
		
		Copyright (c) 2017 Shen Yiming
		
		Permission is hereby granted, free of charge, to any person obtaining a copy
		of this software and associated documentation files (the "Software"), to deal
		in the Software without restriction, including without limitation the rights
		to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
		copies of the Software, and to permit persons to whom the Software is
		furnished to do so, subject to the following conditions:
		
		The above copyright notice and this permission notice shall be included in all
		copies or substantial portions of the Software.
		
		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
		AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
		LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
		OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
		SOFTWARE.
	*/
	
	alias RectangleData = int; //Todo: a rectangle bele mehetne a binPacker classba es lehetne generic tipusu a data
	
	class Rectangle
	{
		int x, y, width, height; 
		RectangleData data; 
		
		this(int x, int y, int width, int height)
		{
			this.x = x; 
			this.y = y; 
			this.width = width; 
			this.height = height; 
		} 
		
		bool opEquals(const Rectangle r) const
		{ return (this !is null) && (r !is null) && x==r.x && y==r.y && width==r.width && height==r.height; } 
		
		int area() const
		{ return this.width * this.height; } 
		
		auto bounds() const
		{ return ibounds2(x, y, x+width, y+height); } 
		
		bool collide(Rectangle rect)
		{
			//intersection.area > 0
			return !(
				rect.x >= this.x + this.width || rect.x + rect.width <= this.x ||
				rect.y >= this.y + this.height || rect.y + rect.height <= this.y
			); 
		} 
		
		bool contain(Rectangle rect)
		{
			//the whole rect is inside this.
			return (
				rect.x >= this.x && rect.y >= this.y &&
				rect.x + rect.width <= this.x + this.width && rect.y + rect.height <= this.y + this.height
			); 
		} 
		
		override string toString() const
		{ return format!"%5s %s"(data, bounds.text); } 
	} 
	
	private void splice(T)(ref T[] a, size_t i, size_t del = 0, T[] ins = [])
	{ a = a[0..i]~ins~a[i+del..$]; } 
	
	private bool collide(Rectangle first, Rectangle second)
	{ return first.collide(second); } 
	private bool contain(Rectangle first, Rectangle second)
	{ return first.contain(second); } 
	
	class MaxRectsBin
	{
		int width, height; 
		const int maxWidth, maxHeight; 
		Rectangle[] freeRects, rects; 
		
		struct Options { bool smart, pot, square; } 
		const Options options; 
		const int padding; 
		
		private bool verticalExpand; 
		private Rectangle stage; 
		
		this(
			int initialWidth, int initialHeight, int maxWidth, int maxHeight, int padding=0,
			Options options = Options(true, true, false)
		)
		{
			this.maxWidth = maxWidth; 
			this.maxHeight = maxHeight; 
			this.options = options; 
			this.padding = padding; 
			
			this.width	= this.options.smart ? initialWidth	: maxWidth; 
			this.height	= this.options.smart ? initialHeight	: maxHeight; 
			this.freeRects ~= new Rectangle(0, 0, this.maxWidth + this.padding, this.maxHeight + this.padding); 
			this.stage = new Rectangle(0, 0, this.width, this.height); 
		} 
		
		void reinitialize()
		{
			this.rects = []; 
			this.freeRects = [new Rectangle(0, 0, this.maxWidth + this.padding, this.maxHeight + this.padding)]; 
			this.stage = new Rectangle(0, 0, this.width, this.height); 
		} 
		
		Rectangle add(int width, int height, RectangleData data = RectangleData.init)
		{
			auto node = this.findNode(width + this.padding, height + this.padding); 
			if(node)
			{
				this.updateBinSize(node); 
				auto numRectToProcess = this.freeRects.length; 
				auto i = 0; 
				while(i < numRectToProcess)
				{
					if(this.splitNode(this.freeRects[i], node)) {
						this.freeRects.splice(i, 1); 
						numRectToProcess--; 
						i--; 
					}
					i++; 
				}
				this.pruneFreeList(); 
				this.verticalExpand = this.width > this.height ? true : false; 
				auto rect = new Rectangle(node.x, node.y, width, height); 
				rect.data = data; 
				this.rects ~= rect; 
				return rect; 
			}
			else if(!this.verticalExpand)
			{
				if(
					this.updateBinSize(new Rectangle(this.width + this.padding, 0, width + this.padding, height + this.padding)) ||
					this.updateBinSize(new Rectangle(0, this.height + this.padding, width + this.padding, height + this.padding))
				)
				{ return this.add(width, height, data); }
			}
			else
			{
				if(
					this.updateBinSize(
						new Rectangle(
							0, this.height + this.padding,
							width + this.padding, height + this.padding
						)
					) ||
					this.updateBinSize(
						new Rectangle(
							this.width + this.padding, 0,
							width + this.padding, height + this.padding
						)
					)
				)
				{ return this.add(width, height, data); }
			}
			return null; 
		} 
		
		//it bugs    sizediff_t find(in Rectangle     r)const { return rects.countUntil(r); }
		sizediff_t find(in RectangleData d)const
		{ return rects.map!(r=>r.data).countUntil(d); } 
		
		bool remove(sizediff_t idx)
		{
			if(idx>=0) {
				freeRects ~= rects[idx]; 
				rects = rects.remove(idx); 
				return true; 
			}else { return false; }
		} 
		
		//it bogs    bool remove(in Rectangle	r){ return remove(find(r)); }
		bool remove(in RectangleData d)
		{ return remove(find(d)); } 
		
		private: 
		
		Rectangle findNode(int width, int height)
		{
			auto score = int.max; 
			int areaFit; 
			Rectangle bestNode; 
			
			foreach(r; freeRects)
			{
					//Todo: ref if struct!!!
				if(r.width >= width && r.height >= height)
				{
					areaFit = r.width * r.height - width * height; //Opt: do the mult outside
					if(areaFit < score) {
						//bestNode.x = r.x;
						//bestNode.y = r.y;
						//bestNode.width = width;
						//bestNode.height = height;
						bestNode = new Rectangle(r.x, r.y, width, height); 
						//Opt: dont make a new allocation here.
						//Opt: rectangle shouldnt be a class
						score = areaFit; 
					}
				}
			}
			
			return bestNode; 
		} 
		
		bool splitNode(Rectangle freeRect, Rectangle usedNode)
		{
			//Test if usedNode intersect with freeRect
			if(!freeRect.collide(usedNode)) return false; 
			
			//Do vertical split
			if(usedNode.x < freeRect.x + freeRect.width && usedNode.x + usedNode.width > freeRect.x)
			{
				//New node at the top side of the used node
				if(usedNode.y > freeRect.y && usedNode.y < freeRect.y + freeRect.height)
				{
					auto newNode = new Rectangle(freeRect.x, freeRect.y, freeRect.width, usedNode.y - freeRect.y); 
					this.freeRects ~= newNode; 
				}
				//New node at the bottom side of the used node
				if(usedNode.y + usedNode.height < freeRect.y + freeRect.height)
				{
					auto newNode = new Rectangle(
						freeRect.x,
						usedNode.y + usedNode.height,
						freeRect.width,
						freeRect.y + freeRect.height - (usedNode.y + usedNode.height)
					); 
					this.freeRects ~= newNode; 
				}
			}
			
			//Do Horizontal split
			if(
				usedNode.y < freeRect.y + freeRect.height &&
				usedNode.y + usedNode.height > freeRect.y
			)
			{
				//New node at the left side of the used node.
				if(usedNode.x > freeRect.x && usedNode.x < freeRect.x + freeRect.width)
				{
					auto newNode = new Rectangle(freeRect.x, freeRect.y, usedNode.x - freeRect.x, freeRect.height); 
					this.freeRects ~= newNode; 
				}
				//New node at the right side of the used node.
				if(usedNode.x + usedNode.width < freeRect.x + freeRect.width)
				{
					auto newNode = new Rectangle(
						usedNode.x + usedNode.width,
						freeRect.y,
						freeRect.x + freeRect.width - (usedNode.x + usedNode.width),
						freeRect.height
					); 
					this.freeRects ~= newNode; 
				}
			}
			return true; 
		} 
		
		void pruneFreeList ()
		{
			//Go through each pair of freeRects and remove any rects that is redundant
			int i, j; 
			auto len = this.freeRects.length; 
			while(i < len)
			{
				j = i + 1; 
				auto tmpRect1 = this.freeRects[i]; 
				while(j < len)
				{
					auto tmpRect2 = this.freeRects[j]; 
					if(tmpRect2.contain(tmpRect1)) {
						this.freeRects.splice(i, 1); 
						i--; 
						len--; 
						break; 
					}
					if(tmpRect1.contain(tmpRect2)) {
						this.freeRects.splice(j, 1); 
						j--; 
						len--; 
					}
					j++; 
				}
				i++; 
			}
		} 
		
		bool updateBinSize(Rectangle node)
		{
			if(!this.options.smart) return false; 
			if(this.stage.contain(node)) return false; 
			auto tmpWidth	= max(this.width , node.x + node.width  - this.padding); 
			auto tmpHeight	= max(this.height, node.y + node.height - this.padding); 
			if(this.options.pot) {
				tmpWidth = nearest2NSize(tmpWidth); 
				tmpHeight = nearest2NSize(tmpHeight); 
			}
			if(this.options.square) { tmpWidth = tmpHeight = max(tmpWidth, tmpHeight); }
			if(tmpWidth > this.maxWidth + this.padding || tmpHeight > this.maxHeight + this.padding) { return false; }
			this.expandFreeRects(tmpWidth + this.padding, tmpHeight + this.padding); 
			this.width = this.stage.width = tmpWidth; 
			this.height = this.stage.height = tmpHeight; 
			return true; 
		} 
		
		void expandFreeRects(int width, int height)
		{
			foreach(freeRect; this.freeRects)
			{
				if(freeRect.x + freeRect.width >= min(this.width + this.padding, width)) { freeRect.width = width - freeRect.x; }
				if(freeRect.y + freeRect.height >= min(this.height + this.padding, height)) { freeRect.height = height - freeRect.y; }
			}
			this.freeRects ~= new Rectangle(this.width + this.padding, 0, width - this.width - this.padding, height); 
			this.freeRects ~= new Rectangle(0, this.height + this.padding, width, height - this.height - this.padding); 
			this.freeRects = this.freeRects.filter!(freeRect => !(freeRect.width <= 0 || freeRect.height <= 0)).array; 
			this.pruneFreeList(); 
		} 
		
		public: 
		
		void dump() const
		{
			writefln("BinPacker %s, %s, %s, %s", width, height, maxWidth, maxHeight); 
			writeln("  rects: ", rects.map!text.join("\n")); 
			writeln("  freeRects:", freeRects.map!text.join("\n")); 
		} 
		
		static string test(Drawing dr)
		{
				//test /////////////////////////////////
			import het.draw2d; 
			
			auto mrb = new MaxRectsBin(0, 0, 1024, 1024); 
			ivec2[] adds = [ivec2(1,1), ivec2(2,2), ivec2(7,3), ivec2(3,7), ivec2(1,1), ivec2(1,1)]; 
			
			RNG rng; rng.seed = 123; 
			foreach(i; 0..60)
			adds ~= ivec2(rng.random(24)+1,rng.random(8)+1); 
			
			foreach(i; 0..550)
			adds ~= ivec2(rng.random(2)+1,rng.random(2)+1); 
			
			foreach(i, a; adds)
			{
				mrb.add(a.x, a.y); 
				
				if((i&3)==3) { mrb.remove(rng.random(mrb.rects.length)); }
				
				if(dr) {
					dr.translate(cast(int)i * 65, 0); 
					
					foreach(r; mrb.freeRects) {
						dr.color = clGray; 
						dr.drawRect(bounds2(r.bounds).inflated(-0.125)); 
					}
					
					dr.color = clWhite;  dr.drawRect(0, 0, mrb.width, mrb.height); 
					
					foreach(j, r; mrb.rects) {
						dr.color = clEga[(cast(int)j % ($-1))+1]; 
						dr.fillRect(r.bounds); 
					}
					
					dr.pop; 
				}
			}
			
			auto res = mrb.rects.text; 
			
			enforce(res.xxh32==844746689, "MaxRectsBin add/remove test (2D Binpacking)"); 
			
			mrb.destroy; 
			
			return res; 
		} 
		
	} 
	
	version(/+$DIDE_REGION Quadtree+/all)
	{
		/+
			+Author: JackStouffer
			/+Link: https://gist.github.com/JackStouffer/810c68f86af2abaa56be+/
			
			Quadtree implementation that allows the collision resolver 
			to only scan a small subset of the possible colliding objects
			See Also:
			/+Link: http://gamedevelopment.tutsplus.com/tutorials/quick-tip-use-quadtrees-to-detect-likely-collisions-in-2d-space--gamedev-374+/
			
			Modifications:
			- It uses het.Bounds omstead of itself. (Was a clever idea but it's wasting resouces.)
			- Added visit() with optional culling.
		+/
		struct QuadTree(B, T, string boundsProp="bounds", uint MAX_OBJECTS = 10, uint MAX_LEVELS = 5)
		if (hasMember!(T, boundsProp))
		{
			B bounds; 
			T[] objects; 
			QuadTree[] nodes; 
			//Opt: maybe a ptr to a static array is better
			
			int level; 
			
			this(int level, B bounds)
			{
				this.level = level; 
				this.bounds = bounds; 
			} 
			
			/*Clears the quadtree*/
			void clear()
			{
				foreach(ref node; nodes) node.clear; 
				nodes = []; 
				objects = []; 
			} 
			
			/*Splits the node into 4 subnodes*/
			void split()
			{
				with(bounds)
				with(bounds.center)
				nodes = 
				[
					QuadTree(level+1, B(x0, y0, x , y )),
					QuadTree(level+1, B(x , y0, x1, y )),
					QuadTree(level+1, B(x0, y , x , y1)),
					QuadTree(level+1, B(x , y , x1, y1))
				]; 
			} 
			
			/*
				Determine which node the object belongs to. -1 means
				object cannot completely fit within a child node and is part
				of the parent node
			*/
			int getIndex(in B p_rect)
			{
				int index = -1; 
				const center = bounds.center; 
				
				// Object can completely fit within the top quadrants
				const top_quadrant = p_rect.y1 <= center.y; 
				// Object can completely fit within the bottom quadrants
				const bottom_quadrant = p_rect.y0 >= center.y; 
				
				if(p_rect.x1 <= center.x)
				{
					// Object can completely fit within the left quadrants
					if(top_quadrant)	index = 0; 
					else if(bottom_quadrant)	index = 2; 
				}
				else if(p_rect.x0 >= center.x)
				{
					// Object can completely fit within the right quadrants
					if(top_quadrant)	index = 1; 
					else if(bottom_quadrant)	index = 3; 
				}
				
				return index; 
			} 
			
			/*
				Insert the object into the quadtree. If the node
				exceeds the capacity, it will split and add all
				objects to their corresponding nodes.
			*/
			void insert(T obj)
			{
				const B objBounds = mixin("obj.", boundsProp); 
				
				if(nodes.length)
				{
					const qIdx = getIndex(objBounds); 
					
					if(qIdx>=0)
					{
						nodes[qIdx].insert(obj); 
						return; 
					}
				}
				
				objects ~= obj; 
				
				if(objects.length > MAX_OBJECTS && level < MAX_LEVELS)
				{
					if(nodes.empty) split; 
					
					int i = 0; 
					while(i < objects.length)
					{
						const qIdx = getIndex(mixin("objects[i].", boundsProp)); 
						if(qIdx>=0)	{
							nodes[qIdx].insert(objects[i]); 
							objects = objects.remove(i); 
						}
						else	{ i++; }
					}
				}
			} 
			
			void visit(void delegate(ref T) fun)
			{
				foreach(ref o; objects) fun(o); 
				foreach(ref n; nodes) n.visit(fun); 
			} 
			
			void visit(in B p_rect, void delegate(ref T) fun)
			{
				if(!p_rect.overlaps(bounds)) return; 
				
				if(p_rect.contains!"[)"(bounds))
				{
					//the whole treeNode is inside the rect.
					visit(fun); 
				}
				else
				{
					foreach(ref o; objects)
					{
						const ob = mixin("o.", boundsProp); 
						if(p_rect.overlaps(ob))
						fun(o); 
					}
					
					foreach(ref n; nodes) n.visit(p_rect, fun); 
				}
			} 
			
			bool empty() const 
			{ return objects.empty && nodes.empty && nodes.map!(n=>n.empty).all/+recursive+/; } 
			
			void remove(bool delegate(in T) pred)
			{
				foreach(ref n; nodes) n.remove(pred)/+recursive+/; 
				const wasEmpty = objects.empty; 
				
				//Todo: If I use an alias for pred, remove!pred fails with a Dual Context not supported error.
				objects = objects.remove!(a=>pred(a)); 
				
				if(objects.empty && !wasEmpty && empty/+recursive+/) clear/+also recursive+/; 
			} 
			
		} 
	}
	
	struct PositionExtrapolator
	{
		private: 
			struct HistoryRec {
			DateTime t; 
			double position; 
		} 
			HistoryRec[] history; 
		
		public: 
		
			Time historyDuration = 1*second; 
		
			void reset()
		{ history = []; } 
		
			void update()
		{
			const tz = now - historyDuration; 
			history = history.remove!(a => a.t<tz); 
		} 
		
			void appendPosition(double pos, DateTime t = now)
		{ history ~= HistoryRec(t, pos); } 
		
			double position(DateTime t = now) const
		{
			//no data
			if(history.empty) return typeof(return).nan; 
			
			//constant
			if(history.length==1) return history[0].position; 
			
			//interpolate
			if(t.inRange(history[0].t, history[$-1].t))
			{
				foreach(a; history.slide(2))
				if(t.inRange(a[0].t, a[1].t))
				return remap(0, (a[0].t-t).value(second), (a[1].t-t).value(second), a[0].position, a[1].position); 
			}
			
			//extrapolate
			return remap(0, (history[0].t-t).value(second), (history[$-1].t-t).value(second), history[0].position, history[$-1].position); 
		} 
		
			double speed() const
		{
			if(history.length<2) return 0; 
			return safeDiv(history[$-1].position - history[0].position, (history[$-1].t - history[0].t).value(second)); 
		} 
		
			void selfTest()
		{
			PositionExtrapolator pe; 
			[100, 125, 150, 0, 0, 300, 300, 300, 300, 300, 300, 500, 505]
				.chain([0].replicate(20))
				.each!((a){
				sleep(100); 
				if(a) pe.appendPosition(a); 
				pe.update; 
				pe.position.print; 
				
				if(a==505)
				iota(-1.5, 1.5, 0.03333).map!(i => pe.position(now + i*second)).print; 
			}); 
		} 
	} 
	float waveLengthStrength(float[] arr, int wl)
	{
		enforce(wl>1); 
		static float[] createTab(alias fun)(int res)
		{
			const invRes = (2*PIf)/res; 
			return iota(res).map!(i => fun(i*invRes)).array; 
			//Opt: cache these tables
		} 
		
		const 	sinTab = createTab!sin(wl),
			cosTab = createTab!cos(wl); 
		
		int j = 0; 
		float sinSum = 0, cosSum = 0; 
		foreach(a; arr)
		{
			sinSum += a * sinTab[j]; 
			cosSum += a * cosTab[j]; 
			j++; if(j==wl) j=0; 
		}
		
		return length(vec2(sinSum, cosSum)); 
	} 
	
	struct WaveLengthDetectionResult
	{
		int waveLength, waveLengthMin, waveLengthMax, waveLengthStep; 
		float[] samples, spectrum; 
		alias waveLength this; 
	} 
	
	auto detectWaveLength(string method)(float[] arr, int wlMin, int wlMax, int wlStep=1)
	{
		auto waveLengthRange = iota(wlMin, wlMax+wlStep, wlStep); 
		enforce(!waveLengthRange.empty); 
		
		static if(method=="sincos")
		{
			float[] scores = waveLengthRange	.map!(wl => waveLengthStrength(arr, wl))
				.array; 
		}
		else static if(method=="pulse")
		{
			float[] scores = [0.0f].replicate(waveLengthRange.length); 
			float lo=arr.front, hi=arr.front; 
			bool lastSt; 
			int counter; 
			foreach(i, act; arr)
			{
				counter++; 
				hi = hi.mix(act, 0.5f); 
				lo = lo.mix(act, 0.02f); 
				const actSt = hi>(lo+10/+noise threshold+/); 
				
				if(lastSt.chkSet(actSt))
				{
					if(actSt) {
						const idx = (counter-wlMin)/wlStep; 
						if(idx.inRange(scores)) scores[idx] += counter; 
						counter = 0; 
					}
				}
			}
			
			scores[] /= waveLengthRange.map!"0.01f".array[]; //scale it up to look nice
		}
		else static assert(0, "Unknown method"); 
		
		scores = scores.gaussianBlur(3.translateDeprecatedGaussParameter); 
		const idx = scores.maxIndex.to!int; 
		
		return WaveLengthDetectionResult(idx<0 ? 0 : idx*wlStep+wlMin, wlMin, wlMax, wlStep, arr, scores); 
	} 
	
	float[][2] getCenterLineSamples(T)(T im, int thickness, int periods=20, ivec2 centerPercent=ivec2(50))
	if(isImage2D!T)
	{
		const t = max(1, thickness/2), scale = 1.0f/(t*2); 
		const p = periods*t; 
		ivec2 c = iround(im.size*centerPercent*0.01f).clamp(ivec2(t), im.size-t); 
		auto extract(A)(A arr)
		{ return arr.map!(a => a.map!(p => p.l).sum*scale).array; } 
		return 	[
			extract(im[max(0, c.x-p) .. min($, c.x+p), c.y-t .. c.y+t].columns),
			extract(im[c.x-t .. c.x+t, max(0, c.y-p) .. min($, c.y+p)].rows)
		]; 
	} 
	
	
	auto detectWaveLength(string method="pulse", T)(
		T img, int wlMin, int wlMax, int wlStep=1, 
		int periods=40, ivec2 centerPercent=ivec2(50)
	)
	if(isImage2D!T)
	{
		auto samples = getCenterLineSamples(img, wlMax, periods, centerPercent); 
		auto res = [
			detectWaveLength!method(samples[0], wlMin, wlMax, wlStep),
			detectWaveLength!method(samples[1], wlMin, wlMax, wlStep)
		]; 
		return res; 
	} 
	
	auto fftDonutHistogram(int count)(
		Image2D!ℂ shiftedSpectrum, float minRadius, float maxRadius, 
		bool dbg=false
	)
	{
		static ivec2 to180(ivec2 v)
		{ return ((v.y>0)?(((v.x<0)?(-v):(v))) :(((v.x<=0)?(-v):(v)))); } 
		
		auto hist = [0.0f].replicate(count); 
		const center = shiftedSpectrum.size/2-1; 
		foreach(p; shiftedSpectrum.size.iota2D)
		{
			const dir = to180(p-center); 
			if(dir)
			{
				const len = length(dir); 
				if(len.inRange(minRadius, maxRadius))
				{
					const 	n = dir*(1.0f/len),
						α = atan(n.y, n.x),
						quant = (α.remap!(-π/2, π/2, 0, count).iround+count)%count; 
					hist[quant] += shiftedSpectrum[p].abs; 
					if(dbg) shiftedSpectrum[p.x, p.y] = ℂ(0); 
				}
			}
		}
		
		return hist; 
	} 
	
	auto angleHistogramPeakAngle(float[] hist, float* y=null)
	{
		const roughAngleIdx = hist.maxIndex.to!int; 
		auto hist2(int i) { return hist[(roughAngleIdx+i+$)%$]; } 
		return (roughAngleIdx + peakLocation(hist2(-1), hist2(0), hist2(1), y)) * (π/hist.length); 
	} 
	
	auto angleHistogramPeakVector(float[] hist)
	{
		float y; 
		const angle = angleHistogramPeakAngle(hist, &y); 
		return vec2(0, y).rotate(angle); 
	} 
	
	void drawFftDonutHistogram(Drawing dr, float[] hist)
	{
		dr.lineLoop(
			iota((hist.length*2).to!int).map!(
				i=>	vec2(0, hist[i%hist.length])
					.rotate(π * i / hist.length)
			).array
		); 
	} 
	
	void drawFftDonutAngle(Drawing dr, float[] hist)
	{
		const v = angleHistogramPeakVector(hist); 
		dr.line(+v, -v); 
	} 
	
	auto fftRadialSum(Image2D!ℂ shiftedSpectrum, vec2 vector, int size)
	{
		if(!vector) return 0; 
		const 	dir 	= vector.normalize,
			side	= dir.rotate90,
			center 	= shiftedSpectrum.size/2-1; 
		return (
			iota
			(
				-size+1,
				size
			)
		).map!(
			i=>(
				iota
				(
					-1,
					2
				)
			).map!(j=>(magnitude(shiftedSpectrum[iround(center + i*dir + j*side)]))).sum
		).sum; 
	} 
}
version(/+$DIDE_REGION Geometry+/all)
{
	
	alias seg2 = Segment!vec2; 
	alias dseg2 = Segment!dvec2; 
	
	struct Segment(Vect)
	{
		alias V = Vect, 
		E = V.ComponentType; 
		
		V[2] p; 
		
		alias p this; 
		
		this(A, B)(in A a, in B b) { p[0] = V(a); p[1] = V(b); } 
		this(E x0, E y0, E x1, E y1) { this(V(x0, y0), V(x1, y1)); } 
		
		auto diff() const => p[1] - p[0]; 
		auto length() const => .length(diff); //Todo: implement in math.length
		auto dir() const => diff*(1/length); //Todo: implement in math.normalize
	} 
	
	auto toSegs(in vec2[] p, bool circular)
	{
		 //Todo: rewrite with functional.slide
		seg2[] res; 
		res.reserve(p.length); 
		if(p.length<=1) return res; 
		foreach(i; 0..p.length-1+(circular ? 1 : 0)) {
			auto j = i+1; 
			if(j == p.length) j = 0; 
			res ~= seg2(p[i], p[j]); 
		}
		return res; 
	} 
	
	auto toPoints(in bounds2 bnd, bool clockwise=true)
	{
		with(bnd) {
			auto res = [low, vec2(high.x, low.y), high, vec2(low.x, high.y)]; 
			return clockwise 	? res
				: res.retro.array; 
		}
	} 
	
	auto toSegs(in bounds2 bnd, bool clockwise=true)
	{ return bnd.toPoints(clockwise).toSegs(true); } 
	
	
	//Todo: these should be done with CTCG
	//Todo: put these into het.math
	auto inflated(B, V)(in B b, in V v)
	{ return b.valid ? B(b.low-v, b.high+v) : b; } //Todo: support this for all bounds
	auto inflated(B, F)(in B b, in F x, in F y)
	{ return b.inflated(B.VectorType(x, y)); } 
	auto inflated(B, F)(in B b, in F x, in F y, in F z)
	{ return b.inflated(B.VectorType(x, y, z)); } 
	
	auto fittingSquare(in bounds2 b)
	{
		auto diff = (b.size.x-b.size.y)*0.5f; 
		if(diff<0) return b.inflated(0    , diff); 
		else return b.inflated(-diff,    0); 
	} 
	
	//float - int combinations ///////////////////////////////////////
	
	////////////////////////////////////////////////////////////////////////////////////////////
	///  Graphics algorithms                                                                 ///
	////////////////////////////////////////////////////////////////////////////////////////////
	
	///  Intersections, primitive distances  ///////////////////////////////////////////////////
	
	vec2 intersectLines_noParallel_prec(S: Segment!E, E)(in S S0, in S S1)
	//Todo: all of these variation should be refactored with static ifs.
	{
		auto 	S	= S1.p[0]-S0.p[0],
			T	= S0.p[1]-S0.p[0],
			U	= S1.p[0]-S1.p[1],
			det	= crossZ(T, U),
			detA	= crossZ(S, U),
			alpha 	= detA/det; //Opt: alpha = detA*rcpf_fast(det);
		
		return S0.p[0] + T*alpha; 
	} 
	
	bool intersectSegs_noParallel_prec(S: Segment!E, E)(in S S0, in S S1, ref E P)
	{
		auto 	S = S1.p[0]-S0.p[0],
			T = S0.p[1]-S0.p[0],
			U = S1.p[0]-S1.p[1]; 
		auto 	det	= crossZ(T, U),
			detA 	= crossZ(S, U); 
		
		if(inRange_sorted(detA, 0, det))
		{
			//have one intersection
			auto detB = crossZ(T, S); 
			if(inRange_sorted(detB, 0, det))
			{
				auto alpha = detA/det; 
				//alpha = detA*rcpf_fast(det); //rather not
				P = S0.p[0]+T*alpha; 
				
				return true; 
			}
		}
		return false; 
	} 
	
	bool intersectSegs_noParallel_prec(S: Segment!E, E)(in S S0, in S S1)
	{
		auto 	S = S1.p[0]-S0.p[0],
			T = S0.p[1]-S0.p[0],
			U = S1.p[0]-S1.p[1]; 
		auto 	det	= crossZ(T, U),
			detA	= crossZ(S, U); 
		
		if(inRange_sorted(detA, 0, det))
		{
			//have one intersection
			auto detB = crossZ(T, S); 
			if(inRange_sorted(detB, 0, det)) {
				auto alpha = detA/det; 
				return true; 
			}
		}
		return false; 
	} 
	
	bool intersectSegs_falseParallel_prec(S: Segment!E, E)(in S S0, in S S1)
	{
		auto 	S	= S1.p[0] - S0.p[0],
			T	= S0.p[1] - S0.p[0],
			U 	= S1.p[0] - S1.p[1]; 
		auto det = crossZ(T, U); 
		
		if(abs(det)<1e-30) return false;  //Todo: this is lame
		
		auto detA = crossZ(S, U); 
		
		if(inRange_sorted(detA, 0, det))
		{
			//have one intersection
			auto detB = crossZ(T, S); 
			if(inRange_sorted(detB, 0, det)) {
				auto alpha = detA/det; 
				return true; 
			}
		}
		return false; 
	} 
	
	bool intersectSegs_falseParallel_prec(S: Segment!E, E)(in S S0, in S S1, ref E P)
	{
		auto 	S	= S1.p[0] - S0.p[0],
			T	= S0.p[1] - S0.p[0],
			U 	= S1.p[0] - S1.p[1]; 
		auto det = crossZ(T, U); 
		
		if(abs(det)<1e-30) return false;  //Todo: this is lame
		
		auto detA = crossZ(S, U); 
		
		if(inRange_sorted(detA, 0, det))
		{
			//have one intersection
			auto detB = crossZ(T, S); 
			if(inRange_sorted(detB, 0, det)) {
				auto alpha = detA/det; 
				P = S0.p[0]+T*alpha; 
				return true; 
			}
		}
		return false; 
	} 
	
	auto polyLineLength(R)(R arr)
	{ return arr.slide!(No.withPartial)(2).map!(a => (magnitude(a[1]-a[0]))).sum; } 
	
	float segmentPointDistance_prec(const vec2 v, const vec2 w, const vec2 p)
	{
		//Return minimum distance between line segment vw and point p
		const l2 = sqrLength(v-w);    //i.e. |w-v|^2 -  avoid a sqrt
		if(!l2) return distance(p, v); //v == w case
		//Consider the line extending the segment, parameterized as v + t (w - v).
		//We find projection of point p onto the line.
		//It falls where t = [(p-v) . (w-v)] / |w-v|^2
		//We clamp t from [0,1] to handle	points outside the segment vw.
		const t = max(0, min(1, dot(p - v,	w - v) / l2)); 
		const projection = v + (w - v)*t; 	//Projection falls on the segment
		return distance(p, projection); 
	} 
	
	//Todo: segmentPointDistance 3d
	/*
		vec3 segmentNearestPoint(vec3 S0, vec3 S1, vec3 P){
			vec3 v = S1 - S0;
			vec3 w = P - S0;
		
			float c1 = dot(w,v);
			if(c1<=0.0) return S0;
		
			float c2 = dot(v,v);
			if(c2<=c1) return S1;
		
			float b = c1 / c2;
			vec3 Pb = S0 + b * v;
			return Pb;
		}
		
		
		float segmentPointDistance(vec3 S0, vec3 S1, vec3 P){
			return distance(P, segmentNearestPoint(S0, S1, P));
		}
	*/
	
	
	/// 2D point position restriction inside bounds
	vec2 restrictPos_normal(T1, T2)(in Vector!(T1, 2) p, in Bounds!(Vector!(T2, 2)) bnd)
	{ return p.clamp(bnd.low, bnd.high); } 
	
	vec2 restrictPos_editor(T1, T2)(in Vector!(T1, 2) p, in Bounds!(Vector!(T2, 2)) bnd)
	{
		return 	p.y<bnd.top ? bnd.topLeft :
			p.y>bnd.bottom ? bnd.bottomRight :
			vec2(p.x.clamp(bnd.left, bnd.right), p.y); 
	} 
	
	///  Bresenham line drawing /////////////////////////////////////////////////////////////////////
	
	void line_bresenham(in ivec2 a, in ivec2 b, bool skipFirst, void delegate(in ivec2) dot)
	{
		auto 	d	= b-a,
			d1 	= abs(d),
			p	= ivec2(
			2*d1.y-d1.x,
			2*d1.x-d1.y
		),
			i	= (d.x<0)==(d.y<0) ? 1 : -1; 
		d1 *= 2; 
		
		void dot2(in ivec2 p) { if(!skipFirst || p!=a) dot(p); } 
		
		int e; ivec2 v; 
		if(d1.y<=d1.x)	{
			if(d.x>=0) { v=a; e=b.x; }
			else { v=b; e=a.x; }
			dot2(v); 
			while(v.x<e) {
				++v.x; 
				if(p.x<0) { p.x += d1.y; 		}
				else { p.x += d1.y-d1.x; 	v.y += i; 	}
				dot2(v); 
			}
		}
		else	{
			if(d.y>=0) { v=a; e=b.y; }
			else { v=b; e=a.y; }
			dot2(v); 
			while(v.y<e) {
				++v.y; 
				if(p.y<0) { p.y += d1.x; 		}
				else { p.y += d1.x-d1.y; 	v.x += i; 	}
				dot2(v); 
			}
		}
	} 
	
	///	 Cohen Sutherland line-rect Clipping ///////////////////////////////////////////////////////////////
	///	 Ported to Delphi from wikipedia C code by Omar Reis - 2012	                         ///
	///	 Ported back to C by realhet 2013, lol	                         ///
	///	 Ported finally to D by realhet 2016, lol**2	                         ///
	
	bool _lineClip(V, E, F)(in V bMin, in V bMax, ref V a, ref V b)
	{
		const 	INSIDE	= 0, //0000
			LEFT	= 1, //0001
			RIGHT	= 2, //0010
			BOTTOM	= 4, //0100
			TOP	= 8 //1000
		; 
		
		int computeOutCode(const V v) const
		{
			int res = INSIDE; //initialised as being inside of clip window
			
			if(v.x < bMin.x) res |= LEFT; 
			else if(
				v.x > bMax.x//to the left of clip window
			)
			res |= RIGHT; 
			//to the right of clip window
			
			if(v.y < bMin.y) res |= BOTTOM; 
			else if(
				v.y > bMax.y//below the clip window
			)
			res |= TOP; 
			//above the clip window
			
			return res; 
		} 
		
		//compute outcodes for P0, P1, and whatever point lies outside the clip rectangle
		int outcode0 = computeOutCode(a); 
		int outcode1 = computeOutCode(b); 
		while(1)
		{
			if((outcode0 | outcode1)==0) {
				 //Bitwise OR is 0. Trivially result and get out of loop
				return true; 
			}
			else if(outcode0 & outcode1) {
				 //Bitwise AND is not 0. Trivially reject and get out of loop
				return false; 
			}
			else {
				//failed both tests, so calculate the line segment to clip
				//from an outside point to an intersection with clip edge
				//At least one endpoint is outside the clip rectangle; pick it.
				int outcodeOut = outcode0 ? outcode0 : outcode1; 
				//Now find the intersection point;
				//use formulas y = a.y + slope * (x - a.x), x = a.x + (1 / slope) * (y - a.y)
				F x,y; 
				if(outcodeOut & TOP)	{
					//point is above the clip rectangle
					x = a.x + (b.x - a.x) * (bMax.y - a.y) / (b.y - a.y); 
					y = bMax.y; 
				}
				else if(outcodeOut & BOTTOM)	{
					//point is below the clip rectangle
					x	= a.x + (b.x - a.x) * (bMin.y - a.y) / (b.y - a.y); 
					y	= bMin.y; 
				}
				else if(outcodeOut & RIGHT)	{
					//point is to the right of clip rectangle
					y	= a.y + (b.y - a.y) * (bMax.x - a.x) / (b.x - a.x); 
					x	= bMax.x; 
				}
				else	{
					//point is to the left of clip rectangle
					y = a.y + (b.y - a.y) * (bMin.x - a.x) / (b.x - a.x); 
					x = bMin.x; 
				}
				
				/*
					Note: if you follow this algorithm exactly(at least for c#),
					then you will fall into an infinite loop
					in case a line crosses more than two segments. 
					To avoid that problem, leave out the last else
					if(outcodeOut & LEFT) and just make it else 
				*/
				
				//Now we move outside point to intersection point to clip
				//and get ready for next pass.
				if(outcodeOut==outcode0) {
					a.x = cast(E)x; 
					a.y = cast(E)y; 
					outcode0 = computeOutCode(a); 
				}
				else {
					b.x = cast(E)x; 
					b.y = cast(E)y; 
					outcode1 = computeOutCode(b); 
				}
			}
		}
	} 
	//lineClip()
	
	
	
	/// Nearest finders ///////////////////////////////////////////////////////////////
	
	int distManh(in ibounds2 b, in ivec2 p)
	{ with(b) return max(max(left-p.x, p.x-right, 0), max(top-p.y, p.y-bottom, 0)); } 
	
	auto findNearestManh(in ibounds2[] b, in ivec2 p)
	{
		auto idx = b.map!(r => r.distManh(p)).array.minIndex; 
		if(idx<0) return ibounds2(); 
		else return b[idx]; 
	} 
	
	auto findNearestManh(ibounds2[] b, in ivec2 p, int maxDist, int* actDist=null)
	{
		auto idx = b.map!(r => r.distManh(p)).array.minIndex; 
		if(idx<0) {
			if(actDist) *actDist = int.max; 
			return ibounds2(); 
		}else {
			int d = b[idx].distManh(p); 
			if(actDist) *actDist = d; 
			if(d>maxDist) return ibounds2(); 
			else return b[idx]; 
		}
	} 
	
	//Linear fit ///////////////////////////////////////////////////////////////////////
	
	struct LinearFitResult
	{
		vec2[] points; 
		float slope=0; 
		float intercept=0; 
		
		float deviation = 0; 
		int worstIdx = -1; 
		bool isGood; //optimizer fills it
		
		bool isNull() const
		{ return !slope && !intercept; } 
		
		float y(float x)
		{ return intercept+x*slope; } 
	} 
	
	auto linearFit(in vec2[] data)
	{
		auto xSum	= data.map!"a.x".sum,
				 ySum	= data.map!"a.y".sum,
				 xxSum	= data.map!"a.x*a.x".sum,
				 xySum	= data.map!"a.x*a.y".sum,
				 len =	data.length.to!float; 
		
		LinearFitResult res; 
		
		if(data.length>=2) {
			res.points = data.dup; 
			res.slope = (len*xySum - xSum*ySum) / (len * xxSum - xSum * xSum); 
			res.intercept = (ySum - res.slope * xSum) / len; 
		}
		else { if(data.length==1) { res.intercept = data[0].y; }else { return res; }}
		
		auto error(in vec2 p) { return res.y(p.x)-p.y; } 
		res.deviation = sqrt(data.map!(p => error(p)^^2).sum/(data.length.to!int-1)); 
		res.worstIdx = data.map!(p => abs(error(p))).maxIndex.to!int; 
		
		return res; 
	} 
	
	auto linearFit(in vec2[] data, int requiredPoints, float maxDeviation)
	{
		auto fit = linearFit(data); 
		
		while(1) {
			fit.isGood = fit.points.length>=requiredPoints && fit.deviation<maxDeviation; 
			if(fit.isGood) break; 
			if(fit.points.length<=requiredPoints) break; 
			fit = linearFit(fit.points.remove(fit.worstIdx)); 
		}
		
		return fit; 
	} 
	
	//Quadratic fit ///////////////////////////////////////////////////////////////////////
	
	struct QuadraticFitResult
	{
		//Todo: combine Quadratic and linear fitter
		vec2[] points; 
		float a=0, b=0, c=0; 
		
		float deviation = 0; 
		int worstIdx = -1; 
		bool isGood; //optimizer fills it
		
		bool isNull() const { return !a && !b && !c; } 
		
		float y(float x) const { return a*x^^2 + b*x + c; } 
		
		vec2 location() const
		{
			float ly = 0; 
			const lx = peakLocation(a, b, c, &ly); 
			return vec2(lx, ly); 
		} 
		
		float location_x() const
		{ return peakLocation(a, b, c); } 
	} 
	
	private float det(float a, float b, float c, float d)
	{ return a*d-c*b; } //Todo: combine this with math.det
	private float det(float a, float b, float c, float d, float e, float f, float g, float h, float i)
	{
		return 	+a*det(e, f, h, i)
			-d*det(b, c, h, i)
			+g*det(b, c, e, f); 
	} 
	
	auto quadraticFit(in vec2[] data)
	{
		NOTIMPL; //Todo: this is possibly buggy. must refactor.
		
		QuadraticFitResult res; 
		if(data.length<3) {
			if(data.length==2) {
				auto lin = linearFit(data); //get it from linear
				res.b = lin.slope; 
				res.c = lin.intercept; 
				res.deviation = lin.deviation; 
				res.worstIdx = lin.worstIdx; 
			}
			return res; 
		}
		
		//https://www.codeproject.com/Articles/63170/Least-Squares-Regression-for-Quadratic-Curve-Fitti
		//notation sjk to mean the sum of x_i^j*y_i^k.
		//Todo: optimize this with .tee or	something to access x and y only once
		float 	s40 = data.map!"a.x^^4".sum,	//sum of x^4
			s30 = data.map!"a.x^^3".sum,	//sum of x^3
			s20 = data.map!"a.x^^2".sum,	//sum of x^2
			s10 = data.map!"a.x".sum,	//sum of x
			s00 = data.length,	//sum of x^0 * y^0	ie 1 * number of entries
			s21 = data.map!"a.x^^2*a.y".sum,	//sum of x^2*y
			s11 = data.map!"a.x*a.y".sum,	//sum of x*y
			s01 = data.map!"a.y".sum	//sum of y
		; 
		
		auto D = det(
			s40, s30, s20,
			s30, s20, s10,
			s20, s10, s00
		); 
		res.a = det(
			s21, s30, s20,
			s11, s20, s10,
			s01, s10, s00
		)/D; 
		res.b = det(
			s40, s21, s20,
			s30, s11, s10,
			s20, s01, s00
		)/D; 
		res.c = det(
			s40, s30, s21,
			s30, s20, s11,
			s20, s10, s01
		)/D; 
		
		res.points = data.dup; 
		
		//copied from lin
		auto error(in vec2 p) { return res.y(p.x)-p.y; } 
		res.deviation = sqrt(data.map!(p => error(p)^^2).sum/(data.length.to!int-1)); 
		res.worstIdx = data.map!(p => abs(error(p))).maxIndex.to!int; 
		
		return res; 
	} 
	auto mirrorPointOverLine(V, T2, T3)(V P, T2 A, T3 B)
	{
		const 	d = B - A,
			mx = ((V(d.x*d.x - d.y*d.y, d.x*d.y*2))/(d.x*d.x + d.y*d.y)),
			my = mx.rotate270,
			a = P - A; 
		return mx*a.x + my*a.y + A; 
	} 
	
	auto extrapolateCurve(V)(V A, V B)
	{ return B + (B-A); } 
	
	auto extrapolateCurve(V)(V A, V B, V C)
	{
		//Continuity: C1
		static if(1)
		{
			//this is simpler, only uses 1 div and no trigonometryc functions
			//Opt: Measure how fast and precise it is.
			const M1 = (B+C)/2, M2 = M1 + (B-C).rotate90; 
			return mirrorPointOverLine(A, M1, M2); 
		}
		else
		{
			const 	v1 = (B-A).normalize,
				v2 = (C-B).normalize,
				a = asin(cross(v1, v2).z); 
			return C + (C-B).rotate(a); 
		}
	} 
	
	auto extrapolateCurve(V)(V A, V B, V C, V D)
	{
		//Continuity: C2
		const 	v1 = (B-A).normalize,
			v2 = (C-B).normalize,
			v3 = (D-C).normalize,
			a1 = asin(cross(v1, v2).z),
			a2 = asin(cross(v2, v3).z),
			a3 = a2 + (a2-a1); 
		return D + (D-C).rotate(a3); 
	} 
	
	T extrapolateCurveFront(R, T=ElementType!R)(R r)
	{
		if(r.empty) return T.init; 
		const A = r.front; r.popFront; 
		if(r.empty) return A; 
		const B = r.front; r.popFront; 
		if(r.empty) return extrapolateCurve(B, A); 
		const C = r.front; r.popFront; 
		if(r.empty) return extrapolateCurve(C, B, A); 
		const D = r.front; 
		return extrapolateCurve(D, C, B, A); 
	} 
	
	T[2] linearBezierWeights(T)(T t)
	{
		const u = 1-t; 
		return [u, t]; 
	} 	T[2] linearBezierTangentWeights(T)(T t)
	{ return [-1, 1]; } 
	T[3] quadraticBezierWeights(T)(T t)
	{
		const u = 1-t; 
		return [((u)^^(2)), 2*u*t, ((t)^^(2))]; 
	} 	T[3] quadraticBezierTangentWeights(T)(T t)
	{
		const u = 1-t; 
		return [-2*u, 2*(u - t), 2*t]; 
	} 
	T[4] cubicBezierWeights(T)(T t)
	{
		const u = 1-t; 
		return [((u)^^(3)), 3*t*((u)^^(2)), 3*u*((t)^^(2)), ((t)^^(3))]; 
	} 		T[4] cubicBezierTangentWeights(T)(T t)
	{
		const u = 1-t; 
		return [-3*((u)^^(2)), 3*((u)^^(2)) - 6*u*t, 6*u*t - 3*((t)^^(2)), 3*((t)^^(2))]; 
	} 
	auto evalBezier(F, int N)(in Vector!(F, 2)[N] p, F t)
	{
		const w = AliasSeq!(
			linearBezierWeights, 
			quadraticBezierWeights, 
			cubicBezierWeights
		)[N-2](t); 
		
		auto res = p[0]*w[0]; 
		static foreach(i; 1..p.length) res += p[i]*w[i]; 
		return res; 
	} 	auto evalBezierTangent(F, int N)(in Vector!(F, 2)[N] p, F t)
	{
		const w = AliasSeq!(
			linearBezierTangentWeights,
			quadraticBezierTangentWeights,
			cubicBezierTangentWeights
		)[N-2](t); 
		
		auto res = p[0]*w[0]; 
		static foreach(i; 1..p.length) res += p[i]*w[i]; 
		return res; 
	} 
	
	
	T[4][2] splitBezier(T)(T[4] P, float t=.5)
	{
		const 	A = mix(mixin(指(q{P},q{0})), mixin(指(q{P},q{1})), t),
			B = mix(mixin(指(q{P},q{1})), mixin(指(q{P},q{2})), t),
			C = mix(mixin(指(q{P},q{2})), mixin(指(q{P},q{3})), t),
		D = mix(A, B, t),
		E = mix(B, C, t),
		F = mix(D, E, t); 
		return [[mixin(指(q{P},q{0})), A, D, F], [F, E, C, mixin(指(q{P},q{3}))]]; 
	} 
	
	auto generateBezierPolyline_equalSteps(F, int N)(in Vector!(F, 2)[N] p, F stepSize=1)
	{
		
		auto eval(F t)
		{ return evalBezier(p, t); } 
		
		const 	roughCount	= iround(5*p[].polyLineLength/stepSize).max(1),
			invRoughCount 	= F(1)/roughCount,
			points	= iota(roughCount+F(1)).map!(i => eval(i*invRoughCount)).array,
			lengths	= points.slide!(No.withPartial)(2).map!(a => distance(a[0], a[1])).array,
			totalLen	= lengths.sum,
			segmentCount	= iround(totalLen/stepSize).max(1),
			segmentLen	= totalLen/segmentCount; 
		
		F writtenLen = 0, prevLen = 0; F[] t; 
		loop:  //resample the t values using linear interpolation
		foreach(i, actLen; lengths)
		{
			while(writtenLen.inRange(prevLen, prevLen+actLen))
			{
				t ~= (i + writtenLen.remap(prevLen, prevLen+actLen, 0, 1))*invRoughCount; 
				writtenLen += segmentLen; 
				if(t.length==segmentCount) break loop; 
			}
			prevLen += actLen; 
		}
		t ~= 1;  //the last point must be exactly 1.0
		
		return t.map!(a => eval(a)).array; 
	} 
	version(/+$DIDE_REGION SVG path helpers+/all)
	{
		int approximateArcToCubicBeziers	(
			in vec2 P0, vec2 R_, in float rotation_deg, 
			in bool large_arc, in bool sweep, in vec2 P1,
			void delegate(const ref vec2[4]) onItem
		)
		{
			enum float PI = π; 
			
			auto R = abs(R_), R2 = ((R)^^(2)); 
			if(!R.x || !R.y) return 0; 
			
			const 	θ 	= rotation_deg.radians,
				mid 	= (P0-P1)/2,
				A 	= mid.rotate(-θ), A2 = ((A)^^(2)); 
			
			const λ = (A2/R2).sum; 
			if(λ>1) R *= (sqrt(λ)),  R2 = ((R)^^(2)); 
			
			float factor = 0; 
			const 	den 	= ((R2).dot(A2.yx)),
				num 	= R2.x*R2.y - den; 
			if(den>0 && num>0)
			{
				factor = (sqrt(num/den)); 
				if(large_arc == sweep) factor *= -1; 
			}
			
			auto CP = factor * vec2(((R.x*A.y)/(R.y)), ((-R.y*A.x)/(R.x))); 
			const U = ((A-CP)/(R)), V = ((-A-CP)/(R)); 
			
			const φ_start = atan(U.y, U.x); 
			float Δφ = atan(V.y, V.x) - φ_start; 
			if(!sweep && Δφ > 0)	{ Δφ -= 2*PI; }
			else if(sweep && Δφ < 0)	{ Δφ += 2*PI; }
			
			const n = (iround((((magnitude(Δφ)))/(PI/2)))).clamp(1, 4); 
			if(onItem !is null)
			{
				const mRotθ = mat2.rotation(θ); 
				CP = mRotθ * CP + avg(P0, P1); 
				
				const segment_Δφ = Δφ / n; 
				const α = (4.0f/3) * tan(segment_Δφ/4); 
				
				vec2[4] C = void; C[0] = P0/*exact startPoint*/; 
				float φ = φ_start; 
				vec2 Rs = vec2(1, 0).rotate(φ), Re; 
				int i=0; 
				while(1)
				{
					const isLast = i==n-1; 
					
					φ += segment_Δφ; 
					Re = vec2(1, 0).rotate(φ); 
					
					const T0 = mRotθ * (R*Rs.rotate90); 
					C[1] = C[0] + α*T0; 
					
					C[3] = ((isLast)?(P1/*exact endPoint*/) :(CP + mRotθ * (R*Re))); 
					const T3 = mRotθ * (R*Re.rotate90); 
					C[2] = C[3] - α*T3; 
					
					onItem(C); 
					
					if(isLast) break; 
					/+advance+/C[0] = C[3]; Rs = Re; i++; 
				}
			}
			return n; 
		} 
		
		enum SvgPathCommand
		{
			Z,	//ClosePath (x,y)
			M,	//MoveTo (x,y)
			L,	//LineTo (x,y)
			T,	//Smooth Quadratic Bezier (x,y)
			Q,	//Quadratic Bezier (x1,y1 x,y)
			S,	//Smooth Cubic Bezier (x2,y2 x,y)
			C,	//Cubic Bezier (x1,y1 x2,y2 x,y)
			A,	//Arc (rx,ry rotation, flags(large, sweep), x,y)
		} 
		
		struct SvgPathItem
		{
			SvgPathCommand cmd; 
			vec2[3] data; 
		} 
		
		alias SvgPathItemEvent = void delegate(const ref SvgPathItem item); 
		
		void approximateArcToCubicBeziers(in vec2 P0, in SvgPathItem item, SvgPathItemEvent onPathItem)
		{
			bool running = false; 
			if(
				!approximateArcToCubicBeziers
				(
					P0, item.data[0], item.data[1].x, 
					((itrunc(item.data[1].y))&1)!=0, ((itrunc(item.data[1].y))&2)!=0,
					item.data[2],
					((P){
						SvgPathItem item; 
						if(!running)	{ item.cmd = SvgPathCommand.C; item.data[0..3] = P[1..4]; }
						else	{ item.cmd = SvgPathCommand.S; item.data[0..2] = P[2..4]; }
						onPathItem(item); 
						running = true; 
					})
				)
			)
			{
				if(P0!=item.data[2])
				{
					SvgPathItem line; 
					line.cmd = SvgPathCommand.S; line.data[0] = item.data[2]; 
					onPathItem(line); 
					
				}
			}
		} 
		
		void parseSvgPath(string svgPath, SvgPathItemEvent onPathItem)
		{
			auto parser = SvgPathParser(onPathItem, svgPath); 
			parser.parse; 
		} 
		
		struct SvgPathParser
		{
			SvgPathItemEvent onPathItem; 
			string svgPath; 
			size_t index = 0; 
			
			vec2 currentPoint = vec2(0,0); 
			vec2 subpathStart = vec2(0,0); 
			char currentCommand = 0; 
			bool currentIsRelative = false; 
			
			uint numParams = 0; 
			float[7] numbers; 
			
			SvgPathItem item; 
			
			static char toUpper(char c)
			=> ((mixin(界3(q{'a'},q{c},q{'z'})))?((cast(char)(c - 'a' + 'A'))):(c)); 
			
			static void skipWhite(string s, ref size_t index)
			{
				while(
					index < s.length && 
					s[index].among(' ', ',', '\t', '\r', '\n')
				)
				{ index++; }
			} 
			
			static float parseNumber(string s, ref size_t index) 
			{
				static bool isDigit(char c)
				=> mixin(界3(q{'0'},q{c},q{'9'})); 
				
				skipWhite(s, index); 
				if(index >= s.length)
				{ return 0.0; }
				
				size_t start = index; 
				
				if(s[index].among('+', '-'))
				{ index++; }
				
				while(index < s.length && isDigit(s[index]))
				{ index++; }
				
				if(index < s.length && s[index] == '.')
				{
					index++; 
					while(index < s.length && isDigit(s[index]))
					{ index++; }
				}
				
				if(index < s.length && s[index].among('e', 'E'))
				{
					index++; 
					if(index < s.length && s[index].among('+', '-'))
					{ index++; }
					while(index < s.length && isDigit(s[index]))
					{ index++; }
				}
				
				if(index == start)
				{ return 0.0; }
				
				string numStr = s[start .. index]; 
				try { return numStr.parse!float; }
				catch(ConvException e) { return 0.0; }
			} 
			void parseCommand()
			{
				char c = svgPath[index]; 
				if(mixin(界3(q{'A'},q{c},q{'Z'})) || mixin(界3(q{'a'},q{c},q{'z'})))
				{
					index++; 
					currentCommand = toUpper(c); 
					currentIsRelative = mixin(界3(q{'a'},q{c},q{'z'})); 
				}
			} 
			
			bool parseParams()
			{
				switch(currentCommand)
				{
					case 'H', 'V': 	numParams = 1; 	break; 
					case 'M', 'L', 'T': 	numParams = 2; 	break; 
					case 'Q', 'S': 	numParams = 4; 	break; 
					case 'C': 	numParams = 6; 	break; 
					case 'A': 	numParams = 7; 	break; 
					default: 	numParams = 0; 
				}
				
				assert(numParams<=numbers.length); 
				foreach(i; 0..numParams)
				numbers[i] = parseNumber(svgPath, index); 
				
				return numParams>0; 
			} 
			
			void resolveHVLine()
			{
				if(currentCommand == 'H')
				{
					numbers[1] = currentIsRelative ? 0 : currentPoint.y; 
					currentCommand = 'L'; numParams = 2; 
				}
				else if(currentCommand == 'V')
				{
					numbers[1] = numbers[0]; 
					numbers[0] = currentIsRelative ? 0 : currentPoint.x; 
					currentCommand = 'L'; numParams = 2; 
				}
			} 
			
			void processRelative()
			{
				if(currentIsRelative)
				{
					void applyRelative(ref float[2] v)
					{
						v[0] += currentPoint.x; currentPoint.x = v[0]; 
						v[1] += currentPoint.y; currentPoint.y = v[1]; 
					} 
					if(currentCommand == 'A')
					{ applyRelative(numbers[numParams-2..numParams][0..2]); }
					else
					{
						for(int i = 0; i < numParams; i += 2)
						{ applyRelative(numbers[i..i+2][0..2]); }
					}
				}
				else
				{ currentPoint = numbers[numParams-2..numParams][0..2]; }
			} 
			void parse(string s)
			{ svgPath = s; index = 0; parse; } 
			
			void parse()
			{
				while(index < svgPath.length)
				{
					skipWhite(svgPath, index); if(index >= svgPath.length) break; 
					
					parseCommand; 
					if(currentCommand == 'Z')
					{
						item.cmd = SvgPathCommand.Z; 
						item.data[0] = subpathStart; 
						onPathItem(item); 
						currentPoint = subpathStart; 
						currentCommand = 0; 
					}
					else if(currentCommand && parseParams)
					{
						resolveHVLine; 
						processRelative; 
						
						item.cmd = SvgPathCommand.Z; 
						
						switch(currentCommand)
						{
							case 'M': 	item.cmd = SvgPathCommand.M, 
							currentCommand = 'L'; 	break; 
							case 'L': 	item.cmd = SvgPathCommand.L; 	break; 
							case 'Q': 	item.cmd = SvgPathCommand.Q; 	break; 
							case 'T': 	item.cmd = SvgPathCommand.T; 	break; 
							case 'C': 	item.cmd = SvgPathCommand.C; 	break; 
							case 'S': 	item.cmd = SvgPathCommand.S; 	break; 
							case 'A': 	item.cmd = SvgPathCommand.A; 	break; 
							default: 	assert(false, "Unhandled"); 	break; 
						}
						
						switch(item.cmd)
						{
							case SvgPathCommand.M, SvgPathCommand.L, SvgPathCommand.T: 
								item.data[0] = vec2(numbers[0], numbers[1]); 
								if(item.cmd == SvgPathCommand.M)
							{ subpathStart = currentPoint; }
								break; 
							case SvgPathCommand.Q, SvgPathCommand.S: 
								item.data[0] = vec2(numbers[0], numbers[1]); 
								item.data[1] = vec2(numbers[2], numbers[3]); 
								break; 
							case SvgPathCommand.C: 
								item.data[0] = vec2(numbers[0], numbers[1]); 
								item.data[1] = vec2(numbers[2], numbers[3]); 
								item.data[2] = vec2(numbers[4], numbers[5]); 
								break; 
							case SvgPathCommand.A: 
								const 	rx 	= numbers[0], 
								ry 	= numbers[1],
								rotation 	= numbers[2], 
								large_arc 	= numbers[3]!=0, 
								sweep 	= numbers[4]!=0,
								flags 	= large_arc | sweep<<1,
								x 	= numbers[5], 
								y 	= numbers[6]; 
								item.data[0] = vec2(rx, ry); 
								item.data[1] = vec2(rotation, flags); 
								item.data[2] = vec2(x, y); 
								break; 
							default: 
						}
						
						onPathItem(item); 
					}
					else
					{ index++; }
				}
			} 
		} 
	}
	
	
	
	
	alias TurtleF = Turtle_!float, 
	TurtleD = Turtle_!double; 
	
	struct Turtle_(T)
	{
		alias V=Vector!(T, 2); 
		
		void delegate(V[]) onPointsCollected; 
		T stepSize=1; 
		
		version(/+$DIDE_REGION Turtle state+/all)
		{
			//state variables
			V pos, dir=V(1, 0); 
			
			void home()
			{ pos = 0; dir = V(1, 0); } 
			
			@property state()
			{ return tuple(pos, dir); }  @property state(Tuple!(V, V) a)
			{ pos = a[0]; dir = a[1]; } 
			
			private Tuple!(V, V)[] stack; 
			void push()
			{
				enforce(stack.length<32, "Turtle stack oveflow."); 
				stack ~= state; 
			} 
			void pop()
			{
				enforce(stack.length, "Turtle stack underflow."); 
				state = stack.back; stack.popBack; 
			} 
		}
		
		bool active = true;  void on()
		{ active = true; }  void off()
		{ active = false; } 
		
		
		private V[] _points; 
		
		private void sink(V p)
		{
				if(active)
			if(_points.empty || _points.back!=p)
			_points ~= p; 
		} 
		
		private void collectPoints(void delegate() fun, bool emit=true)
		{
			scope(exit) _points.clear; 
			fun(); 
			if(emit && _points.length>=2)
			onPointsCollected(_points); 
		} 
		
		private auto captureStartEndPosDir(void delegate() fun)
		{
			const p0 = pos; const d0 = dir; //capture first point+dir
			//simulate draw commands, but don't generate anything
			collectPoints(fun, false); 
			auto res = tuple(p0, d0, pos, dir); 
			pos = p0; dir = d0; //restore pos/dir to initial values
			return res; 
		} 
		
		
		private
		{
			void line(
				in T length //negative goes backwards
			)
			{
				if(!length) return; 
				const 	segmentCount 	= ((abs(length))/(stepSize)).iround.max(1),
					endPos 	= pos + dir*length,
					step 	= (endPos-pos) * (T(1)/segmentCount); 
				sink(pos); 
				foreach(i; 0..segmentCount-1)
				{ pos += step; sink(pos); }
				pos = endPos; sink(pos); 
			} 
			
			void arc_angle(
				T θ, //negative: goes backwards on the same side
				T r, //-left, +right
				float adjust = 0 //clothoidal bending
			)
			{
				if(!θ) return; 
				if(θ<0) {
					//negative angle: backwards, same side (mirror)
					θ *= -1; dir *= -1; r *= -1; 
				}
				θ = θ.radians * r.sign; //turning direction is defined by radius
				
				const 	length	= abs(θ*r),
					segmentCount	= ((length)/(stepSize)).iround.max(1),
					segmentLength 	= ((length)/(segmentCount)),
					center	= pos + dir.rotate90 * r,
					endPos	= (pos-center).rotate(θ) + center,
					endDir	= (normalize(dir.rotate(θ))),
					Δθ 	= ((θ)/(segmentCount)); 
				if(adjust==0)
				{
					dir = (normalize(dir.rotate(Δθ / 2))) * segmentLength; 
					sink(pos); 
					foreach(i; 0..segmentCount-1)
					{
						pos += dir; sink(pos); 
						dir = dir.rotate(Δθ); 
					}
					pos = endPos; dir = endDir; 
					sink(pos); 
				}
				else
				{ bezier4(endPos, endDir, adjust); }
			} 
			
			void arc_length(
				T length, //negative: goes backwards on the same side
				T r, //-left, +right
				float adjust = 0 //clothoidal bending, (distorts length)
			)
			{
				if(!length) return; 
				const θ = ((length)/((magnitude(r)))).degrees; 
				arc_angle(θ, r, adjust); 
			} 
			
			void clothoid_accel(
				T ΔΔθ, //angle step increase between steps.
				T r_start, T r_end //negative = turn left
			)
			{
				if(!ΔΔθ) return; 
				if(ΔΔθ<0)
				{
					//negative angle: backwards, same side (mirror)
					ΔΔθ *= -1; dir *= -1; 
				}
				
				const 	segmentLength 	= stepSize,
					Δθ_start 	= segmentLength / r_start,
					Δθ_end 	= segmentLength / r_end; 
				
				//calculate actual angle acceleration
				ΔΔθ = (magnitude(ΔΔθ.radians)) * sign(Δθ_end - Δθ_start); 
				if(!ΔΔθ) return; 
				
				
				sink(pos); 
				T Δθ = Δθ_start + ΔΔθ; //the first point has acceleration too
				dir = (normalize(dir.rotate(Δθ/2))) * segmentLength; //sets dir.length
				while(
					(ΔΔθ>0 && Δθ<Δθ_end) || 
					(ΔΔθ<0 && Δθ>Δθ_end)
				)
				{
					pos += dir; sink(pos); 
					dir = dir.rotate(Δθ); 
					Δθ += ΔΔθ; 
				}
				
				/+
					Note: The final pos/dir is distorted by the iterative calculations, 
					but it's much simpler than FresnelC
				+/
				pos += dir; sink(pos); 
				dir = (normalize(dir.rotate(Δθ/2))); //restore dir.length
			} 
			
			void bezier4(V pos_end, V dir_end, float adjust=0)
			{
				/+
					Draw a cubic bezier curve from current pos/dir to a given pos/dir.
					The middle points can be adjusted to move close to each other, so it is 
					possible to emulate a clothoid using cubic bezier interpolation.
				+/
				V[4] cp; //The 4 control points
				{
					const len = (magnitude(pos_end - pos)) * 0.33333f * (1 + adjust); 
					
					cp[0] = pos; 
					cp[1]	= pos	+ (normalize(dir    ))*len,
					cp[2]	= pos_end	- (normalize(dir_end))*len; 
					cp[3] = pos_end; 
				}
				
				generateBezierPolyline_equalSteps(cp, stepSize).each!((p){ sink(p); }); 
				
				pos = pos_end; 
				dir = (normalize(dir_end)); 
			} 
		} 
		
		///G, M: line, arc, clothioid
		void G(double lengthOrAngle, double r0=0, double r1=0)
		{
			collectPoints
			(
				{
					if(r0==0)
					{ line(lengthOrAngle); }
					else if(r1==0)	{ arc_angle(lengthOrAngle, r0); }
					else	{ clothoid_accel(lengthOrAngle, r0, r1); }
				}
			); 
		} 
		
		///R: Adjustable arc
		
		void R(double angle, double r, float adjust=0)
		{ collectPoints({ arc_angle(angle, r, adjust); }); } 
		
		///B: cubic Bezier
		void B(void delegate() fun, float adjust=0)
		{
			const se = captureStartEndPosDir(fun); 
			collectPoints({ bezier4(se[2], se[3], adjust); }); 
		} 
		
		void build(in TurtleCmd tcmd)
		{
			bool bezierState; 
			void updateBezier(float adjust)
			{
				bezierState.toggle; 
				if(bezierState)
				{ push; off; }
				else	{
					const p = pos, d = dir; pop; on; 
					collectPoints({ bezier4(p, d, adjust); }); 
				}
			} 
			
			foreach(const item; tcmd.list)
			{
				with(item)
				{
					switch(op)
					{
						case TurtleOp.G: 	G(a0); 	break; 
						case TurtleOp.R: 	R(a0, a1, a2); 	break; 
						case TurtleOp.push: 	push; 	break; 
						case TurtleOp.pop: 	pop; 	break; 
						case TurtleOp.on: 	on; 	break; 
						case TurtleOp.off: 	off; 	break; 
						
						case TurtleOp.back: 	dir *= -1; 	break; 
						case TurtleOp.turn: 	dir = dir.rotate(a0.radians); 	break; 
						case TurtleOp.slide: 	pos += V(dir.rotate90*a0 + dir*a1); 	break; 
						case TurtleOp.bezier: 	updateBezier(a0); 	break; 
						default: 	raise("Unhandled TurtleCmd: "~this.text); 
					}
				}
			}
		} 
	} 
	
	enum TurtleOp : ubyte
	{G, R, push, pop, on, off, turn, back, slide, bezier} 
	
	struct TurtleCmd
	{
		struct Cmd
		{
			TurtleOp op; 
			double a0, a1, a2; 
		} 
		Cmd[] list; 
		TurtleCmd opBinary(string op: "+")(in TurtleCmd b) const
		{ return TurtleCmd(list.dup~b.list.dup); } 
		TurtleCmd opUnary(string op: "+")() const
		{ return TurtleCmd(list.dup); } 
		TurtleCmd opUnary(string op: "-")() const
		{ return TurtleCmd(Cmd(TurtleOp.back)~list.dup); } 
		TurtleCmd opBinary(string op: "-")(in TurtleCmd b) const
		{ return this+-b; } 
		TurtleCmd opBinary(string op: "*")(int n) const
		{ return TurtleCmd((n<0 ? (-this).list : list.dup).replicate(abs(n))); } 
		TurtleCmd opBinaryRight(string op: "*")(int n) const
		{ return this*n; } 
		TurtleCmd opBinary(string op: "/")(int n) const
		{
			enforce(list.length==1, "TurtleCmd: Invalid division of multiple commands."); 
			with(list.front)
			{
				if(op.among(TurtleOp.G, TurtleOp.R)) return TurtleCmd([TurtleCmd.Cmd(op, a0/n, a1, a2)]); 
				if(op==TurtleOp.slide) return TurtleCmd([TurtleCmd.Cmd(op, a0/n, a1/n, a2)]); 
				enforce(0, "TurtleCmd: Invalid division of command: "~op.text); 
				assert(0); 
			}
		} 
		
		void opOpAssign(string op)(TurtleCmd b)
		{ mixin("this = this "~op~" b;"); } 
	} 
	
	static turtleCmd(TurtleOp op, double a0=0, double a1=0, double a2=0)
	{ return TurtleCmd([TurtleCmd.Cmd(op, a0, a1, a2)]); } 
	static turtleCmd(string op)(double a0=0, double a1=0, double a2=0)
	{
		enum op_ = op.to!TurtleOp; 
		return turtleCmd(op_, a0, a1, a2); 
	} 
	
	mixin template TurtleCmdMixin(alias _Scale=1, alias _WAdjust=0.5)
	{
		//Inject this mixin into a struct to create a set of commands generating TurtleCmds
		
		static G(double len)
		{ return turtleCmd!"G"(len*_Scale); } 
		static R(double a, double r, double adjust=0)
		{ return turtleCmd!"R"(a, r*_Scale, adjust); } 
		static RW(double a, double r)
		{ return R(a, r, _WAdjust); } 
		
		static slide(double right, double forward=0) //slide: move to the side
		{ return turtleCmd!"slide"(right*_Scale, forward*_Scale); } 
		static turn(double angle) //turn: + = right
		{ return turtleCmd!"turn"(angle); } static back()
		{ return turtleCmd!"back"; } 
		static push()
		{ return turtleCmd!"push"; } static pop()
		{ return turtleCmd!"pop"; } 
		static branch(in TurtleCmd tcmd)
		{ return push + tcmd + pop; } 
		static on()
		{ return turtleCmd!"on"; } static off()
		{ return turtleCmd!"off"; } 
		
		static M(in TurtleCmd tcmd)
		{ return off + tcmd + on; } //move
		
		static B(in TurtleCmd tcmd, double adjust=0)
		{
			/+
				the bezier turtleOp is a toggle: thsi first records the starting pos/dir, 
							the second records the ending pos/dir and draws the curve.
			+/
			return turtleCmd!"bezier"(adjust) + tcmd + turtleCmd!"bezier"(adjust); 
		} 
		static BW(in TurtleCmd tcmd)
		{ return B(tcmd, _WAdjust); } //bezier for switches
		
		static fork(A...)(in A a)
		{
			static if(a.length==1)
			return a[0]; 
			else static if(a.length>1) return push + a[0] + pop + fork(a[1..$]); 
			//it leaves the turtle at the tip of the last branch.
		} 
	} 
}