module het.algorithm; 
import het; 
version(/+$DIDE_REGION+/all)
{
	
	
	
	//////////////////////////////////////////////////////////////////////
	///  FloodFill, Blob detection                                     ///
	//////////////////////////////////////////////////////////////////////
	
	struct Blob
	{
		ivec2 pos; 
		int id; 
		int area; 
		
		auto calcBounds(T)(T im)
		{
			//Note: image must be the one generated by findBlobs()!!! The image is filled with 0's and id's.
			auto bnd = ibounds2(pos, pos+1); 
			
			bool growUp()
			{
				const res = bnd.top>0 && im[bnd.left..bnd.right, bnd.top-1].asArray.any!(a => a==id); 
				if(res) bnd.top --; 
				return res; 
			} 
			
			bool growDown()
			{
				const res = bnd.bottom<im.height && im[bnd.left..bnd.right, bnd.bottom].asArray.any!(a => a==id); 
				if(res) bnd.bottom ++; 
				return res; 
			} 
			
			bool growLeft()
			{
				const res = bnd.left>0 && im[bnd.left-1, bnd.top..bnd.bottom].asArray.any!(a => a==id); 
				if(res) bnd.left --; 
				return res; 
			} 
			
			bool growRight()
			{
				const res = bnd.right<im.width && im[bnd.right, bnd.top..bnd.bottom].asArray.any!(a => a==id); 
				if(res) bnd.right ++; 
				return res; 
			} 
			
			while(1) {
				bool any; 
				if(growDown) any = true; 
				if(growRight) any = true; 
				if(growUp) any = true; 
				if(growLeft) any = true; 
				if(!any) break; 
			}
			
			return bnd; 
		} 
	} 
	
	auto findBlobs(alias pred = "a", T1)(Image!(T1, 2) src)
	{
		bool boolSrc(int x, int y)
		{ return !!(src[x, y].unaryFun!pred); } 
		
		struct Res {
			Image!(int, 2) img; 
			Blob[int] blobs; 
			alias blobs this; 
		} 
		
		Res res; 
		res.img = image2D(src.size, 0); 
		
		int[int] map_; 
		int map(int i) { if(auto a = i in map_) return *a; else return i; } 
		
		int actId; 
		
		//first pass: find the blobs based on top and left neighbors
		
		foreach(y; 0..src.height)
		foreach(x; 0..src.width)
		if(boolSrc(x, y))
		{
			bool leftSet()
			{ return x ? boolSrc(x-1, y) : false; } 	bool topSet ()
			{ return y ? boolSrc(x, y-1) : false; } 
			int leftId()
			{ return res.img[x-1, y]; } 	int topId ()
			{ return res.img[x, y-1]; } 
			int p; 
			
			if(leftSet && topSet)
			{
				p = map(topId); 	//map is important for topId
				int l = leftId; 	//leftId is alrteady mapped
				if(p!=l) {
					sort(p, l); 	//sort is to eliminate cyclic loops im map_[]
					map_[l] = p; 	//from unmapped to mapped is good
				}
			}
			else if(topSet)
			{
				p = map(topId ); 	//map is important for topId
			}
			else if(leftSet)
			{
				p = leftId; 	//leftId is already mapped
			}
			else
			{ p = ++actId; res.blobs[p] = Blob(ivec2(x, y), p); }
			
			res.img[x, y] = p; 
			res.blobs[p].area++; 
			
			static if(is(findBlobsDebug))
			findBlobsDebug.log(ivec2(x, y), src.dup, res.img.dup, map_.dup, res.blobs.dup); 
		}
		
		
		
		{
			//make the map recursive
			//print("FUCK"); map_.keys.sort.each!(k => print(k, "->", map_[k]));
			int map_recursive(int id)
			{
				while(1) if(auto a = id in map_) id = *a; else break; 
				//Todo: install latest LDC
				return id; 
			} 
			foreach(k; map_.keys) map_[k] = map_recursive(k); 
			//remap the result id image
			foreach(ref p; res.img) if(p) p = map(p); 
		}
		
		{
				//remap the result blobs
			int[] rem; 
			foreach(k; res.blobs.keys) {
					//Opt: maybe the .array is not needed
				int p = map(k); 
				if(p!=k) {
					res.blobs[p].area += res.blobs[k].area; 
					rem ~= k; 
				}
			}
			rem.each!(k => res.blobs.remove(k)); 
		}
		
		static if(is(findBlobsDebug))
		findBlobsDebug.log(ivec2(-1), src.dup, res.img.dup, map_.dup, res.blobs.dup); 
		
		return res; 
	} 
	
	static if(0)
	struct findBlobsDebug
	{
		import het.draw2d, het.ui; static: 
		struct Event
		{
			ivec2 actPos; 
			Image!(ubyte, 2) src; 
			Image!(int, 2) dst; 
			int[int] idMap; 
			Blob[int] blobs; 
			
			void draw(Drawing dr)
			{
				with(dr) {
					fontHeight = .8; 
					
					void setColor(int i)
					{ color = hsvToRgb(([i].xxh32&255)/255.0f, 1, 1).floatToRgb; } 
					
					foreach(y; 0..src.height)
					foreach(x; 0..src.width)
					{
						translate(x, y); 
						
						if(src[x, y]) setColor(dst[x, y]); else color = clBlack; 
						drawRect(0.05, 0.05, 0.95, 0.95); 
						
						if(dst[x, y]) textOut(0.1, 0.1, dst[x, y].to!string(36)); 
						
						pop; 
					}
					
					
					color = clWhite; 
					foreach(i, k; idMap.keys.sort.array)
					{
						translate(src.width+2, i); 
						textOut(0, 0, k.to!string(36) ~ " -> " ~ idMap[k].to!string(36)); 
						pop; 
					}
					
					
					foreach(k, v; blobs)
					{
						translate(v.pos); 
						setColor(k); 
						fontHeight = 0.8; 
						textOut(0.1, 0.1, k.to!string(36)); 
						color = clWhite; 
						fontHeight = 0.3; 
						textOut(0.1, 0.7, v.area.text); 
						circle(vec2(.5), 0.7); 
						pop; 
					}
					
				}
			} 
		} 
		
		Event[] events; 
		
		void log(A...)(A a)
		{ events ~= Event(a); } 
		
		int actEventIdx; 
		
		void UI()
		{
			with(im)
			Row(
				{
					Text("FindBlobs debug idx:"); 
					const r = range(0, events.length.to!int-1); 
					IncDec(actEventIdx, r); 
					Slider(actEventIdx, r, { width = fh*32; }); 
				}
			); 
			
			
		} 
		
		void draw(Drawing dr)
		{ events.get(actEventIdx).draw(dr); } 
	} 
	
	//////////////////////////////////////////////////////////////////////
	///  2D MaxRects Bin Packer                                        ///
	//////////////////////////////////////////////////////////////////////
	
	/*
			2D MaxRects Bin Packer
		
		Copyright (c) 2017 Shen Yiming
		
		Permission is hereby granted, free of charge, to any person obtaining a copy
		of this software and associated documentation files (the "Software"), to deal
		in the Software without restriction, including without limitation the rights
		to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
		copies of the Software, and to permit persons to whom the Software is
		furnished to do so, subject to the following conditions:
		
		The above copyright notice and this permission notice shall be included in all
		copies or substantial portions of the Software.
		
		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
		AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
		LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
		OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
		SOFTWARE.
	*/
	
	alias RectangleData = int; //Todo: a rectangle bele mehetne a binPacker classba es lehetne generic tipusu a data
	
	class Rectangle
	{
		int x, y, width, height; 
		RectangleData data; 
		
		this(int x, int y, int width, int height)
		{
			this.x = x; 
			this.y = y; 
			this.width = width; 
			this.height = height; 
		} 
		
		bool opEquals(const Rectangle r) const
		{ return (this !is null) && (r !is null) && x==r.x && y==r.y && width==r.width && height==r.height; } 
		
		int area() const
		{ return this.width * this.height; } 
		
		auto bounds() const
		{ return ibounds2(x, y, x+width, y+height); } 
		
		bool collide(Rectangle rect)
		{
			//intersection.area > 0
			return !(
				rect.x >= this.x + this.width || rect.x + rect.width <= this.x ||
				rect.y >= this.y + this.height || rect.y + rect.height <= this.y
			); 
		} 
		
		bool contain(Rectangle rect)
		{
			//the whole rect is inside this.
			return (
				rect.x >= this.x && rect.y >= this.y &&
				rect.x + rect.width <= this.x + this.width && rect.y + rect.height <= this.y + this.height
			); 
		} 
		
		override string toString() const
		{ return format!"%5s %s"(data, bounds.text); } 
	} 
	
	private void splice(T)(ref T[] a, size_t i, size_t del = 0, T[] ins = [])
	{ a = a[0..i]~ins~a[i+del..$]; } 
	
	private bool collide(Rectangle first, Rectangle second)
	{ return first.collide(second); } 
	private bool contain(Rectangle first, Rectangle second)
	{ return first.contain(second); } 
	
	class MaxRectsBin
	{
		int width, height; 
		const int maxWidth, maxHeight; 
		Rectangle[] freeRects, rects; 
		
		struct Options { bool smart, pot, square; } 
		const Options options; 
		const int padding; 
		
		private bool verticalExpand; 
		private Rectangle stage; 
		
		this(
			int initialWidth, int initialHeight, int maxWidth, int maxHeight, int padding=0,
			Options options = Options(true, true, false)
		)
		{
			this.maxWidth = maxWidth; 
			this.maxHeight = maxHeight; 
			this.options = options; 
			this.padding = padding; 
			
			this.width	= this.options.smart ? initialWidth	: maxWidth; 
			this.height	= this.options.smart ? initialHeight	: maxHeight; 
			this.freeRects ~= new Rectangle(0, 0, this.maxWidth + this.padding, this.maxHeight + this.padding); 
			this.stage = new Rectangle(0, 0, this.width, this.height); 
		} 
		
		void reinitialize()
		{
			this.rects = []; 
			this.freeRects = [new Rectangle(0, 0, this.maxWidth + this.padding, this.maxHeight + this.padding)]; 
			this.stage = new Rectangle(0, 0, this.width, this.height); 
		} 
		
		Rectangle add(int width, int height, RectangleData data = RectangleData.init)
		{
			auto node = this.findNode(width + this.padding, height + this.padding); 
			if(node)
			{
				this.updateBinSize(node); 
				auto numRectToProcess = this.freeRects.length; 
				auto i = 0; 
				while(i < numRectToProcess)
				{
					if(this.splitNode(this.freeRects[i], node)) {
						this.freeRects.splice(i, 1); 
						numRectToProcess--; 
						i--; 
					}
					i++; 
				}
				this.pruneFreeList(); 
				this.verticalExpand = this.width > this.height ? true : false; 
				auto rect = new Rectangle(node.x, node.y, width, height); 
				rect.data = data; 
				this.rects ~= rect; 
				return rect; 
			}
			else if(!this.verticalExpand)
			{
				if(
					this.updateBinSize(new Rectangle(this.width + this.padding, 0, width + this.padding, height + this.padding)) ||
					this.updateBinSize(new Rectangle(0, this.height + this.padding, width + this.padding, height + this.padding))
				)
				{ return this.add(width, height, data); }
			}
			else
			{
				if(
					this.updateBinSize(
						new Rectangle(
							0, this.height + this.padding,
							width + this.padding, height + this.padding
						)
					) ||
					this.updateBinSize(
						new Rectangle(
							this.width + this.padding, 0,
							width + this.padding, height + this.padding
						)
					)
				)
				{ return this.add(width, height, data); }
			}
			return null; 
		} 
		
		//it bugs    sizediff_t find(in Rectangle     r)const { return rects.countUntil(r); }
		sizediff_t find(in RectangleData d)const
		{ return rects.map!(r=>r.data).countUntil(d); } 
		
		bool remove(sizediff_t idx)
		{
			if(idx>=0) {
				freeRects ~= rects[idx]; 
				rects = rects.remove(idx); 
				return true; 
			}else { return false; }
		} 
		
		//it bogs    bool remove(in Rectangle	r){ return remove(find(r)); }
		bool remove(in RectangleData d)
		{ return	remove(find(d)); } 
		
		private: 
		
		Rectangle findNode(int width, int height)
		{
			auto score = int.max; 
			int areaFit; 
			Rectangle bestNode; 
			
			foreach(r; freeRects)
			{
					//Todo: ref if struct!!!
				if(r.width >= width && r.height >= height)
				{
					areaFit = r.width * r.height - width * height; //Opt: do the mult outside
					if(areaFit < score) {
						//bestNode.x = r.x;
						//bestNode.y = r.y;
						//bestNode.width = width;
						//bestNode.height = height;
						bestNode = new Rectangle(r.x, r.y, width, height); 
						//Opt: dont make a new allocation here.
						//Opt: rectangle shouldnt be a class
						score = areaFit; 
					}
				}
			}
			
			return bestNode; 
		} 
		
		bool splitNode(Rectangle freeRect, Rectangle usedNode)
		{
			//Test if usedNode intersect with freeRect
			if(!freeRect.collide(usedNode)) return false; 
			
			//Do vertical split
			if(usedNode.x < freeRect.x + freeRect.width && usedNode.x + usedNode.width > freeRect.x)
			{
				//New node at the top side of the used node
				if(usedNode.y > freeRect.y && usedNode.y < freeRect.y + freeRect.height)
				{
					auto newNode = new Rectangle(freeRect.x, freeRect.y, freeRect.width, usedNode.y - freeRect.y); 
					this.freeRects ~= newNode; 
				}
				//New node at the bottom side of the used node
				if(usedNode.y + usedNode.height < freeRect.y + freeRect.height)
				{
					auto newNode = new Rectangle(
						freeRect.x,
						usedNode.y + usedNode.height,
						freeRect.width,
						freeRect.y + freeRect.height - (usedNode.y + usedNode.height)
					); 
					this.freeRects ~= newNode; 
				}
			}
			
			//Do Horizontal split
			if(
				usedNode.y < freeRect.y + freeRect.height &&
				usedNode.y + usedNode.height > freeRect.y
			)
			{
				//New node at the left side of the used node.
				if(usedNode.x > freeRect.x && usedNode.x < freeRect.x + freeRect.width)
				{
					auto newNode = new Rectangle(freeRect.x, freeRect.y, usedNode.x - freeRect.x, freeRect.height); 
					this.freeRects ~= newNode; 
				}
				//New node at the right side of the used node.
				if(usedNode.x + usedNode.width < freeRect.x + freeRect.width)
				{
					auto newNode = new Rectangle(
						usedNode.x + usedNode.width,
						freeRect.y,
						freeRect.x + freeRect.width - (usedNode.x + usedNode.width),
						freeRect.height
					); 
					this.freeRects ~= newNode; 
				}
			}
			return true; 
		} 
		
		void pruneFreeList ()
		{
			//Go through each pair of freeRects and remove any rects that is redundant
			int i, j; 
			auto len = this.freeRects.length; 
			while(i < len)
			{
				j = i + 1; 
				auto tmpRect1 = this.freeRects[i]; 
				while(j < len)
				{
					auto tmpRect2 = this.freeRects[j]; 
					if(tmpRect2.contain(tmpRect1)) {
						this.freeRects.splice(i, 1); 
						i--; 
						len--; 
						break; 
					}
					if(tmpRect1.contain(tmpRect2)) {
						this.freeRects.splice(j, 1); 
						j--; 
						len--; 
					}
					j++; 
				}
				i++; 
			}
		} 
		
		bool updateBinSize(Rectangle node)
		{
			if(!this.options.smart) return false; 
			if(this.stage.contain(node)) return false; 
			auto tmpWidth	= max(this.width , node.x + node.width  - this.padding); 
			auto tmpHeight	= max(this.height, node.y + node.height - this.padding); 
			if(this.options.pot) {
				tmpWidth = nearest2NSize(tmpWidth); 
				tmpHeight = nearest2NSize(tmpHeight); 
			}
			if(this.options.square) { tmpWidth = tmpHeight = max(tmpWidth, tmpHeight); }
			if(tmpWidth > this.maxWidth + this.padding || tmpHeight > this.maxHeight + this.padding) { return false; }
			this.expandFreeRects(tmpWidth + this.padding, tmpHeight + this.padding); 
			this.width = this.stage.width = tmpWidth; 
			this.height = this.stage.height = tmpHeight; 
			return true; 
		} 
		
		void expandFreeRects(int width, int height)
		{
			foreach(freeRect; this.freeRects)
			{
				if(freeRect.x + freeRect.width >= min(this.width + this.padding, width)) { freeRect.width = width - freeRect.x; }
				if(freeRect.y + freeRect.height >= min(this.height + this.padding, height)) { freeRect.height = height - freeRect.y; }
			}
			this.freeRects ~= new Rectangle(this.width + this.padding, 0, width - this.width - this.padding, height); 
			this.freeRects ~= new Rectangle(0, this.height + this.padding, width, height - this.height - this.padding); 
			this.freeRects = this.freeRects.filter!(freeRect => !(freeRect.width <= 0 || freeRect.height <= 0)).array; 
			this.pruneFreeList(); 
		} 
		
		public: 
		
		void dump() const
		{
			writefln("BinPacker %s, %s, %s, %s", width, height, maxWidth, maxHeight); 
			writeln("  rects: ", rects.map!text.join("\n")); 
			writeln("  freeRects:", freeRects.map!text.join("\n")); 
		} 
		
		import het.draw2d; 
		static string test(Drawing dr)
		{
				//test /////////////////////////////////
			import het.draw2d; 
			
			auto mrb = new MaxRectsBin(0, 0, 1024, 1024); 
			ivec2[] adds = [ivec2(1,1), ivec2(2,2), ivec2(7,3), ivec2(3,7), ivec2(1,1), ivec2(1,1)]; 
			
			RNG rng; rng.seed = 123; 
			foreach(i; 0..60)
			adds ~= ivec2(rng.random(24)+1,rng.random(8)+1); 
			
			foreach(i; 0..550)
			adds ~= ivec2(rng.random(2)+1,rng.random(2)+1); 
			
			foreach(i, a; adds)
			{
				mrb.add(a.x, a.y); 
				
				if((i&3)==3) { mrb.remove(rng.random(mrb.rects.length)); }
				
				if(dr) {
					dr.translate(cast(int)i * 65, 0); 
					
					foreach(r; mrb.freeRects) {
						dr.color = clGray; 
						dr.drawRect(bounds2(r.bounds).inflated(-0.125)); 
					}
					
					dr.color = clWhite;  dr.drawRect(0, 0, mrb.width, mrb.height); 
					
					foreach(j, r; mrb.rects) {
						dr.color = clVga[(cast(int)j % ($-1))+1]; 
						dr.fillRect(r.bounds); 
					}
					
					dr.pop; 
				}
			}
			
			auto res = mrb.rects.text; 
			
			enforce(res.xxh32==844746689, "MaxRectsBin add/remove test (2D Binpacking)"); 
			
			mrb.destroy; 
			
			return res; 
		} 
		
	} 
	
	struct PositionExtrapolator
	{
		private: 
			struct HistoryRec {
			DateTime t; 
			double position; 
		} 
			HistoryRec[] history; 
		
		public: 
		
			Time historyDuration = 1*second; 
		
			void reset()
		{ history = []; } 
		
			void update()
		{
			const tz = now - historyDuration; 
			history = history.remove!(a => a.t<tz); 
		} 
		
			void appendPosition(double pos, DateTime t = now)
		{ history ~= HistoryRec(t, pos); } 
		
			double position(DateTime t = now) const
		{
			//no data
			if(history.empty) return typeof(return).nan; 
			
			//constant
			if(history.length==1) return history[0].position; 
			
			//interpolate
			if(t.inRange(history[0].t, history[$-1].t))
			{
				foreach(a; history.slide(2))
				if(t.inRange(a[0].t, a[1].t))
				return remap(0, (a[0].t-t).value(second), (a[1].t-t).value(second), a[0].position, a[1].position); 
			}
			
			//extrapolate
			return remap(0, (history[0].t-t).value(second), (history[$-1].t-t).value(second), history[0].position, history[$-1].position); 
		} 
		
			double speed() const
		{
			if(history.length<2) return 0; 
			return safeDiv(history[$-1].position - history[0].position, (history[$-1].t - history[0].t).value(second)); 
		} 
		
			void selfTest()
		{
			PositionExtrapolator pe; 
			[100, 125, 150, 0, 0, 300, 300, 300, 300, 300, 300, 500, 505]
				.chain([0].replicate(20))
				.each!(
				(a){
					sleep(100); 
					if(a) pe.appendPosition(a); 
					pe.update; 
					pe.position.print; 
					
					if(a==505)
					iota(-1.5, 1.5, 0.03333).map!(i => pe.position(now + i*second)).print; 
				}
			); 
		} 
	} 
	float waveLengthStrength(float[] arr, int wl)
	{
		enforce(wl>1); 
		static float[] createTab(alias fun)(int res)
		{
			const invRes = (2*PIf)/res; 
			return iota(res).map!(i => fun(i*invRes)).array; 
			//Opt: cache these tables
		} 
		
		const 	sinTab = createTab!sin(wl),
			cosTab = createTab!cos(wl); 
		
		int j = 0; 
		float sinSum = 0, cosSum = 0; 
		foreach(a; arr)
		{
			sinSum += a * sinTab[j]; 
			cosSum += a * cosTab[j]; 
			j++; if(j==wl) j=0; 
		}
		
		return length(vec2(sinSum, cosSum)); 
	} 
	
	struct WaveLengthDetectionResult
	{
		int waveLength, waveLengthMin, waveLengthMax, waveLengthStep; 
		float[] samples, spectrum; 
		alias waveLength this; 
	} 
	
	auto detectWaveLength(string method)(float[] arr, int wlMin, int wlMax, int wlStep=1)
	{
		auto waveLengthRange = iota(wlMin, wlMax+wlStep, wlStep); 
		enforce(!waveLengthRange.empty); 
		
		static if(method=="sincos")
		{
			float[] scores = waveLengthRange	.map!(wl => waveLengthStrength(arr, wl))
				.array; 
		}
		else static if(method=="pulse")
		{
			float[] scores = [0.0f].replicate(waveLengthRange.length); 
			float lo=arr.front, hi=arr.front; 
			bool lastSt; 
			int counter; 
			foreach(i, act; arr)
			{
				counter++; 
				hi = hi.mix(act, 0.5f); 
				lo = lo.mix(act, 0.02f); 
				const actSt = hi>(lo+10/+noise threshold+/); 
				
				if(lastSt.chkSet(actSt))
				{
					if(actSt) {
						const idx = (counter-wlMin)/wlStep; 
						if(idx.inRange(scores)) scores[idx] += counter; 
						counter = 0; 
					}
				}
			}
			
			scores[] /= waveLengthRange.map!"0.01f".array[]; //scale it up to look nice
		}
		else static assert(0, "Unknown method"); 
		
		scores = scores.gaussianBlur(3); 
		const idx = scores.maxIndex.to!int; 
		
		return WaveLengthDetectionResult(idx<0 ? 0 : idx*wlStep+wlMin, wlMin, wlMax, wlStep, arr, scores); 
	} 
	
	float[][2] getCenterLineSamples(T)(T im, int thickness, int periods=20, ivec2 centerPercent=ivec2(50))
	if(isImage2D!T)
	{
		const t = max(1, thickness/2), scale = 1.0f/(t*2); 
		const p = periods*t; 
		ivec2 c = iround(im.size*centerPercent*0.01f).clamp(ivec2(t), im.size-t); 
		auto extract(A)(A arr)
		{ return arr.map!(a => a.map!(p => p.l).sum*scale).array; } 
		return 	[
			extract(im[max(0, c.x-p) .. min($, c.x+p), c.y-t .. c.y+t].columns),
			extract(im[c.x-t .. c.x+t, max(0, c.y-p) .. min($, c.y+p)].rows)
		]; 
	} 
	
	
	auto detectWaveLength(string method="pulse", T)(
		T img, int wlMin, int wlMax, int wlStep=1, 
		int periods=40, ivec2 centerPercent=ivec2(50)
	)
	if(isImage2D!T)
	{
		auto samples = getCenterLineSamples(img, wlMax, periods, centerPercent); 
		auto res = [
			detectWaveLength!method(samples[0], wlMin, wlMax, wlStep),
			detectWaveLength!method(samples[1], wlMin, wlMax, wlStep)
		]; 
		return res; 
	} 
}
version(/+$DIDE_REGION Geometry+/all)
{
	
	alias seg2 = Segment!vec2; 
	alias dseg2 = Segment!dvec2; 
	
	struct Segment(Vect)
	{
		alias 	V = Vect, 
			E = V.ComponentType; 
		
		V[2] p; 
		
		alias p this; 
		
		this(A, B)(in A a, in B b) { p[0] = V(a); p[1] = V(b); } 
		this(E x0, E y0, E x1, E y1) { this(V(x0, y0), V(x1, y1)); } 
		
		auto diff() const { return p[1] - p[0]; } 
		auto length() const { return .length(diff); } //Todo: implement in math.length
		auto dir() const { return diff*(1/length); } //Todo: implement in math.normalize
	} 
	
	auto toSegs(in vec2[] p, bool circular)
	{
		 //Todo: rewrite with functional.slide
		seg2[] res; 
		res.reserve(p.length); 
		if(p.length<=1) return res; 
		foreach(i; 0..p.length-1+(circular ? 1 : 0)) {
			auto j = i+1; 
			if(j == p.length) j = 0; 
			res ~= seg2(p[i], p[j]); 
		}
		return res; 
	} 
	
	auto toPoints(in bounds2 bnd, bool clockwise=true)
	{
		with(bnd) {
			auto res = [low, vec2(high.x, low.y), high, vec2(low.x, high.y)]; 
			return clockwise 	? res
				: res.retro.array; 
		}
	} 
	
	auto toSegs(in bounds2 bnd, bool clockwise=true)
	{ return bnd.toPoints(clockwise).toSegs(true); } 
	
	
	//Todo: these should be done with CTCG
	//Todo: put these into het.math
	bounds2 inflated(in bounds2 b, in vec2 v)
	{ return b.valid ? bounds2(b.low-v, b.high+v) : bounds2.init; } //Todo: support this for all bounds
	bounds2 inflated(in bounds2 b, in float x, in float y)
	{ return b.inflated(vec2(x, y)); } 
	bounds2 inflated(in bounds2 b, float f)
	{ return b.inflated(f, f); } //Todo: support this for all bounds
	
	bounds2 inflated(in ibounds2 b, in vec2 v)
	{ return b.valid ? bounds2(b.low-v, b.high+v) : bounds2.init; } //Todo: support this for all bounds
	bounds2 inflated(in ibounds2 b, in float x, in float y)
	{ return b.inflated(vec2(x, y)); } 
	bounds2 inflated(in ibounds2 b, float f)
	{ return b.inflated(f, f); } //Todo: support this for all bounds
	
	ibounds2 inflated(in ibounds2 b, in ivec2 v)
	{ return b.valid ? ibounds2(b.low-v, b.high+v) : ibounds2.init; } //Todo: support this for all bounds
	ibounds2 inflated(in ibounds2 b, int x, int y)
	{ return b.inflated(ivec2(x, y)); } //Todo: support this for all bounds
	ibounds2 inflated(in ibounds2 b, int a)
	{ return b.inflated(a, a); } //Todo: support this for all bounds
	
	auto fittingSquare(in bounds2 b)
	{
		auto diff = (b.size.x-b.size.y)*0.5f; 
		if(diff<0) return b.inflated(0    , diff); 
		else return b.inflated(-diff,    0); 
	} 
	
	//float - int combinations ///////////////////////////////////////
	
	////////////////////////////////////////////////////////////////////////////////////////////
	///  Graphics algorithms                                                                 ///
	////////////////////////////////////////////////////////////////////////////////////////////
	
	///  Intersections, primitive distances  ///////////////////////////////////////////////////
	
	vec2 intersectLines_noParallel_prec(S: Segment!E, E)(in S S0, in S S1)
	//Todo: all of these variation should be refactored with static ifs.
	{
		auto 	S	= S1.p[0]-S0.p[0],
			T	= S0.p[1]-S0.p[0],
			U	= S1.p[0]-S1.p[1],
			det	= crossZ(T, U),
			detA	= crossZ(S, U),
			alpha 	= detA/det; //Opt: alpha = detA*rcpf_fast(det);
		
		return S0.p[0] + T*alpha; 
	} 
	
	bool intersectSegs_noParallel_prec(S: Segment!E, E)(in S S0, in S S1, ref E P)
	{
		auto 	S = S1.p[0]-S0.p[0],
			T = S0.p[1]-S0.p[0],
			U = S1.p[0]-S1.p[1]; 
		auto 	det	= crossZ(T, U),
			detA 	= crossZ(S, U); 
		
		if(inRange_sorted(detA, 0, det))
		{
			//have one intersection
			auto detB = crossZ(T, S); 
			if(inRange_sorted(detB, 0, det))
			{
				auto alpha = detA/det; 
				//alpha = detA*rcpf_fast(det); //rather not
				P = S0.p[0]+T*alpha; 
				
				return true; 
			}
		}
		return false; 
	} 
	
	bool intersectSegs_noParallel_prec(S: Segment!E, E)(in S S0, in S S1)
	{
		auto 	S = S1.p[0]-S0.p[0],
			T = S0.p[1]-S0.p[0],
			U = S1.p[0]-S1.p[1]; 
		auto 	det	= crossZ(T, U),
			detA	= crossZ(S, U); 
		
		if(inRange_sorted(detA, 0, det))
		{
			//have one intersection
			auto detB = crossZ(T, S); 
			if(inRange_sorted(detB, 0, det)) {
				auto alpha = detA/det; 
				return true; 
			}
		}
		return false; 
	} 
	
	bool intersectSegs_falseParallel_prec(S: Segment!E, E)(in S S0, in S S1)
	{
		auto 	S	= S1.p[0] - S0.p[0],
			T	= S0.p[1] - S0.p[0],
			U 	= S1.p[0] - S1.p[1]; 
		auto det = crossZ(T, U); 
		
		if(abs(det)<1e-30) return false;  //Todo: this is lame
		
		auto detA = crossZ(S, U); 
		
		if(inRange_sorted(detA, 0, det))
		{
			//have one intersection
			auto detB = crossZ(T, S); 
			if(inRange_sorted(detB, 0, det)) {
				auto alpha = detA/det; 
				return true; 
			}
		}
		return false; 
	} 
	
	auto polyLineLength(R)(R arr)
	{ return arr.slide!(No.withPartial)(2).map!(a => (magnitude(a[1]-a[0]))).sum; } 
	
	float segmentPointDistance_prec(const vec2 v, const vec2 w, const vec2 p)
	{
		//Return minimum distance between line segment vw and point p
		const l2 = sqrLength(v-w);    //i.e. |w-v|^2 -  avoid a sqrt
		if(!l2) return distance(p, v); //v == w case
		//Consider the line extending the segment, parameterized as v + t (w - v).
		//We find projection of point p onto the line.
		//It falls where t = [(p-v) . (w-v)] / |w-v|^2
		//We clamp t from [0,1] to handle	points outside the segment vw.
		const t = max(0, min(1, dot(p - v,	w - v) / l2)); 
		const projection = v + (w - v)*t; 	//Projection falls on the segment
		return distance(p, projection); 
	} 
	
	//Todo: segmentPointDistance 3d
	/*
		vec3 segmentNearestPoint(vec3 S0, vec3 S1, vec3 P){
			vec3 v = S1 - S0;
			vec3 w = P - S0;
		
			float c1 = dot(w,v);
			if(c1<=0.0) return S0;
		
			float c2 = dot(v,v);
			if(c2<=c1) return S1;
		
			float b = c1 / c2;
			vec3 Pb = S0 + b * v;
			return Pb;
		}
		
		
		float segmentPointDistance(vec3 S0, vec3 S1, vec3 P){
			return distance(P, segmentNearestPoint(S0, S1, P));
		}
	*/
	
	
	/// 2D point position restriction inside bounds
	vec2 restrictPos_normal(T1, T2)(in Vector!(T1, 2) p, in Bounds!(Vector!(T2, 2)) bnd)
	{ return p.clamp(bnd.low, bnd.high); } 
	
	vec2 restrictPos_editor(T1, T2)(in Vector!(T1, 2) p, in Bounds!(Vector!(T2, 2)) bnd)
	{
		return 	p.y<bnd.top ? bnd.topLeft :
			p.y>bnd.bottom ? bnd.bottomRight :
			vec2(p.x.clamp(bnd.left, bnd.right), p.y); 
	} 
	
	///  Bresenham line drawing /////////////////////////////////////////////////////////////////////
	
	void line_bresenham(in ivec2 a, in ivec2 b, bool skipFirst, void delegate(in ivec2) dot)
	{
		auto 	d	= b-a,
			d1 	= abs(d),
			p	= ivec2(
			2*d1.y-d1.x,
			2*d1.x-d1.y
		),
			i	= (d.x<0)==(d.y<0) ? 1 : -1; 
		d1 *= 2; 
		
		void dot2(in ivec2 p) { if(!skipFirst || p!=a) dot(p); } 
		
		int e; ivec2 v; 
		if(d1.y<=d1.x)	{
			if(d.x>=0) { v=a; e=b.x; }
			else { v=b; e=a.x; }
			dot2(v); 
			while(v.x<e) {
				++v.x; 
				if(p.x<0) { p.x += d1.y; 		}
				else { p.x += d1.y-d1.x; 	v.y += i; 	}
				dot2(v); 
			}
		}
		else	{
			if(d.y>=0) { v=a; e=b.y; }
			else { v=b; e=a.y; }
			dot2(v); 
			while(v.y<e) {
				++v.y; 
				if(p.y<0) { p.y += d1.x; 		}
				else { p.y += d1.x-d1.y; 	v.x += i; 	}
				dot2(v); 
			}
		}
	} 
	
	///	 Cohen Sutherland line-rect Clipping ///////////////////////////////////////////////////////////////
	///	 Ported to Delphi from wikipedia C code by Omar Reis - 2012	                         ///
	///	 Ported back to C by realhet 2013, lol	                         ///
	///	 Ported finally to D by realhet 2016, lol**2	                         ///
	
	bool _lineClip(V, E, F)(in V bMin, in V bMax, ref V a, ref V b)
	{
		const 	INSIDE	= 0, //0000
			LEFT	= 1, //0001
			RIGHT	= 2, //0010
			BOTTOM	= 4, //0100
			TOP	= 8 //1000
		; 
		
		int computeOutCode(const V v) const
		{
			int res = INSIDE; //initialised as being inside of clip window
			
			if(v.x < bMin.x) res |= LEFT; 
			else if(
				v.x > bMax.x//to the left of clip window
			)
			res |= RIGHT; 
			//to the right of clip window
			
			if(v.y < bMin.y) res |= BOTTOM; 
			else if(
				v.y > bMax.y//below the clip window
			)
			res |= TOP; 
			//above the clip window
			
			return res; 
		} 
		
		//compute outcodes for P0, P1, and whatever point lies outside the clip rectangle
		int outcode0 = computeOutCode(a); 
		int outcode1 = computeOutCode(b); 
		while(1)
		{
			if((outcode0 | outcode1)==0) {
				 //Bitwise OR is 0. Trivially result and get out of loop
				return true; 
			}
			else if(outcode0 & outcode1) {
				 //Bitwise AND is not 0. Trivially reject and get out of loop
				return false; 
			}
			else {
				//failed both tests, so calculate the line segment to clip
				//from an outside point to an intersection with clip edge
				//At least one endpoint is outside the clip rectangle; pick it.
				int outcodeOut = outcode0 ? outcode0 : outcode1; 
				//Now find the intersection point;
				//use formulas y = a.y + slope * (x - a.x), x = a.x + (1 / slope) * (y - a.y)
				F x,y; 
				if(outcodeOut & TOP)	{
					//point is above the clip rectangle
					x = a.x + (b.x - a.x) * (bMax.y - a.y) / (b.y - a.y); 
					y = bMax.y; 
				}
				else if(outcodeOut & BOTTOM)	{
					//point is below the clip rectangle
					x	= a.x + (b.x - a.x) * (bMin.y - a.y) / (b.y - a.y); 
					y	= bMin.y; 
				}
				else if(outcodeOut & RIGHT)	{
					//point is to the right of clip rectangle
					y	= a.y + (b.y - a.y) * (bMax.x - a.x) / (b.x - a.x); 
					x	= bMax.x; 
				}
				else	{
					//point is to the left of clip rectangle
					y = a.y + (b.y - a.y) * (bMin.x - a.x) / (b.x - a.x); 
					x = bMin.x; 
				}
				
				/*
					Note: if you follow this algorithm exactly(at least for c#),
					then you will fall into an infinite loop
					in case a line crosses more than two segments. 
					To avoid that problem, leave out the last else
					if(outcodeOut & LEFT) and just make it else 
				*/
				
				//Now we move outside point to intersection point to clip
				//and get ready for next pass.
				if(outcodeOut==outcode0) {
					a.x = cast(E)x; 
					a.y = cast(E)y; 
					outcode0 = computeOutCode(a); 
				}
				else {
					b.x = cast(E)x; 
					b.y = cast(E)y; 
					outcode1 = computeOutCode(b); 
				}
			}
		}
	} 
	//lineClip()
	
	
	
	/// Nearest finders ///////////////////////////////////////////////////////////////
	
	int distManh(in ibounds2 b, in ivec2 p)
	{ with(b) return max(max(left-p.x, p.x-right, 0), max(top-p.y, p.y-bottom, 0)); } 
	
	auto findNearestManh(in ibounds2[] b, in ivec2 p)
	{
		auto idx = b.map!(r => r.distManh(p)).array.minIndex; 
		if(idx<0) return ibounds2(); 
		else return b[idx]; 
	} 
	
	auto findNearestManh(ibounds2[] b, in ivec2 p, int maxDist, int* actDist=null)
	{
		auto idx = b.map!(r => r.distManh(p)).array.minIndex; 
		if(idx<0) {
			if(actDist) *actDist = int.max; 
			return ibounds2(); 
		}else {
			int d = b[idx].distManh(p); 
			if(actDist) *actDist = d; 
			if(d>maxDist) return ibounds2(); 
			else return b[idx]; 
		}
	} 
	
	//Linear fit ///////////////////////////////////////////////////////////////////////
	
	struct LinearFitResult
	{
		vec2[] points; 
		float slope=0; 
		float intercept=0; 
		
		float deviation = 0; 
		int worstIdx = -1; 
		bool isGood; //optimizer fills it
		
		bool isNull() const
		{ return !slope && !intercept; } 
		
		float y(float x)
		{ return intercept+x*slope; } 
	} 
	
	auto linearFit(in vec2[] data)
	{
		auto xSum	= data.map!"a.x".sum,
				 ySum	= data.map!"a.y".sum,
				 xxSum	= data.map!"a.x*a.x".sum,
				 xySum	= data.map!"a.x*a.y".sum,
				 len =	data.length.to!float; 
		
		LinearFitResult res; 
		
		if(data.length>=2) {
			res.points = data.dup; 
			res.slope = (len*xySum - xSum*ySum) / (len * xxSum - xSum * xSum); 
			res.intercept = (ySum - res.slope * xSum) / len; 
		}
		else { if(data.length==1) { res.intercept = data[0].y; }else { return res; }}
		
		auto error(in vec2 p) { return res.y(p.x)-p.y; } 
		res.deviation = sqrt(data.map!(p => error(p)^^2).sum/(data.length.to!int-1)); 
		res.worstIdx = data.map!(p => abs(error(p))).maxIndex.to!int; 
		
		return res; 
	} 
	
	auto linearFit(in vec2[] data, int requiredPoints, float maxDeviation)
	{
		auto fit = linearFit(data); 
		
		while(1) {
			fit.isGood = fit.points.length>=requiredPoints && fit.deviation<maxDeviation; 
			if(fit.isGood) break; 
			if(fit.points.length<=requiredPoints) break; 
			fit = linearFit(fit.points.remove(fit.worstIdx)); 
		}
		
		return fit; 
	} 
	
	//Quadratic fit ///////////////////////////////////////////////////////////////////////
	
	struct QuadraticFitResult
	{
		//Todo: combine Quadratic and linear fitter
		vec2[] points; 
		float a=0, b=0, c=0; 
		
		float deviation = 0; 
		int worstIdx = -1; 
		bool isGood; //optimizer fills it
		
		bool isNull() const { return !a && !b && !c; } 
		
		float y(float x) const { return a*x^^2 + b*x + c; } 
		
		vec2 location() const
		{
			float ly = 0; 
			const lx = peakLocation(a, b, c, &ly); 
			return vec2(lx, ly); 
		} 
		
		float location_x() const
		{ return peakLocation(a, b, c); } 
	} 
	
	private float det(float a, float b, float c, float d)
	{ return a*d-c*b; } //Todo: combine this with math.det
	private float det(float a, float b, float c, float d, float e, float f, float g, float h, float i)
	{
		return 	+a*det(e, f, h, i)
			-d*det(b, c, h, i)
			+g*det(b, c, e, f); 
	} 
	
	auto quadraticFit(in vec2[] data)
	{
		NOTIMPL; //Todo: this is possibly buggy. must refactor.
		
		QuadraticFitResult res; 
		if(data.length<3) {
			if(data.length==2) {
				auto lin = linearFit(data); //get it from linear
				res.b = lin.slope; 
				res.c = lin.intercept; 
				res.deviation = lin.deviation; 
				res.worstIdx = lin.worstIdx; 
			}
			return res; 
		}
		
		//https://www.codeproject.com/Articles/63170/Least-Squares-Regression-for-Quadratic-Curve-Fitti
		//notation sjk to mean the sum of x_i^j*y_i^k.
		//Todo: optimize this with .tee or	something to access x and y only once
		float 	s40 = data.map!"a.x^^4".sum,	//sum of x^4
			s30 = data.map!"a.x^^3".sum,	//sum of x^3
			s20 = data.map!"a.x^^2".sum,	//sum of x^2
			s10 = data.map!"a.x".sum,	//sum of x
			s00 = data.length,	//sum of x^0 * y^0	ie 1 * number of entries
			s21 = data.map!"a.x^^2*a.y".sum,	//sum of x^2*y
			s11 = data.map!"a.x*a.y".sum,	//sum of x*y
			s01 = data.map!"a.y".sum	//sum of y
		; 
		
		auto D = det(
			s40, s30, s20,
			s30, s20, s10,
			s20, s10, s00
		); 
		res.a = det(
			s21, s30, s20,
			s11, s20, s10,
			s01, s10, s00
		)/D; 
		res.b = det(
			s40, s21, s20,
			s30, s11, s10,
			s20, s01, s00
		)/D; 
		res.c = det(
			s40, s30, s21,
			s30, s20, s11,
			s20, s10, s01
		)/D; 
		
		res.points = data.dup; 
		
		//copied from lin
		auto error(in vec2 p) { return res.y(p.x)-p.y; } 
		res.deviation = sqrt(data.map!(p => error(p)^^2).sum/(data.length.to!int-1)); 
		res.worstIdx = data.map!(p => abs(error(p))).maxIndex.to!int; 
		
		return res; 
	} 
	auto mirrorPointOverLine(V, T2, T3)(V P, T2 A, T3 B)
	{
		const 	d = B - A,
			mx = ((V(d.x*d.x - d.y*d.y, d.x*d.y*2))/(d.x*d.x + d.y*d.y)),
			my = mx.rotate270,
			a = P - A; 
		return mx*a.x + my*a.y + A; 
	} 
	
	auto extrapolateCurve(V)(V A, V B, V C)
	{
		//Continuity: C1
		static if(1)
		{
			//this is simpler, only uses 1 div and no trigonometryc functions
			//Opt: Measure how fast and precise it is.
			const M1 = (B+C)/2, M2 = M1 + (B-C).rotate90; 
			return mirrorPointOverLine(A, M1, M2); 
		}
		else
		{
			const 	v1 = (B-A).normalize,
				v2 = (C-B).normalize,
				a = asin(cross(v1, v2).z); 
			return C + (C-B).rotate(a); 
		}
	} 
	
	auto extrapolateCurve(V)(V A, V B, V C, V D)
	{
		//Continuity: C2
		const 	v1 = (B-A).normalize,
			v2 = (C-B).normalize,
			v3 = (D-C).normalize,
			a1 = asin(cross(v1, v2).z),
			a2 = asin(cross(v2, v3).z),
			a3 = a2 + (a2-a1); 
		return D + (D-C).rotate(a3); 
	} 
	
	T[2] linearBezierWeights(T)(T t)
	{
		const u = 1-t; 
		return [u, t]; 
	} 
	
	T[3] quadraticBezierWeights(T)(T t)
	{
		const u = 1-t; 
		return [((u)^^(2)), 2*u*t, ((t)^^(2))]; 
	} 
	
	T[4] cubicBezierWeights(T)(T t)
	{
		const u = 1-t; 
		return [((u)^^(3)), 3*t*((u)^^(2)), 3*u*((t)^^(2)), ((t)^^(3))]; 
	} 
	
	auto evalBezier(F, int N)(in Vector!(F, 2)[N] p, F t)
	{
		const w = cubicBezierWeights(t); 
		auto res = p[0]*w[0]; 
		static foreach(i; 1..p.length) res += p[i]*w[i]; 
		return res; 
	} 
	
	auto generateBezierPolyline(F, int N)(in Vector!(F, 2)[N] p, F stepSize=1)
	{
		
		auto eval(F t)
		{ return evalBezier(p, t); } 
		
		const 	roughCount	= iround(5*p[].polyLineLength/stepSize).max(1),
			invRoughCount 	= F(1)/roughCount,
			points	= iota(roughCount+F(1)).map!(i => eval(i*invRoughCount)).array,
			lengths	= points.slide!(No.withPartial)(2).map!(a => distance(a[0], a[1])).array,
			totalLen	= lengths.sum,
			segmentCount	= iround(totalLen/stepSize).max(1),
			segmentLen	= totalLen/segmentCount; 
			
		F writtenLen = 0, prevLen = 0; F[] t; 
		loop:  //resample the t values using linear interpolation
		foreach(i, actLen; lengths)
		{
			while(writtenLen.inRange(prevLen, prevLen+actLen))
			{
				t ~= (i + writtenLen.remap(prevLen, prevLen+actLen, 0, 1))*invRoughCount; 
				writtenLen += segmentLen; 
				if(t.length==segmentCount) break loop; 
			}
			prevLen += actLen; 
		}
		t ~= 1;  //the last point must be exactly 1.0
		
		return t.map!(a => eval(a)).array; 
	} 
	
	
	
	alias FTurtle = Turtle_!float, 
	DTurtle = Turtle_!double, 
	Turtle = DTurtle; 
	
	struct Turtle_(T)
	{
		alias V=Vector!(T, 2); 
		
		T stepSize=1; 
		void delegate(V) sink; 
		
		//state variables
		V pos, dir=V(1, 0); 
		
		void reset()
		{ pos = 0; dir = V(1, 0); } 
		
		@property state() { return tuple(pos, dir); } 
		@property state(Tuple!(V, V) a) { pos = a[0]; dir = a[1]; } 
		
		Tuple!(V, V)[] stack; 
		void push()
		{ stack ~= state; } 
		void pop()
		{
			enforce(stack.length); 
			state = stack.back; stack.popBack; 
		} 
		
		struct Path
		{
			V[] points; 
			V dir_start, dir_end; 
			alias points this; 
		} 
		
		auto capture(void delegate() fun)
		{
			Path path; 
			with(path)
			{
				dir_start = dir; 
				
				auto originalSink = sink; 
				sink = (V p){ if(points.empty || points.back!=p) points ~= p; }; 
				push; 
				
				scope(exit)
				{
					sink = originalSink; 
					dir_end = dir; 
					pop; 
				} 
			}
			
			fun(); 
			
			return path; 
		} 
		
		void emit(in Path path)
		{
			if(path.empty) return; 
			path.each!((a){ sink(a); }); 
			pos = path.back; 
			dir = path.dir_end; 
		} 
		
		void line(
			in T length //negative goes backwards
		)
		{
			if(!length) return; 
			const 	segmentCount 	= ((abs(length))/(stepSize)).iround.max(1),
				endPos 	= pos + dir*length,
				step 	= (endPos-pos) * (T(1)/segmentCount); 
			sink(pos); 
			foreach(i; 0..segmentCount-1)
			{ pos += step; sink(pos); }
			pos = endPos; sink(pos); 
		} 
		
		void arc_angle(
			T θ, //negative: goes backwards on the same side
			T r, //-left, +right
			float adjust = 0 //clothoidal bending
		)
		{
			if(!θ) return; 
			if(θ<0) {
				//negative angle: backwards, same side (mirror)
				θ *= -1; dir *= -1; r *= -1; 
			}
			θ = θ.radians * r.sign; //turning direction is defined by radius
			
			const 	length	= abs(θ*r),
				segmentCount	= ((length)/(stepSize)).iround.max(1),
				segmentLength 	= ((length)/(segmentCount)),
				center	= pos + dir.rotate90 * r,
				endPos	= (pos-center).rotate(θ) + center,
				endDir	= (normalize(dir.rotate(θ))),
				Δθ 	= ((θ)/(segmentCount)); 
			if(adjust==0)
			{
				dir = (normalize(dir.rotate(Δθ / 2))) * segmentLength; 
				sink(pos); 
				foreach(i; 0..segmentCount-1)
				{
					pos += dir; sink(pos); 
					dir = dir.rotate(Δθ); 
				}
				pos = endPos; dir = endDir; 
				sink(pos); 
			}
			else
			{ bezier4(endPos, endDir, adjust); }
		} 
		
		void arc_length(
			T length, //negative: goes backwards on the same side
			T r, //-left, +right
			float adjust = 0 //clothoidal bending
		)
		{
			if(!length) return; 
			const θ = ((length)/((magnitude(r)))).degrees; 
			arc_angle(θ, r, adjust); 
		} 
		
		void bezier4(V pos_end, V dir_end, float adjust=0)
		{
			/+
				Draw a cubic bezier curve from current pos/dir to a given pos/dir.
				The middle points can be adjusted to move close to each other, so it is 
				possible to emulate a clothoid using cubic bezier interpolation.
			+/
			V[4] cp; //The 4 control points
			{
				const len = (magnitude(pos_end - pos)) * 0.33333f * (1 + adjust); 
				
				cp[0] = pos; 
				cp[1]	= pos	+ (normalize(dir    ))*len,
				cp[2]	= pos_end	- (normalize(dir_end))*len; 
				cp[3] = pos_end; 
			}
			
			generateBezierPolyline(cp, stepSize).each!((p){ sink(p); }); 
			
			pos = pos_end; 
			dir = (normalize(dir_end)); 
		} 
		
		
		void clothoid_accel(
			T ΔΔθ, //angle step increase between steps.
			T r_start, T r_end //negative = turn left
		)
		{
			if(!ΔΔθ) return; 
			if(ΔΔθ<0)
			{
				//negative angle: backwards, same side (mirror)
				ΔΔθ *= -1; dir *= -1; 
			}
			
			const 	segmentLength 	= stepSize,
				Δθ_start 	= segmentLength / r_start,
				Δθ_end 	= segmentLength / r_end; 
			
			//calculate actual angle acceleration
			ΔΔθ = (magnitude(ΔΔθ.radians)) * sign(Δθ_end - Δθ_start); 
			if(!ΔΔθ) return; 
			
			
			sink(pos); 
			T Δθ = Δθ_start + ΔΔθ; //the first point has acceleration too
			dir = (normalize(dir.rotate(Δθ/2))) * segmentLength; //sets dir.length
			while(
				(ΔΔθ>0 && Δθ<Δθ_end) || 
				(ΔΔθ<0 && Δθ>Δθ_end)
			)
			{
				pos += dir; sink(pos); 
				dir = dir.rotate(Δθ); 
				Δθ += ΔΔθ; 
			}
			
			/+
				Note: The final pos/dir is distorted by the iterative calculations, 
				but it's much simpler than FresnelC
			+/
			pos += dir; sink(pos); 
			dir = (normalize(dir.rotate(Δθ/2))); //restore dir.length
		} 
		
	} 
}