module het.vulkan; 

version(/+$DIDE_REGION+/all)
{
	//THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY.
	
	private {
		/+
			Note: To exclude het.win and other GUI modules compile with:
			/+Code: //@compile --d-version=VulkanHeadless+/ 
		+/
		version(VulkanHeadless)	private enum VulkanWindowed = false; 
		else	private enum VulkanWindowed = true; 
	} 
	
	/+
		Note: Original source and generator:
			/+Link: https://github.com/ColonelThirtyTwo/dvulkan+/
			name	: d-vulkan
			description	: Auto-generated D bindings for Vulkan
			copyright	: Copyright 2015-2016 The Khronos Group Inc.; Copyright 2016, Alex Parrill
			authors	: Alex Parrill"
			license	: BSD 2-clause
		
		It's been edited a lot. -> Search for "het"
		Now (2024) it's an archived repository.  But not a problem since I will import every new extensions manually, while learning.
	+/
	
	/+
		Note: More info on synching and memory types:
		/+Link: https://themaister.net/blog/2019/08/14/yet-another-blog-explaining-vulkan-synchronization+/
		/+Link: https://asawicki.info/news_1740_vulkan_memory_types_on_pc_and_how_to_use_them+/
	+/
	
	//Extensions used by hetlib.
	version = DVulkan_VK_VERSION_1_0; 
	
	version = DVulkan_VK_KHR_surface; 
	version = DVulkan_VK_KHR_win32_surface; 
	version = DVulkan_VK_KHR_swapchain; 
	
	mixin SmartClassGenerator; 
	
	version(DVulkanAllExtensions)
	{
		version = DVulkan_VK_VERSION_1_0; 
		version = DVulkan_VK_KHR_surface; 
		version = DVulkan_VK_KHR_win32_surface; //het
		version = DVulkan_VK_KHR_swapchain; 
		version = DVulkan_VK_KHR_display; 
		version = DVulkan_VK_KHR_display_swapchain; 
		version = DVulkan_VK_KHR_sampler_mirror_clamp_to_edge; 
		version = DVulkan_VK_ANDROID_native_buffer; 
		version = DVulkan_VK_EXT_debug_report; 
		version = DVulkan_VK_NV_glsl_shader; 
		version = DVulkan_VK_NV_extension_1; 
		version = DVulkan_VK_IMG_filter_cubic; 
		version = DVulkan_VK_AMD_extension_1; 
		version = DVulkan_VK_AMD_extension_2; 
		version = DVulkan_VK_AMD_rasterization_order; 
		version = DVulkan_VK_AMD_extension_4; 
		version = DVulkan_VK_AMD_extension_5; 
		version = DVulkan_VK_AMD_extension_6; 
		version = DVulkan_VK_EXT_debug_marker; 
	}struct VkBitFlags(E, Flag!"unsafe" unsafe=No.unsafe)
	{
		BitFlags!(E, unsafe) _bitflags; 
		alias _bitflags this; 
		
		this(A)(A a) { _bitflags = a; } 
		
		string toString() const
		{
			import std.conv, std.format, std.array; 
			string[] res; ulong remaining; 
			auto a = cast(ulong) this; 
			for(ulong i=1; a; i<<=1, a>>=1)
			if(a&1)
			{
				const s = (cast(E)i).text; 
				if(s.startsWith("cast("))
				remaining |= i; 
				else
				res ~= s; 
			}
			
			if(remaining) res ~= remaining.format!"0x%x"; 
			if(res.empty) res = ["0"]; 
			return format!"%s(%s)"(E.stringof, res.join(" | ")); 
		} 
	} 
	
	
	//THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY.
	alias uint8_t = ubyte; 	alias uint16_t = ushort; 	alias uint32_t = uint; 	alias uint64_t = ulong; 
	alias int8_t = byte; 	alias int16_t = short; 	alias int32_t = int; 	alias int64_t = long; 
	
	@nogc pure nothrow
	{
		uint VK_MAKE_VERSION(uint major, uint minor, uint patch)
		{ return (major << 22) | (minor << 12) | (patch); } 
		uint VK_VERSION_MAJOR(uint ver)
		{ return ver >> 22; } 
		uint VK_VERSION_MINOR(uint ver)
		{ return (ver >> 12) & 0x3ff; } 
		uint VK_VERSION_PATCH(uint ver)
		{ return ver & 0xfff; } 
	} 
	
	/+
		+ On 32-bit systems, VK_NULL_HANDLE must be compatible with both opaque struct pointers
		+ (for dispatchable object) and integers (for nondispatchable objects). This is not possible
		+ with D's type system, which doesn't implicitly convert 0 to the null pointer as in C
		+ (for better or for worse). Either use the `VK_NULL_[NON_]DISPATCHABLE_HANDLE` constants or
		+ `Vk(Type).init`.
		+
		+ See also https://github.com/ColonelThirtyTwo/dvulkan/issues/13
	+/
	
	//VK_NULL_HANDLE is impossible to implement portably in D. Use Vk(Type).init or VK_NULL_[NON_]DISPATCHABLE_HANDLE
	enum VK_NULL_HANDLE = null; 
	
	enum VK_DEFINE_HANDLE(string name) = "struct "~name~"_handle; alias "~name~" = "~name~"_handle*;"; 
	
	enum VK_NULL_DISPATCHABLE_HANDLE = null; 
	version(X86_64)
	{
		alias VK_DEFINE_NON_DISPATCHABLE_HANDLE(string name) = VK_DEFINE_HANDLE!name; 
		enum VK_NULL_NON_DISPATCHABLE_HANDLE = null; 
	}else
	{
		enum VK_DEFINE_NON_DISPATCHABLE_HANDLE(string name) = "alias "~name~" = ulong;"; 
		enum VK_NULL_NON_DISPATCHABLE_HANDLE = 0; 
	}
	version(DVulkan_VK_VERSION_1_0)
	{
		enum VkPipelineCacheHeaderVersion
		{ VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1, } 
		enum VK_LOD_CLAMP_NONE = 1000.0f; 
		enum VK_REMAINING_MIP_LEVELS = (~0U); 
		enum VK_REMAINING_ARRAY_LAYERS = (~0U); 
		enum VK_WHOLE_SIZE = (~0UL); 
		enum VK_ATTACHMENT_UNUSED = (~0U); 
		enum VK_TRUE = 1; 
		enum VK_FALSE = 0; 
		enum VK_QUEUE_FAMILY_IGNORED = (~0U); 
		enum VK_SUBPASS_EXTERNAL = (~0U); 
		
		enum VkResult
		{
			VK_SUCCESS = 0,
			VK_NOT_READY = 1,
			VK_TIMEOUT = 2,
			VK_EVENT_SET = 3,
			VK_EVENT_RESET = 4,
			VK_INCOMPLETE = 5,
			VK_ERROR_OUT_OF_HOST_MEMORY = -1,
			VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
			VK_ERROR_INITIALIZATION_FAILED = -3,
			VK_ERROR_DEVICE_LOST = -4,
			VK_ERROR_MEMORY_MAP_FAILED = -5,
			VK_ERROR_LAYER_NOT_PRESENT = -6,
			VK_ERROR_EXTENSION_NOT_PRESENT = -7,
			VK_ERROR_FEATURE_NOT_PRESENT = -8,
			VK_ERROR_INCOMPATIBLE_DRIVER = -9,
			VK_ERROR_TOO_MANY_OBJECTS = -10,
			VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
			VK_ERROR_SURFACE_LOST_KHR = -1000000000,
			VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
			VK_SUBOPTIMAL_KHR = 1000001003,
			VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
			VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
			VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
			VK_ERROR_INVALID_SHADER_NV = -1000012000,
			VK_NV_EXTENSION_1_ERROR = -1000013000,
		} 
		
		static foreach(r; EnumMembers!VkResult) mixin(format!"enum %s = VkResult.%s;"(r, r)); 
		
		alias VkStructureType = VK_STRUCTURE_TYPE_; 
		enum VK_STRUCTURE_TYPE_
		{
			APPLICATION_INFO = 0,
			INSTANCE_CREATE_INFO = 1,
			DEVICE_QUEUE_CREATE_INFO = 2,
			DEVICE_CREATE_INFO = 3,
			SUBMIT_INFO = 4,
			MEMORY_ALLOCATE_INFO = 5,
			MAPPED_MEMORY_RANGE = 6,
			BIND_SPARSE_INFO = 7,
			FENCE_CREATE_INFO = 8,
			SEMAPHORE_CREATE_INFO = 9,
			EVENT_CREATE_INFO = 10,
			QUERY_POOL_CREATE_INFO = 11,
			BUFFER_CREATE_INFO = 12,
			BUFFER_VIEW_CREATE_INFO = 13,
			IMAGE_CREATE_INFO = 14,
			IMAGE_VIEW_CREATE_INFO = 15,
			SHADER_MODULE_CREATE_INFO = 16,
			PIPELINE_CACHE_CREATE_INFO = 17,
			PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
			PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
			PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
			PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
			PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
			PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
			PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
			PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
			PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
			PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
			GRAPHICS_PIPELINE_CREATE_INFO = 28,
			COMPUTE_PIPELINE_CREATE_INFO = 29,
			PIPELINE_LAYOUT_CREATE_INFO = 30,
			SAMPLER_CREATE_INFO = 31,
			DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
			DESCRIPTOR_POOL_CREATE_INFO = 33,
			DESCRIPTOR_SET_ALLOCATE_INFO = 34,
			WRITE_DESCRIPTOR_SET = 35,
			COPY_DESCRIPTOR_SET = 36,
			FRAMEBUFFER_CREATE_INFO = 37,
			RENDER_PASS_CREATE_INFO = 38,
			COMMAND_POOL_CREATE_INFO = 39,
			COMMAND_BUFFER_ALLOCATE_INFO = 40,
			COMMAND_BUFFER_INHERITANCE_INFO = 41,
			COMMAND_BUFFER_BEGIN_INFO = 42,
			RENDER_PASS_BEGIN_INFO = 43,
			BUFFER_MEMORY_BARRIER = 44,
			IMAGE_MEMORY_BARRIER = 45,
			MEMORY_BARRIER = 46,
			LOADER_INSTANCE_CREATE_INFO = 47,
			LOADER_DEVICE_CREATE_INFO = 48,
			SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
			PRESENT_INFO_KHR = 1000001001,
			DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
			DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
			DISPLAY_PRESENT_INFO_KHR = 1000003000,
			XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
			XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
			WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
			MIR_SURFACE_CREATE_INFO_KHR = 1000007000,
			ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
			WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
			DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
			PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
			DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
			DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
			DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
		} 
		
		alias VkFlags = uint32_t; 
		alias VkInstanceCreateFlags = VkFlags; 
		struct VkApplicationInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.APPLICATION_INFO; 
			const(void)* pNext; 
			const(char)* pApplicationName; 
			uint32_t applicationVersion; 
			const(char)* pEngineName; 
			uint32_t engineVersion; 
			uint32_t apiVersion; 
		} 
		struct VkInstanceCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.INSTANCE_CREATE_INFO; 
			const(void)* pNext; 
			VkInstanceCreateFlags flags; 
			const(VkApplicationInfo)* pApplicationInfo; 
			uint32_t enabledLayerCount; 
			const(char*)* ppEnabledLayerNames; 
			uint32_t enabledExtensionCount; 
			const(char*)* ppEnabledExtensionNames; 
		} 
		
		enum VkSystemAllocationScope
		{
			VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
			VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
			VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
			VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
			VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
		} 
		
		alias PFN_vkAllocationFunction = void* function(
			void*	pUserData,
			size_t	size,
			size_t	alignment,
			VkSystemAllocationScope 	allocationScope
		); 
		alias PFN_vkReallocationFunction = void* function(
			void*	pUserData,
			void*	pOriginal,
			size_t	size,
			size_t	alignment,
			VkSystemAllocationScope 	allocationScope
		); 
		alias PFN_vkFreeFunction = void function(
			void* 	pUserData,
			void*	pMemory
		); 
		enum VkInternalAllocationType
		{ VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0, } 
		alias PFN_vkInternalAllocationNotification = void function(
			void*	pUserData,
			size_t	size,
			VkInternalAllocationType	allocationType,
			VkSystemAllocationScope 	allocationScope
		); 
		alias PFN_vkInternalFreeNotification = void function(
			void*	pUserData,
			size_t	size,
			VkInternalAllocationType	allocationType,
			VkSystemAllocationScope 	allocationScope
		); 
		struct VkAllocationCallbacks
		{
			void* pUserData; 
			PFN_vkAllocationFunction pfnAllocation; 
			PFN_vkReallocationFunction pfnReallocation; 
			PFN_vkFreeFunction pfnFree; 
			PFN_vkInternalAllocationNotification pfnInternalAllocation; 
			PFN_vkInternalFreeNotification pfnInternalFree; 
		} 
		mixin(VK_DEFINE_HANDLE!q{VkInstance}); 
		mixin(VK_DEFINE_HANDLE!q{VkPhysicalDevice}); 
		alias VkBool32 = uint32_t; 
		struct VkPhysicalDeviceFeatures
		{
			VkBool32 robustBufferAccess; 
			VkBool32 fullDrawIndexUint32; 
			VkBool32 imageCubeArray; 
			VkBool32 independentBlend; 
			VkBool32 geometryShader; 
			VkBool32 tessellationShader; 
			VkBool32 sampleRateShading; 
			VkBool32 dualSrcBlend; 
			VkBool32 logicOp; 
			VkBool32 multiDrawIndirect; 
			VkBool32 drawIndirectFirstInstance; 
			VkBool32 depthClamp; 
			VkBool32 depthBiasClamp; 
			VkBool32 fillModeNonSolid; 
			VkBool32 depthBounds; 
			VkBool32 wideLines; 
			VkBool32 largePoints; 
			VkBool32 alphaToOne; 
			VkBool32 multiViewport; 
			VkBool32 samplerAnisotropy; 
			VkBool32 textureCompressionETC2; 
			VkBool32 textureCompressionASTC_LDR; 
			VkBool32 textureCompressionBC; 
			VkBool32 occlusionQueryPrecise; 
			VkBool32 pipelineStatisticsQuery; 
			VkBool32 vertexPipelineStoresAndAtomics; 
			VkBool32 fragmentStoresAndAtomics; 
			VkBool32 shaderTessellationAndGeometryPointSize; 
			VkBool32 shaderImageGatherExtended; 
			VkBool32 shaderStorageImageExtendedFormats; 
			VkBool32 shaderStorageImageMultisample; 
			VkBool32 shaderStorageImageReadWithoutFormat; 
			VkBool32 shaderStorageImageWriteWithoutFormat; 
			VkBool32 shaderUniformBufferArrayDynamicIndexing; 
			VkBool32 shaderSampledImageArrayDynamicIndexing; 
			VkBool32 shaderStorageBufferArrayDynamicIndexing; 
			VkBool32 shaderStorageImageArrayDynamicIndexing; 
			VkBool32 shaderClipDistance; 
			VkBool32 shaderCullDistance; 
			VkBool32 shaderFloat64; 
			VkBool32 shaderInt64; 
			VkBool32 shaderInt16; 
			VkBool32 shaderResourceResidency; 
			VkBool32 shaderResourceMinLod; 
			VkBool32 sparseBinding; 
			VkBool32 sparseResidencyBuffer; 
			VkBool32 sparseResidencyImage2D; 
			VkBool32 sparseResidencyImage3D; 
			VkBool32 sparseResidency2Samples; 
			VkBool32 sparseResidency4Samples; 
			VkBool32 sparseResidency8Samples; 
			VkBool32 sparseResidency16Samples; 
			VkBool32 sparseResidencyAliased; 
			VkBool32 variableMultisampleRate; 
			VkBool32 inheritedQueries; 
		} 
		alias VkFormat = VK_FORMAT_; 
		enum VK_FORMAT_
		{
			UNDEFINED = 0,
			R4G4_UNORM_PACK8 = 1,
			R4G4B4A4_UNORM_PACK16 = 2,
			B4G4R4A4_UNORM_PACK16 = 3,
			R5G6B5_UNORM_PACK16 = 4,
			B5G6R5_UNORM_PACK16 = 5,
			R5G5B5A1_UNORM_PACK16 = 6,
			B5G5R5A1_UNORM_PACK16 = 7,
			A1R5G5B5_UNORM_PACK16 = 8,
			R8_UNORM = 9,
			R8_SNORM = 10,
			R8_USCALED = 11,
			R8_SSCALED = 12,
			R8_UINT = 13,
			R8_SINT = 14,
			R8_SRGB = 15,
			R8G8_UNORM = 16,
			R8G8_SNORM = 17,
			R8G8_USCALED = 18,
			R8G8_SSCALED = 19,
			R8G8_UINT = 20,
			R8G8_SINT = 21,
			R8G8_SRGB = 22,
			R8G8B8_UNORM = 23,
			R8G8B8_SNORM = 24,
			R8G8B8_USCALED = 25,
			R8G8B8_SSCALED = 26,
			R8G8B8_UINT = 27,
			R8G8B8_SINT = 28,
			R8G8B8_SRGB = 29,
			B8G8R8_UNORM = 30,
			B8G8R8_SNORM = 31,
			B8G8R8_USCALED = 32,
			B8G8R8_SSCALED = 33,
			B8G8R8_UINT = 34,
			B8G8R8_SINT = 35,
			B8G8R8_SRGB = 36,
			R8G8B8A8_UNORM = 37,
			R8G8B8A8_SNORM = 38,
			R8G8B8A8_USCALED = 39,
			R8G8B8A8_SSCALED = 40,
			R8G8B8A8_UINT = 41,
			R8G8B8A8_SINT = 42,
			R8G8B8A8_SRGB = 43,
			B8G8R8A8_UNORM = 44,
			B8G8R8A8_SNORM = 45,
			B8G8R8A8_USCALED = 46,
			B8G8R8A8_SSCALED = 47,
			B8G8R8A8_UINT = 48,
			B8G8R8A8_SINT = 49,
			B8G8R8A8_SRGB = 50,
			A8B8G8R8_UNORM_PACK32 = 51,
			A8B8G8R8_SNORM_PACK32 = 52,
			A8B8G8R8_USCALED_PACK32 = 53,
			A8B8G8R8_SSCALED_PACK32 = 54,
			A8B8G8R8_UINT_PACK32 = 55,
			A8B8G8R8_SINT_PACK32 = 56,
			A8B8G8R8_SRGB_PACK32 = 57,
			A2R10G10B10_UNORM_PACK32 = 58,
			A2R10G10B10_SNORM_PACK32 = 59,
			A2R10G10B10_USCALED_PACK32 = 60,
			A2R10G10B10_SSCALED_PACK32 = 61,
			A2R10G10B10_UINT_PACK32 = 62,
			A2R10G10B10_SINT_PACK32 = 63,
			A2B10G10R10_UNORM_PACK32 = 64,
			A2B10G10R10_SNORM_PACK32 = 65,
			A2B10G10R10_USCALED_PACK32 = 66,
			A2B10G10R10_SSCALED_PACK32 = 67,
			A2B10G10R10_UINT_PACK32 = 68,
			A2B10G10R10_SINT_PACK32 = 69,
			R16_UNORM = 70,
			R16_SNORM = 71,
			R16_USCALED = 72,
			R16_SSCALED = 73,
			R16_UINT = 74,
			R16_SINT = 75,
			R16_SFLOAT = 76,
			R16G16_UNORM = 77,
			R16G16_SNORM = 78,
			R16G16_USCALED = 79,
			R16G16_SSCALED = 80,
			R16G16_UINT = 81,
			R16G16_SINT = 82,
			R16G16_SFLOAT = 83,
			R16G16B16_UNORM = 84,
			R16G16B16_SNORM = 85,
			R16G16B16_USCALED = 86,
			R16G16B16_SSCALED = 87,
			R16G16B16_UINT = 88,
			R16G16B16_SINT = 89,
			R16G16B16_SFLOAT = 90,
			R16G16B16A16_UNORM = 91,
			R16G16B16A16_SNORM = 92,
			R16G16B16A16_USCALED = 93,
			R16G16B16A16_SSCALED = 94,
			R16G16B16A16_UINT = 95,
			R16G16B16A16_SINT = 96,
			R16G16B16A16_SFLOAT = 97,
			R32_UINT = 98,
			R32_SINT = 99,
			R32_SFLOAT = 100,
			R32G32_UINT = 101,
			R32G32_SINT = 102,
			R32G32_SFLOAT = 103,
			R32G32B32_UINT = 104,
			R32G32B32_SINT = 105,
			R32G32B32_SFLOAT = 106,
			R32G32B32A32_UINT = 107,
			R32G32B32A32_SINT = 108,
			R32G32B32A32_SFLOAT = 109,
			R64_UINT = 110,
			R64_SINT = 111,
			R64_SFLOAT = 112,
			R64G64_UINT = 113,
			R64G64_SINT = 114,
			R64G64_SFLOAT = 115,
			R64G64B64_UINT = 116,
			R64G64B64_SINT = 117,
			R64G64B64_SFLOAT = 118,
			R64G64B64A64_UINT = 119,
			R64G64B64A64_SINT = 120,
			R64G64B64A64_SFLOAT = 121,
			B10G11R11_UFLOAT_PACK32 = 122,
			E5B9G9R9_UFLOAT_PACK32 = 123,
			D16_UNORM = 124,
			X8_D24_UNORM_PACK32 = 125,
			D32_SFLOAT = 126,
			S8_UINT = 127,
			D16_UNORM_S8_UINT = 128,
			D24_UNORM_S8_UINT = 129,
			D32_SFLOAT_S8_UINT = 130,
			BC1_RGB_UNORM_BLOCK = 131,
			BC1_RGB_SRGB_BLOCK = 132,
			BC1_RGBA_UNORM_BLOCK = 133,
			BC1_RGBA_SRGB_BLOCK = 134,
			BC2_UNORM_BLOCK = 135,
			BC2_SRGB_BLOCK = 136,
			BC3_UNORM_BLOCK = 137,
			BC3_SRGB_BLOCK = 138,
			BC4_UNORM_BLOCK = 139,
			BC4_SNORM_BLOCK = 140,
			BC5_UNORM_BLOCK = 141,
			BC5_SNORM_BLOCK = 142,
			BC6H_UFLOAT_BLOCK = 143,
			BC6H_SFLOAT_BLOCK = 144,
			BC7_UNORM_BLOCK = 145,
			BC7_SRGB_BLOCK = 146,
			ETC2_R8G8B8_UNORM_BLOCK = 147,
			ETC2_R8G8B8_SRGB_BLOCK = 148,
			ETC2_R8G8B8A1_UNORM_BLOCK = 149,
			ETC2_R8G8B8A1_SRGB_BLOCK = 150,
			ETC2_R8G8B8A8_UNORM_BLOCK = 151,
			ETC2_R8G8B8A8_SRGB_BLOCK = 152,
			EAC_R11_UNORM_BLOCK = 153,
			EAC_R11_SNORM_BLOCK = 154,
			EAC_R11G11_UNORM_BLOCK = 155,
			EAC_R11G11_SNORM_BLOCK = 156,
			ASTC_4x4_UNORM_BLOCK = 157,
			ASTC_4x4_SRGB_BLOCK = 158,
			ASTC_5x4_UNORM_BLOCK = 159,
			ASTC_5x4_SRGB_BLOCK = 160,
			ASTC_5x5_UNORM_BLOCK = 161,
			ASTC_5x5_SRGB_BLOCK = 162,
			ASTC_6x5_UNORM_BLOCK = 163,
			ASTC_6x5_SRGB_BLOCK = 164,
			ASTC_6x6_UNORM_BLOCK = 165,
			ASTC_6x6_SRGB_BLOCK = 166,
			ASTC_8x5_UNORM_BLOCK = 167,
			ASTC_8x5_SRGB_BLOCK = 168,
			ASTC_8x6_UNORM_BLOCK = 169,
			ASTC_8x6_SRGB_BLOCK = 170,
			ASTC_8x8_UNORM_BLOCK = 171,
			ASTC_8x8_SRGB_BLOCK = 172,
			ASTC_10x5_UNORM_BLOCK = 173,
			ASTC_10x5_SRGB_BLOCK = 174,
			ASTC_10x6_UNORM_BLOCK = 175,
			ASTC_10x6_SRGB_BLOCK = 176,
			ASTC_10x8_UNORM_BLOCK = 177,
			ASTC_10x8_SRGB_BLOCK = 178,
			ASTC_10x10_UNORM_BLOCK = 179,
			ASTC_10x10_SRGB_BLOCK = 180,
			ASTC_12x10_UNORM_BLOCK = 181,
			ASTC_12x10_SRGB_BLOCK = 182,
			ASTC_12x12_UNORM_BLOCK = 183,
			ASTC_12x12_SRGB_BLOCK = 184,
		} 
		
		enum VkFormatFeatureFlagBits
		{
			VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x00000001,
			VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x00000002,
			VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004,
			VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008,
			VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x00000010,
			VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020,
			VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x00000040,
			VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x00000080,
			VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100,
			VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200,
			VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0x00000400,
			VK_FORMAT_FEATURE_BLIT_DST_BIT = 0x00000800,
			VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000,
			VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 0x00002000,
		} 
		alias VkFormatFeatureFlags = VkFlags; 
		
		struct VkFormatProperties
		{
			VkFormatFeatureFlags linearTilingFeatures; 
			VkFormatFeatureFlags optimalTilingFeatures; 
			VkFormatFeatureFlags bufferFeatures; 
		} 
		enum VkImageType
		{
			VK_IMAGE_TYPE_1D = 0,
			VK_IMAGE_TYPE_2D = 1,
			VK_IMAGE_TYPE_3D = 2,
		} 
		enum VkImageTiling
		{
			VK_IMAGE_TILING_OPTIMAL = 0,
			VK_IMAGE_TILING_LINEAR = 1,
		} 
		
		alias VkImageUsageFlagBits = VK_IMAGE_USAGE_; 
		enum VK_IMAGE_USAGE_
		{
			TRANSFER_SRC_BIT = 0x00000001,
			TRANSFER_DST_BIT = 0x00000002,
			SAMPLED_BIT = 0x00000004,
			STORAGE_BIT = 0x00000008,
			COLOR_ATTACHMENT_BIT = 0x00000010,
			DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020,
			TRANSIENT_ATTACHMENT_BIT = 0x00000040,
			INPUT_ATTACHMENT_BIT = 0x00000080,
		} 
		alias VkImageUsageFlags = VkBitFlags!VkImageUsageFlagBits; 
		enum VkImageCreateFlagBits
		{
			VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0x00000001,
			VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
			VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
			VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x00000008,
			VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x00000010,
		} 
		alias VkImageCreateFlags = VkFlags; 
		struct VkExtent3D
		{
			uint32_t width; 
			uint32_t height; 
			uint32_t depth; 
		} 
		alias VkSampleCountFlagBits = VK_SAMPLE_COUNT; 
		enum VK_SAMPLE_COUNT
		{
			_1_BIT = 0x00000001,
			_2_BIT = 0x00000002,
			_4_BIT = 0x00000004,
			_8_BIT = 0x00000008,
			_16_BIT = 0x00000010,
			_32_BIT = 0x00000020,
			_64_BIT = 0x00000040,
		} 
		alias VkSampleCountFlags = VkBitFlags!VkSampleCountFlagBits; 
		alias VkDeviceSize = uint64_t; 
		struct VkImageFormatProperties
		{
			VkExtent3D maxExtent; 
			uint32_t maxMipLevels; 
			uint32_t maxArrayLayers; 
			VkSampleCountFlags sampleCounts; 
			VkDeviceSize maxResourceSize; 
		} 
		
		alias VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_; 
		enum VK_PHYSICAL_DEVICE_TYPE_
		{
			OTHER = 0,
			INTEGRATED_GPU = 1,
			DISCRETE_GPU = 2,
			VIRTUAL_GPU = 3,
			CPU = 4,
		} 
		
		struct VkPhysicalDeviceLimits
		{
			uint32_t maxImageDimension1D; 
			uint32_t maxImageDimension2D; 
			uint32_t maxImageDimension3D; 
			uint32_t maxImageDimensionCube; 
			uint32_t maxImageArrayLayers; 
			uint32_t maxTexelBufferElements; 
			uint32_t maxUniformBufferRange; 
			uint32_t maxStorageBufferRange; 
			uint32_t maxPushConstantsSize; 
			uint32_t maxMemoryAllocationCount; 
			uint32_t maxSamplerAllocationCount; 
			VkDeviceSize bufferImageGranularity; 
			VkDeviceSize sparseAddressSpaceSize; 
			uint32_t maxBoundDescriptorSets; 
			uint32_t maxPerStageDescriptorSamplers; 
			uint32_t maxPerStageDescriptorUniformBuffers; 
			uint32_t maxPerStageDescriptorStorageBuffers; 
			uint32_t maxPerStageDescriptorSampledImages; 
			uint32_t maxPerStageDescriptorStorageImages; 
			uint32_t maxPerStageDescriptorInputAttachments; 
			uint32_t maxPerStageResources; 
			uint32_t maxDescriptorSetSamplers; 
			uint32_t maxDescriptorSetUniformBuffers; 
			uint32_t maxDescriptorSetUniformBuffersDynamic; 
			uint32_t maxDescriptorSetStorageBuffers; 
			uint32_t maxDescriptorSetStorageBuffersDynamic; 
			uint32_t maxDescriptorSetSampledImages; 
			uint32_t maxDescriptorSetStorageImages; 
			uint32_t maxDescriptorSetInputAttachments; 
			uint32_t maxVertexInputAttributes; 
			uint32_t maxVertexInputBindings; 
			uint32_t maxVertexInputAttributeOffset; 
			uint32_t maxVertexInputBindingStride; 
			uint32_t maxVertexOutputComponents; 
			uint32_t maxTessellationGenerationLevel; 
			uint32_t maxTessellationPatchSize; 
			uint32_t maxTessellationControlPerVertexInputComponents; 
			uint32_t maxTessellationControlPerVertexOutputComponents; 
			uint32_t maxTessellationControlPerPatchOutputComponents; 
			uint32_t maxTessellationControlTotalOutputComponents; 
			uint32_t maxTessellationEvaluationInputComponents; 
			uint32_t maxTessellationEvaluationOutputComponents; 
			uint32_t maxGeometryShaderInvocations; 
			uint32_t maxGeometryInputComponents; 
			uint32_t maxGeometryOutputComponents; 
			uint32_t maxGeometryOutputVertices; 
			uint32_t maxGeometryTotalOutputComponents; 
			uint32_t maxFragmentInputComponents; 
			uint32_t maxFragmentOutputAttachments; 
			uint32_t maxFragmentDualSrcAttachments; 
			uint32_t maxFragmentCombinedOutputResources; 
			uint32_t maxComputeSharedMemorySize; 
			uint32_t[3] maxComputeWorkGroupCount; 
			uint32_t maxComputeWorkGroupInvocations; 
			uint32_t[3] maxComputeWorkGroupSize; 
			uint32_t subPixelPrecisionBits; 
			uint32_t subTexelPrecisionBits; 
			uint32_t mipmapPrecisionBits; 
			uint32_t maxDrawIndexedIndexValue; 
			uint32_t maxDrawIndirectCount; 
			float maxSamplerLodBias; 
			float maxSamplerAnisotropy; 
			uint32_t maxViewports; 
			uint32_t[2] maxViewportDimensions; 
			float[2] viewportBoundsRange; 
			uint32_t viewportSubPixelBits; 
			size_t minMemoryMapAlignment; 
			VkDeviceSize minTexelBufferOffsetAlignment; 
			VkDeviceSize minUniformBufferOffsetAlignment; 
			VkDeviceSize minStorageBufferOffsetAlignment; 
			int32_t minTexelOffset; 
			uint32_t maxTexelOffset; 
			int32_t minTexelGatherOffset; 
			uint32_t maxTexelGatherOffset; 
			float minInterpolationOffset; 
			float maxInterpolationOffset; 
			uint32_t subPixelInterpolationOffsetBits; 
			uint32_t maxFramebufferWidth; 
			uint32_t maxFramebufferHeight; 
			uint32_t maxFramebufferLayers; 
			VkSampleCountFlags framebufferColorSampleCounts; 
			VkSampleCountFlags framebufferDepthSampleCounts; 
			VkSampleCountFlags framebufferStencilSampleCounts; 
			VkSampleCountFlags framebufferNoAttachmentsSampleCounts; 
			uint32_t maxColorAttachments; 
			VkSampleCountFlags sampledImageColorSampleCounts; 
			VkSampleCountFlags sampledImageIntegerSampleCounts; 
			VkSampleCountFlags sampledImageDepthSampleCounts; 
			VkSampleCountFlags sampledImageStencilSampleCounts; 
			VkSampleCountFlags storageImageSampleCounts; 
			uint32_t maxSampleMaskWords; 
			VkBool32 timestampComputeAndGraphics; 
			float timestampPeriod; 
			uint32_t maxClipDistances; 
			uint32_t maxCullDistances; 
			uint32_t maxCombinedClipAndCullDistances; 
			uint32_t discreteQueuePriorities; 
			float[2] pointSizeRange; 
			float[2] lineWidthRange; 
			float pointSizeGranularity; 
			float lineWidthGranularity; 
			VkBool32 strictLines; 
			VkBool32 standardSampleLocations; 
			VkDeviceSize optimalBufferCopyOffsetAlignment; 
			VkDeviceSize optimalBufferCopyRowPitchAlignment; 
			VkDeviceSize nonCoherentAtomSize; 
		} 
		struct VkPhysicalDeviceSparseProperties
		{
			VkBool32 residencyStandard2DBlockShape; 
			VkBool32 residencyStandard2DMultisampleBlockShape; 
			VkBool32 residencyStandard3DBlockShape; 
			VkBool32 residencyAlignedMipSize; 
			VkBool32 residencyNonResidentStrict; 
		} 
		
		enum VK_MAX_PHYSICAL_DEVICE_NAME_SIZE = 256; 
		enum VK_UUID_SIZE = 16; 
		struct VkPhysicalDeviceProperties
		{
			uint32_t apiVersion; 
			uint32_t driverVersion; 
			uint32_t vendorID; 
			uint32_t deviceID; 
			VkPhysicalDeviceType deviceType; 
			char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] deviceName; 
			uint8_t[VK_UUID_SIZE] pipelineCacheUUID; 
			VkPhysicalDeviceLimits limits; 
			VkPhysicalDeviceSparseProperties sparseProperties; 
		} 
		
		enum VK_QUEUE_
		{
			GRAPHICS_BIT = 0x00000001,
			COMPUTE_BIT = 0x00000002,
			TRANSFER_BIT = 0x00000004,
			SPARSE_BINDING_BIT = 0x00000008,
		} 
		alias VkQueueFlags = VkBitFlags!VK_QUEUE_; 
		
		struct VkQueueFamilyProperties
		{
			VkQueueFlags queueFlags; 
			uint32_t queueCount; 
			uint32_t timestampValidBits; 
			VkExtent3D minImageTransferGranularity; 
		} 
		
		alias VkMemoryPropertyFlagBits = VK_MEMORY_PROPERTY_; 
		enum VK_MEMORY_PROPERTY_
		{
			DEVICE_LOCAL_BIT = 0x00000001,
			HOST_VISIBLE_BIT = 0x00000002,
			HOST_COHERENT_BIT = 0x00000004,
			HOST_CACHED_BIT = 0x00000008,
			LAZILY_ALLOCATED_BIT = 0x00000010,
		} 
		alias VkMemoryPropertyFlags = VkBitFlags!VkMemoryPropertyFlagBits; 
		
		struct VkMemoryType
		{
			VkMemoryPropertyFlags propertyFlags; 
			uint32_t heapIndex; 
		} 
		
		alias VkMemoryHeapFlagBits =  VK_MEMORY_HEAP_; 
		enum VK_MEMORY_HEAP_
		{DEVICE_LOCAL_BIT = 0x00000001, } 
		alias VkMemoryHeapFlags = VkBitFlags!VkMemoryHeapFlagBits; 
		
		struct VkMemoryHeap
		{
			VkDeviceSize size; 
			VkMemoryHeapFlags flags; 
		} 
		
		enum VK_MAX_MEMORY_TYPES = 32; 
		enum VK_MAX_MEMORY_HEAPS = 16; 
		struct VkPhysicalDeviceMemoryProperties
		{
			uint32_t memoryTypeCount; 
			VkMemoryType[VK_MAX_MEMORY_TYPES] memoryTypes; 
			uint32_t memoryHeapCount; 
			VkMemoryHeap[VK_MAX_MEMORY_HEAPS] memoryHeaps; 
		} 
		alias PFN_vkVoidFunction = void function(); 
		mixin(VK_DEFINE_HANDLE!q{VkDevice}); 
		alias VkDeviceCreateFlags = VkFlags; 
		alias VkDeviceQueueCreateFlags = VkFlags; 
		
		struct VkDeviceQueueCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.DEVICE_QUEUE_CREATE_INFO; 
			const(void)* pNext; 
			VkDeviceQueueCreateFlags flags; 
			uint32_t queueFamilyIndex; 
			uint32_t queueCount; 
			const(float)* pQueuePriorities; 
		} 
		
		struct VkDeviceCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.DEVICE_CREATE_INFO; 
			const(void)* pNext; 
			VkDeviceCreateFlags flags; 
			uint32_t queueCreateInfoCount; 
			const(VkDeviceQueueCreateInfo)* pQueueCreateInfos; 
			uint32_t enabledLayerCount; 
			const(char*)* ppEnabledLayerNames; 
			uint32_t enabledExtensionCount; 
			const(char*)* ppEnabledExtensionNames; 
			const(VkPhysicalDeviceFeatures)* pEnabledFeatures; 
		} 
		
		enum VK_MAX_EXTENSION_NAME_SIZE = 256; 
		struct VkExtensionProperties
		{
			char[VK_MAX_EXTENSION_NAME_SIZE] extensionName; 
			uint32_t specVersion; 
		} 
		
		enum VK_MAX_DESCRIPTION_SIZE = 256; 
		struct VkLayerProperties
		{
			char[VK_MAX_EXTENSION_NAME_SIZE] layerName; 
			uint32_t specVersion; 
			uint32_t implementationVersion; 
			char[VK_MAX_DESCRIPTION_SIZE] description; 
		} 
		
		mixin(VK_DEFINE_HANDLE!q{VkQueue}); 
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkSemaphore}); 
		
		alias VkPipelineStageFlagBits = VK_PIPELINE_STAGE_; 
		enum VK_PIPELINE_STAGE_
		{
			TOP_OF_PIPE_BIT = 0x00000001,
			DRAW_INDIRECT_BIT = 0x00000002,
			VERTEX_INPUT_BIT = 0x00000004,
			VERTEX_SHADER_BIT = 0x00000008,
			TESSELLATION_CONTROL_SHADER_BIT = 0x00000010,
			TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020,
			GEOMETRY_SHADER_BIT = 0x00000040,
			FRAGMENT_SHADER_BIT = 0x00000080,
			EARLY_FRAGMENT_TESTS_BIT = 0x00000100,
			LATE_FRAGMENT_TESTS_BIT = 0x00000200,
			COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400,
			COMPUTE_SHADER_BIT = 0x00000800,
			TRANSFER_BIT = 0x00001000,
			BOTTOM_OF_PIPE_BIT = 0x00002000,
			HOST_BIT = 0x00004000,
			ALL_GRAPHICS_BIT = 0x00008000,
			ALL_COMMANDS_BIT = 0x00010000,
		} 
		alias VkPipelineStageFlags = VkBitFlags!VkPipelineStageFlagBits; 
		
		mixin(VK_DEFINE_HANDLE!q{VkCommandBuffer}); 
		struct VkSubmitInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.SUBMIT_INFO; 
			const(void)* pNext; 
			uint32_t waitSemaphoreCount; 
			const(VkSemaphore)* pWaitSemaphores; 
			const(VkPipelineStageFlags)* pWaitDstStageMask; 
			uint32_t commandBufferCount; 
			const(VkCommandBuffer)* pCommandBuffers; 
			uint32_t signalSemaphoreCount; 
			const(VkSemaphore)* pSignalSemaphores; 
		} 
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkFence}); 
		struct VkMemoryAllocateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.MEMORY_ALLOCATE_INFO; 
			const(void)* pNext; 
			VkDeviceSize allocationSize; 
			uint32_t memoryTypeIndex; 
		} 
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkDeviceMemory}); 
		alias VkMemoryMapFlags = VkFlags; 
		struct VkMappedMemoryRange
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.MAPPED_MEMORY_RANGE; 
			const(void)* pNext; 
			VkDeviceMemory memory; 
			VkDeviceSize offset; 
			VkDeviceSize size; 
		} 
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkBuffer}); 
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkImage}); 
		struct VkMemoryRequirements
		{
			VkDeviceSize size; 
			VkDeviceSize alignment; 
			uint32_t memoryTypeBits; 
		} 
		
		alias VkImageAspectFlagBits = VK_IMAGE_ASPECT_; 
		enum VK_IMAGE_ASPECT_
		{
			COLOR_BIT = 0x00000001,
			DEPTH_BIT = 0x00000002,
			STENCIL_BIT = 0x00000004,
			METADATA_BIT = 0x00000008,
		} 
		alias VkImageAspectFlags = VkBitFlags!VkImageAspectFlagBits; 
		
		enum VkSparseImageFormatFlagBits
		{
			VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x00000001,
			VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x00000002,
			VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004,
		} 
		alias VkSparseImageFormatFlags = VkFlags; 
		struct VkSparseImageFormatProperties
		{
			VkImageAspectFlags aspectMask; 
			VkExtent3D imageGranularity; 
			VkSparseImageFormatFlags flags; 
		} 
		struct VkSparseImageMemoryRequirements
		{
			VkSparseImageFormatProperties formatProperties; 
			uint32_t imageMipTailFirstLod; 
			VkDeviceSize imageMipTailSize; 
			VkDeviceSize imageMipTailOffset; 
			VkDeviceSize imageMipTailStride; 
		} 
		enum VkSparseMemoryBindFlagBits
		{ VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001, } 
		alias VkSparseMemoryBindFlags = VkFlags; 
		struct VkSparseMemoryBind
		{
			VkDeviceSize resourceOffset; 
			VkDeviceSize size; 
			VkDeviceMemory memory; 
			VkDeviceSize memoryOffset; 
			VkSparseMemoryBindFlags flags; 
		} 
		struct VkSparseBufferMemoryBindInfo
		{
			VkBuffer buffer; 
			uint32_t bindCount; 
			const(VkSparseMemoryBind)* pBinds; 
		} 
		struct VkSparseImageOpaqueMemoryBindInfo
		{
			VkImage image; 
			uint32_t bindCount; 
			const(VkSparseMemoryBind)* pBinds; 
		} 
		struct VkImageSubresource
		{
			VkImageAspectFlags aspectMask; 
			uint32_t mipLevel; 
			uint32_t arrayLayer; 
		} 
		struct VkOffset3D
		{
			int32_t x; 
			int32_t y; 
			int32_t z; 
		} 
		struct VkSparseImageMemoryBind
		{
			VkImageSubresource subresource; 
			VkOffset3D offset; 
			VkExtent3D extent; 
			VkDeviceMemory memory; 
			VkDeviceSize memoryOffset; 
			VkSparseMemoryBindFlags flags; 
		} 
		struct VkSparseImageMemoryBindInfo
		{
			VkImage image; 
			uint32_t bindCount; 
			const(VkSparseImageMemoryBind)* pBinds; 
		} 
		struct VkBindSparseInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.BIND_SPARSE_INFO; 
			const(void)* pNext; 
			uint32_t waitSemaphoreCount; 
			const(VkSemaphore)* pWaitSemaphores; 
			uint32_t bufferBindCount; 
			const(VkSparseBufferMemoryBindInfo)* pBufferBinds; 
			uint32_t imageOpaqueBindCount; 
			const(VkSparseImageOpaqueMemoryBindInfo)* pImageOpaqueBinds; 
			uint32_t imageBindCount; 
			const(VkSparseImageMemoryBindInfo)* pImageBinds; 
			uint32_t signalSemaphoreCount; 
			const(VkSemaphore)* pSignalSemaphores; 
		} 
		alias VkFenceCreateFlagBits = VK_FENCE_CREATE_; 
		enum VK_FENCE_CREATE_
		{SIGNALED_BIT = 0x00000001, } 
		alias VkFenceCreateFlags = VkBitFlags!VkFenceCreateFlagBits; 
		
		struct VkFenceCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.FENCE_CREATE_INFO; 
			const(void)* pNext; 
			VkFenceCreateFlags flags; 
		} 
		
		alias VkSemaphoreCreateFlags = VkFlags; 
		
		struct VkSemaphoreCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.SEMAPHORE_CREATE_INFO; 
			const(void)* pNext; 
			VkSemaphoreCreateFlags flags; 
		} 
		
		alias VkEventCreateFlags = VkFlags; 
		struct VkEventCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.EVENT_CREATE_INFO; 
			const(void)* pNext; 
			VkEventCreateFlags flags; 
		} 
		
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkEvent}); 
		
		alias VkQueryPoolCreateFlags = VkFlags; 
		enum VkQueryType
		{
			VK_QUERY_TYPE_OCCLUSION = 0,
			VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
			VK_QUERY_TYPE_TIMESTAMP = 2,
		} 
		enum VkQueryPipelineStatisticFlagBits
		{
			VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x00000001,
			VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x00000002,
			VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x00000004,
			VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x00000008,
			VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x00000010,
			VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x00000020,
			VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x00000040,
			VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x00000080,
			VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x00000100,
			VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200,
			VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x00000400,
		} 
		alias VkQueryPipelineStatisticFlags = VkFlags; 
		struct VkQueryPoolCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.QUERY_POOL_CREATE_INFO; 
			const(void)* pNext; 
			VkQueryPoolCreateFlags flags; 
			VkQueryType queryType; 
			uint32_t queryCount; 
			VkQueryPipelineStatisticFlags pipelineStatistics; 
		} 
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkQueryPool}); 
		enum VkQueryResultFlagBits
		{
			VK_QUERY_RESULT_64_BIT = 0x00000001,
			VK_QUERY_RESULT_WAIT_BIT = 0x00000002,
			VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004,
			VK_QUERY_RESULT_PARTIAL_BIT = 0x00000008,
		} 
		alias VkQueryResultFlags = VkFlags; 
		enum VkBufferCreateFlagBits
		{
			VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0x00000001,
			VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
			VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
		} 
		alias VkBufferCreateFlags = VkFlags; 
		alias VkBufferUsageFlagBits = VK_BUFFER_USAGE_; 
		enum VK_BUFFER_USAGE_
		{
			TRANSFER_SRC_BIT = 0x00000001,
			TRANSFER_DST_BIT = 0x00000002,
			UNIFORM_TEXEL_BUFFER_BIT = 0x00000004,
			STORAGE_TEXEL_BUFFER_BIT = 0x00000008,
			UNIFORM_BUFFER_BIT = 0x00000010,
			STORAGE_BUFFER_BIT = 0x00000020,
			INDEX_BUFFER_BIT = 0x00000040,
			VERTEX_BUFFER_BIT = 0x00000080,
			INDIRECT_BUFFER_BIT = 0x00000100,
		} 
		alias VkBufferUsageFlags = VkBitFlags!VkBufferUsageFlagBits; 
		
		alias VkSharingMode = VK_SHARING_MODE_; 
		enum VK_SHARING_MODE_
		{
			EXCLUSIVE = 0,
			CONCURRENT = 1,
		} 
		
		struct VkBufferCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.BUFFER_CREATE_INFO; 
			const(void)* pNext; 
			VkBufferCreateFlags flags; 
			VkDeviceSize size; 
			VkBufferUsageFlags usage; 
			VkSharingMode sharingMode; 
			uint32_t queueFamilyIndexCount; 
			const(uint32_t)* pQueueFamilyIndices; 
		} 
		
		alias VkBufferViewCreateFlags = VkFlags; 
		struct VkBufferViewCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.BUFFER_VIEW_CREATE_INFO; 
			const(void)* pNext; 
			VkBufferViewCreateFlags flags; 
			VkBuffer buffer; 
			VkFormat format; 
			VkDeviceSize offset; 
			VkDeviceSize range; 
		} 
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkBufferView}); 
		
		alias VkImageLayout = VK_IMAGE_LAYOUT_; 
		enum VK_IMAGE_LAYOUT_
		{
			UNDEFINED = 0,
			GENERAL = 1,
			COLOR_ATTACHMENT_OPTIMAL = 2,
			DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
			DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
			SHADER_READ_ONLY_OPTIMAL = 5,
			TRANSFER_SRC_OPTIMAL = 6,
			TRANSFER_DST_OPTIMAL = 7,
			PREINITIALIZED = 8,
			PRESENT_SRC_KHR = 1000001002,
		} 
		
		struct VkImageCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.IMAGE_CREATE_INFO; 
			const(void)* pNext; 
			VkImageCreateFlags flags; 
			VkImageType imageType; 
			VkFormat format; 
			VkExtent3D extent; 
			uint32_t mipLevels; 
			uint32_t arrayLayers; 
			VkSampleCountFlagBits samples; 
			VkImageTiling tiling; 
			VkImageUsageFlags usage; 
			VkSharingMode sharingMode; 
			uint32_t queueFamilyIndexCount; 
			const(uint32_t)* pQueueFamilyIndices; 
			VkImageLayout initialLayout; 
		} 
		struct VkSubresourceLayout
		{
			VkDeviceSize offset; 
			VkDeviceSize size; 
			VkDeviceSize rowPitch; 
			VkDeviceSize arrayPitch; 
			VkDeviceSize depthPitch; 
		} 
		
		alias VkImageViewCreateFlags = VkFlags; 
		
		alias VkImageViewType = VK_IMAGE_VIEW_TYPE; 
		enum VK_IMAGE_VIEW_TYPE
		{
			_1D = 0,
			_2D = 1,
			_3D = 2,
			_CUBE = 3,
			_1D_ARRAY = 4,
			_2D_ARRAY = 5,
			_CUBE_ARRAY = 6,
		} 
		
		alias VkComponentSwizzle = VK_COMPONENT_SWIZZLE_; 
		enum VK_COMPONENT_SWIZZLE_
		{
			IDENTITY = 0,
			ZERO = 1,
			ONE = 2,
			R = 3,
			G = 4,
			B = 5,
			A = 6,
		} 
		
		struct VkComponentMapping
		{
			VkComponentSwizzle r; 
			VkComponentSwizzle g; 
			VkComponentSwizzle b; 
			VkComponentSwizzle a; 
		} 
		
		struct VkImageSubresourceRange
		{
			VkImageAspectFlags aspectMask; 
			uint32_t baseMipLevel; 
			uint32_t levelCount; 
			uint32_t baseArrayLayer; 
			uint32_t layerCount; 
		} 
		
		struct VkImageViewCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.IMAGE_VIEW_CREATE_INFO; 
			const(void)* pNext; 
			VkImageViewCreateFlags flags; 
			VkImage image; 
			VkImageViewType viewType; 
			VkFormat format; 
			VkComponentMapping components; 
			VkImageSubresourceRange subresourceRange; 
		} 
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkImageView}); 
		
		alias VkShaderModuleCreateFlags = VkFlags; 
		struct VkShaderModuleCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.SHADER_MODULE_CREATE_INFO; 
			const(void)* pNext; 
			VkShaderModuleCreateFlags flags; 
			size_t codeSize; 
			const(uint32_t)* pCode; 
		} 
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkShaderModule}); 
		alias VkPipelineCacheCreateFlags = VkFlags; 
		struct VkPipelineCacheCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.PIPELINE_CACHE_CREATE_INFO; 
			const(void)* pNext; 
			VkPipelineCacheCreateFlags flags; 
			size_t initialDataSize; 
			const(void)* pInitialData; 
		} 
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkPipelineCache}); 
		enum VkPipelineCreateFlagBits
		{
			VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001,
			VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x00000002,
			VK_PIPELINE_CREATE_DERIVATIVE_BIT = 0x00000004,
		} 
		alias VkPipelineCreateFlags = VkFlags; 
		alias VkPipelineShaderStageCreateFlags = VkFlags; 
		
		alias VkShaderStageFlagBits = VK_SHADER_STAGE_; 
		enum VK_SHADER_STAGE_
		{
			VERTEX_BIT = 0x00000001,
			TESSELLATION_CONTROL_BIT = 0x00000002,
			TESSELLATION_EVALUATION_BIT = 0x00000004,
			GEOMETRY_BIT = 0x00000008,
			FRAGMENT_BIT = 0x00000010,
			COMPUTE_BIT = 0x00000020,
			ALL_GRAPHICS = 0x0000001F,
			ALL = 0x7FFFFFFF,
		} 
		alias VkShaderStageFlags = VkBitFlags!(VkShaderStageFlagBits, Yes.unsafe); 
		
		struct VkSpecializationMapEntry
		{
			uint32_t constantID; 
			uint32_t offset; 
			size_t size; 
		} 
		struct VkSpecializationInfo
		{
			uint32_t mapEntryCount; 
			const(VkSpecializationMapEntry)* pMapEntries; 
			size_t dataSize; 
			const(void)* pData; 
		} 
		struct VkPipelineShaderStageCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.PIPELINE_SHADER_STAGE_CREATE_INFO; 
			const(void)* pNext; 
			VkPipelineShaderStageCreateFlags flags; 
			VkShaderStageFlagBits stage; 
			VkShaderModule _module; 
			const(char)* pName; 
			const(VkSpecializationInfo)* pSpecializationInfo; 
		} 
		
		alias VkPipelineVertexInputStateCreateFlags = VkFlags; 
		
		alias VkVertexInputRate = VK_VERTEX_INPUT_RATE_; 
		enum VK_VERTEX_INPUT_RATE_
		{
			VERTEX = 0,
			INSTANCE = 1,
		} 
		
		struct VkVertexInputBindingDescription
		{
			uint32_t binding; 
			uint32_t stride; 
			VkVertexInputRate inputRate; 
		} 
		
		struct VkVertexInputAttributeDescription
		{
			uint32_t location; 
			uint32_t binding; 
			VkFormat format; 
			uint32_t offset; 
		} 
		struct VkPipelineVertexInputStateCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO; 
			const(void)* pNext; 
			VkPipelineVertexInputStateCreateFlags flags; 
			uint32_t vertexBindingDescriptionCount; 
			const(VkVertexInputBindingDescription)* pVertexBindingDescriptions; 
			uint32_t vertexAttributeDescriptionCount; 
			const(VkVertexInputAttributeDescription)* pVertexAttributeDescriptions; 
		} 
		alias VkPipelineInputAssemblyStateCreateFlags = VkFlags; 
		
		alias VkPrimitiveTopology = VK_PRIMITIVE_TOPOLOGY_; 
		enum VK_PRIMITIVE_TOPOLOGY_
		{
			POINT_LIST = 0,
			LINE_LIST = 1,
			LINE_STRIP = 2,
			TRIANGLE_LIST = 3,
			TRIANGLE_STRIP = 4,
			TRIANGLE_FAN = 5,
			LINE_LIST_WITH_ADJACENCY = 6,
			LINE_STRIP_WITH_ADJACENCY = 7,
			TRIANGLE_LIST_WITH_ADJACENCY = 8,
			TRIANGLE_STRIP_WITH_ADJACENCY = 9,
			PATCH_LIST = 10,
		} 
		
		struct VkPipelineInputAssemblyStateCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO; 
			const(void)* pNext; 
			VkPipelineInputAssemblyStateCreateFlags flags; 
			VkPrimitiveTopology topology; 
			VkBool32 primitiveRestartEnable; 
		} 
		
		alias VkPipelineTessellationStateCreateFlags = VkFlags; 
		
		struct VkPipelineTessellationStateCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.PIPELINE_TESSELLATION_STATE_CREATE_INFO; 
			const(void)* pNext; 
			VkPipelineTessellationStateCreateFlags flags; 
			uint32_t patchControlPoints; 
		} 
		
		alias VkPipelineViewportStateCreateFlags = VkFlags; 
		
		struct VkViewport
		{
			float x; 
			float y; 
			float width; 
			float height; 
			float minDepth; 
			float maxDepth; 
		} 
		
		struct VkOffset2D
		{
			int32_t x; 
			int32_t y; 
		} 
		
		struct VkExtent2D
		{
			uint32_t width; 
			uint32_t height; 
		} 
		
		struct VkRect2D
		{
			VkOffset2D offset; 
			VkExtent2D extent; 
		} 
		
		struct VkPipelineViewportStateCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.PIPELINE_VIEWPORT_STATE_CREATE_INFO; 
			const(void)* pNext; 
			VkPipelineViewportStateCreateFlags flags; 
			uint32_t viewportCount; 
			const(VkViewport)* pViewports; 
			uint32_t scissorCount; 
			const(VkRect2D)* pScissors; 
		} 
		
		alias VkPipelineRasterizationStateCreateFlags = VkFlags; 
		
		alias VkPolygonMode = VK_POLYGON_MODE_; 
		enum VK_POLYGON_MODE_
		{
			FILL = 0,
			LINE = 1,
			POINT = 2,
		} 
		
		alias VkCullModeFlagBits = VK_CULL_MODE_; 
		enum VK_CULL_MODE_
		{
			NONE = 0,
			FRONT_BIT = 0x00000001,
			BACK_BIT = 0x00000002,
			FRONT_AND_BACK = 0x00000003,
		} 
		alias VkCullModeFlags = VkBitFlags!(VkCullModeFlagBits, Yes.unsafe); 
		
		alias VkFrontFace = VK_FRONT_FACE_; 
		enum VK_FRONT_FACE_
		{
			COUNTER_CLOCKWISE = 0,
			CLOCKWISE = 1,
		} 
		
		struct VkPipelineRasterizationStateCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.PIPELINE_RASTERIZATION_STATE_CREATE_INFO; 
			const(void)* pNext; 
			VkPipelineRasterizationStateCreateFlags flags; 
			VkBool32 depthClampEnable; 
			VkBool32 rasterizerDiscardEnable; 
			VkPolygonMode polygonMode; 
			VkCullModeFlags cullMode; 
			VkFrontFace frontFace; 
			VkBool32 depthBiasEnable; 
			float depthBiasConstantFactor; 
			float depthBiasClamp; 
			float depthBiasSlopeFactor; 
			float lineWidth; 
		} 
		alias VkPipelineMultisampleStateCreateFlags = VkFlags; 
		alias VkSampleMask = uint32_t; 
		struct VkPipelineMultisampleStateCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.PIPELINE_MULTISAMPLE_STATE_CREATE_INFO; 
			const(void)* pNext; 
			VkPipelineMultisampleStateCreateFlags flags; 
			VkSampleCountFlagBits rasterizationSamples; 
			VkBool32 sampleShadingEnable; 
			float minSampleShading; 
			const(VkSampleMask)* pSampleMask; 
			VkBool32 alphaToCoverageEnable; 
			VkBool32 alphaToOneEnable; 
		} 
		alias VkPipelineDepthStencilStateCreateFlags = VkFlags; 
		enum VkCompareOp
		{
			VK_COMPARE_OP_NEVER = 0,
			VK_COMPARE_OP_LESS = 1,
			VK_COMPARE_OP_EQUAL = 2,
			VK_COMPARE_OP_LESS_OR_EQUAL = 3,
			VK_COMPARE_OP_GREATER = 4,
			VK_COMPARE_OP_NOT_EQUAL = 5,
			VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
			VK_COMPARE_OP_ALWAYS = 7,
		} 
		enum VkStencilOp
		{
			VK_STENCIL_OP_KEEP = 0,
			VK_STENCIL_OP_ZERO = 1,
			VK_STENCIL_OP_REPLACE = 2,
			VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
			VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
			VK_STENCIL_OP_INVERT = 5,
			VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
			VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
		} 
		struct VkStencilOpState
		{
			VkStencilOp failOp; 
			VkStencilOp passOp; 
			VkStencilOp depthFailOp; 
			VkCompareOp compareOp; 
			uint32_t compareMask; 
			uint32_t writeMask; 
			uint32_t reference; 
		} 
		struct VkPipelineDepthStencilStateCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO; 
			const(void)* pNext; 
			VkPipelineDepthStencilStateCreateFlags flags; 
			VkBool32 depthTestEnable; 
			VkBool32 depthWriteEnable; 
			VkCompareOp depthCompareOp; 
			VkBool32 depthBoundsTestEnable; 
			VkBool32 stencilTestEnable; 
			VkStencilOpState front; 
			VkStencilOpState back; 
			float minDepthBounds; 
			float maxDepthBounds; 
		} 
		alias VkPipelineColorBlendStateCreateFlags = VkFlags; 
		
		alias VkLogicOp = VK_LOGIC_OP_; 
		enum VK_LOGIC_OP_
		{
			CLEAR = 0,
			AND = 1,
			AND_REVERSE = 2,
			COPY = 3,
			AND_INVERTED = 4,
			NO_OP = 5,
			XOR = 6,
			OR = 7,
			NOR = 8,
			EQUIVALENT = 9,
			INVERT = 10,
			OR_REVERSE = 11,
			COPY_INVERTED = 12,
			OR_INVERTED = 13,
			NAND = 14,
			SET = 15,
		} 
		
		alias VkBlendFactor = VK_BLEND_FACTOR_; 
		enum VK_BLEND_FACTOR_
		{
			ZERO = 0,
			ONE = 1,
			SRC_COLOR = 2,
			ONE_MINUS_SRC_COLOR = 3,
			DST_COLOR = 4,
			ONE_MINUS_DST_COLOR = 5,
			SRC_ALPHA = 6,
			ONE_MINUS_SRC_ALPHA = 7,
			DST_ALPHA = 8,
			ONE_MINUS_DST_ALPHA = 9,
			CONSTANT_COLOR = 10,
			ONE_MINUS_CONSTANT_COLOR = 11,
			CONSTANT_ALPHA = 12,
			ONE_MINUS_CONSTANT_ALPHA = 13,
			SRC_ALPHA_SATURATE = 14,
			SRC1_COLOR = 15,
			ONE_MINUS_SRC1_COLOR = 16,
			SRC1_ALPHA = 17,
			ONE_MINUS_SRC1_ALPHA = 18,
		} 
		
		alias VkBlendOp = VK_BLEND_OP_; 
		enum VK_BLEND_OP_
		{
			ADD = 0,
			SUBTRACT = 1,
			REVERSE_SUBTRACT = 2,
			MIN = 3,
			MAX = 4,
		} 
		
		alias VkColorComponentFlagBits = VK_COLOR_COMPONENT_; 
		enum VK_COLOR_COMPONENT_
		{
			R_BIT = 0x00000001,
			G_BIT = 0x00000002,
			B_BIT = 0x00000004,
			A_BIT = 0x00000008,
		} 
		alias VkColorComponentFlags = VkBitFlags!VkColorComponentFlagBits; 
		
		struct VkPipelineColorBlendAttachmentState
		{
			VkBool32 blendEnable; 
			VkBlendFactor srcColorBlendFactor; 
			VkBlendFactor dstColorBlendFactor; 
			VkBlendOp colorBlendOp; 
			VkBlendFactor srcAlphaBlendFactor; 
			VkBlendFactor dstAlphaBlendFactor; 
			VkBlendOp alphaBlendOp; 
			VkColorComponentFlags colorWriteMask; 
		} 
		
		struct VkPipelineColorBlendStateCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.PIPELINE_COLOR_BLEND_STATE_CREATE_INFO; 
			const(void)* pNext; 
			VkPipelineColorBlendStateCreateFlags flags; 
			VkBool32 logicOpEnable; 
			VkLogicOp logicOp; 
			uint32_t attachmentCount; 
			const(VkPipelineColorBlendAttachmentState)* pAttachments; 
			float[4] blendConstants; 
		} 
		alias VkPipelineDynamicStateCreateFlags = VkFlags; 
		enum VkDynamicState
		{
			VK_DYNAMIC_STATE_VIEWPORT = 0,
			VK_DYNAMIC_STATE_SCISSOR = 1,
			VK_DYNAMIC_STATE_LINE_WIDTH = 2,
			VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
			VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
			VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
			VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
			VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
			VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
		} 
		struct VkPipelineDynamicStateCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.PIPELINE_DYNAMIC_STATE_CREATE_INFO; 
			const(void)* pNext; 
			VkPipelineDynamicStateCreateFlags flags; 
			uint32_t dynamicStateCount; 
			const(VkDynamicState)* pDynamicStates; 
		} 
		
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkPipelineLayout}); 
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkRenderPass}); 
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkPipeline}); 
		
		struct VkGraphicsPipelineCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.GRAPHICS_PIPELINE_CREATE_INFO; 
			const(void)* pNext; 
			VkPipelineCreateFlags flags; 
			uint32_t stageCount; 
			const(VkPipelineShaderStageCreateInfo)* pStages; 
			const(VkPipelineVertexInputStateCreateInfo)* pVertexInputState; 
			const(VkPipelineInputAssemblyStateCreateInfo)* pInputAssemblyState; 
			const(VkPipelineTessellationStateCreateInfo)* pTessellationState; 
			const(VkPipelineViewportStateCreateInfo)* pViewportState; 
			const(VkPipelineRasterizationStateCreateInfo)* pRasterizationState; 
			const(VkPipelineMultisampleStateCreateInfo)* pMultisampleState; 
			const(VkPipelineDepthStencilStateCreateInfo)* pDepthStencilState; 
			const(VkPipelineColorBlendStateCreateInfo)* pColorBlendState; 
			const(VkPipelineDynamicStateCreateInfo)* pDynamicState; 
			VkPipelineLayout layout; 
			VkRenderPass renderPass; 
			uint32_t subpass; 
			VkPipeline basePipelineHandle; 
			int32_t basePipelineIndex; 
		} 
		
		struct VkComputePipelineCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.COMPUTE_PIPELINE_CREATE_INFO; 
			const(void)* pNext; 
			VkPipelineCreateFlags flags; 
			VkPipelineShaderStageCreateInfo stage; 
			VkPipelineLayout layout; 
			VkPipeline basePipelineHandle; 
			int32_t basePipelineIndex; 
		} 
		alias VkPipelineLayoutCreateFlags = VkFlags; 
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkDescriptorSetLayout}); 
		struct VkPushConstantRange
		{
			VkShaderStageFlags stageFlags; 
			uint32_t offset; 
			uint32_t size; 
		} 
		struct VkPipelineLayoutCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.PIPELINE_LAYOUT_CREATE_INFO; 
			const(void)* pNext; 
			VkPipelineLayoutCreateFlags flags; 
			uint32_t setLayoutCount; 
			const(VkDescriptorSetLayout)* pSetLayouts; 
			uint32_t pushConstantRangeCount; 
			const(VkPushConstantRange)* pPushConstantRanges; 
		} 
		alias VkSamplerCreateFlags = VkFlags; 
		enum VkFilter
		{
			VK_FILTER_NEAREST = 0,
			VK_FILTER_LINEAR = 1,
			VK_FILTER_CUBIC_IMG = 1000015000,
		} 
		enum VkSamplerMipmapMode
		{
			VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
			VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
		} 
		enum VkSamplerAddressMode
		{
			VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
			VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
			VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
			VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
			VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
		} 
		enum VkBorderColor
		{
			VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
			VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
			VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
			VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
			VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
			VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
		} 
		struct VkSamplerCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.SAMPLER_CREATE_INFO; 
			const(void)* pNext; 
			VkSamplerCreateFlags flags; 
			VkFilter magFilter; 
			VkFilter minFilter; 
			VkSamplerMipmapMode mipmapMode; 
			VkSamplerAddressMode addressModeU; 
			VkSamplerAddressMode addressModeV; 
			VkSamplerAddressMode addressModeW; 
			float mipLodBias; 
			VkBool32 anisotropyEnable; 
			float maxAnisotropy; 
			VkBool32 compareEnable; 
			VkCompareOp compareOp; 
			float minLod; 
			float maxLod; 
			VkBorderColor borderColor; 
			VkBool32 unnormalizedCoordinates; 
		} 
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkSampler}); 
		alias VkDescriptorSetLayoutCreateFlags = VkFlags; 
		alias VkDescriptorType = VK_DESCRIPTOR_TYPE_; 
		enum VK_DESCRIPTOR_TYPE_
		{
			SAMPLER = 0,
			COMBINED_IMAGE_SAMPLER = 1,
			SAMPLED_IMAGE = 2,
			STORAGE_IMAGE = 3,
			UNIFORM_TEXEL_BUFFER = 4,
			STORAGE_TEXEL_BUFFER = 5,
			UNIFORM_BUFFER = 6,
			STORAGE_BUFFER = 7,
			UNIFORM_BUFFER_DYNAMIC = 8,
			STORAGE_BUFFER_DYNAMIC = 9,
			INPUT_ATTACHMENT = 10,
		} 
		
		struct VkDescriptorSetLayoutBinding
		{
			uint32_t binding; 
			VkDescriptorType descriptorType; 
			uint32_t descriptorCount; 
			VkShaderStageFlags stageFlags; 
			const(VkSampler)* pImmutableSamplers; 
		} 
		
		struct VkDescriptorSetLayoutCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.DESCRIPTOR_SET_LAYOUT_CREATE_INFO; 
			const(void)* pNext; 
			VkDescriptorSetLayoutCreateFlags flags; 
			uint32_t bindingCount; 
			const(VkDescriptorSetLayoutBinding)* pBindings; 
		} 
		
		alias VkDescriptorPoolCreateFlagBits = VK_DESCRIPTOR_POOL_CREATE_; 
		enum VK_DESCRIPTOR_POOL_CREATE_
		{FREE_DESCRIPTOR_SET_BIT = 0x00000001, } 
		alias VkDescriptorPoolCreateFlags = VkBitFlags!VkDescriptorPoolCreateFlagBits; 
		
		struct VkDescriptorPoolSize
		{
			VkDescriptorType type; 
			uint32_t descriptorCount; 
		} 
		
		struct VkDescriptorPoolCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.DESCRIPTOR_POOL_CREATE_INFO; 
			const(void)* pNext; 
			VkDescriptorPoolCreateFlags flags; 
			uint32_t maxSets; 
			uint32_t poolSizeCount; 
			const(VkDescriptorPoolSize)* pPoolSizes; 
		} 
		
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkDescriptorPool}); 
		
		alias VkDescriptorPoolResetFlags = VkFlags; 
		
		struct VkDescriptorSetAllocateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.DESCRIPTOR_SET_ALLOCATE_INFO; 
			const(void)* pNext; 
			VkDescriptorPool descriptorPool; 
			uint32_t descriptorSetCount; 
			const(VkDescriptorSetLayout)* pSetLayouts; 
		} 
		
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkDescriptorSet}); 
		struct VkDescriptorImageInfo
		{
			VkSampler sampler; 
			VkImageView imageView; 
			VkImageLayout imageLayout; 
		} 
		
		struct VkDescriptorBufferInfo
		{
			VkBuffer buffer; 
			VkDeviceSize offset; 
			VkDeviceSize range; 
		} 
		
		struct VkWriteDescriptorSet
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.WRITE_DESCRIPTOR_SET; 
			const(void)* pNext; 
			VkDescriptorSet dstSet; 
			uint32_t dstBinding; 
			uint32_t dstArrayElement; 
			uint32_t descriptorCount; 
			VkDescriptorType descriptorType; 
			const(VkDescriptorImageInfo)* pImageInfo; 
			const(VkDescriptorBufferInfo)* pBufferInfo; 
			const(VkBufferView)* pTexelBufferView; 
		} 
		
		struct VkCopyDescriptorSet
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.COPY_DESCRIPTOR_SET; 
			const(void)* pNext; 
			VkDescriptorSet srcSet; 
			uint32_t srcBinding; 
			uint32_t srcArrayElement; 
			VkDescriptorSet dstSet; 
			uint32_t dstBinding; 
			uint32_t dstArrayElement; 
			uint32_t descriptorCount; 
		} 
		
		alias VkFramebufferCreateFlags = VkFlags; 
		struct VkFramebufferCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.FRAMEBUFFER_CREATE_INFO; 
			const(void)* pNext; 
			VkFramebufferCreateFlags flags; 
			VkRenderPass renderPass; 
			uint32_t attachmentCount; 
			const(VkImageView)* pAttachments; 
			uint32_t width; 
			uint32_t height; 
			uint32_t layers; 
		} 
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkFramebuffer}); 
		alias VkRenderPassCreateFlags = VkFlags; 
		enum VkAttachmentDescriptionFlagBits
		{ VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001, } 
		alias VkAttachmentDescriptionFlags = VkFlags; 
		
		alias VkAttachmentLoadOp = VK_ATTACHMENT_LOAD_OP_; 
		enum VK_ATTACHMENT_LOAD_OP_
		{
			LOAD = 0,
			CLEAR = 1,
			DONT_CARE = 2,
		} 
		
		alias VkAttachmentStoreOp = VK_ATTACHMENT_STORE_OP_; 
		enum VK_ATTACHMENT_STORE_OP_
		{
			STORE = 0,
			DONT_CARE = 1,
		} 
		
		struct VkAttachmentDescription
		{
			VkAttachmentDescriptionFlags flags; 
			VkFormat format; 
			VkSampleCountFlagBits samples; 
			VkAttachmentLoadOp loadOp; 
			VkAttachmentStoreOp storeOp; 
			VkAttachmentLoadOp stencilLoadOp; 
			VkAttachmentStoreOp stencilStoreOp; 
			VkImageLayout initialLayout; 
			VkImageLayout finalLayout; 
		} 
		alias VkSubpassDescriptionFlags = VkFlags; 
		
		alias VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_; 
		enum VK_PIPELINE_BIND_POINT_
		{
			GRAPHICS = 0,
			COMPUTE = 1,
		} 
		
		struct VkAttachmentReference
		{
			uint32_t attachment; 
			VkImageLayout layout; 
		} 
		
		struct VkSubpassDescription
		{
			VkSubpassDescriptionFlags flags; 
			VkPipelineBindPoint pipelineBindPoint; 
			uint32_t inputAttachmentCount; 
			const(VkAttachmentReference)* pInputAttachments; 
			uint32_t colorAttachmentCount; 
			const(VkAttachmentReference)* pColorAttachments; 
			const(VkAttachmentReference)* pResolveAttachments; 
			const(VkAttachmentReference)* pDepthStencilAttachment; 
			uint32_t preserveAttachmentCount; 
			const(uint32_t)* pPreserveAttachments; 
		} 
		
		alias VkAccessFlagBits = VK_ACCESS_; 
		enum VK_ACCESS_
		{
			INDIRECT_COMMAND_READ_BIT 	= 0x00000001,
			INDEX_READ_BIT 	= 0x00000002,
			VERTEX_ATTRIBUTE_READ_BIT 	= 0x00000004,
			UNIFORM_READ_BIT 	= 0x00000008,
			INPUT_ATTACHMENT_READ_BIT 	= 0x00000010,
			SHADER_READ_BIT 	= 0x00000020,
			SHADER_WRITE_BIT 	= 0x00000040,
			COLOR_ATTACHMENT_READ_BIT 	= 0x00000080,
			COLOR_ATTACHMENT_WRITE_BIT 	= 0x00000100,
			DEPTH_STENCIL_ATTACHMENT_READ_BIT 	= 0x00000200,
			DEPTH_STENCIL_ATTACHMENT_WRITE_BIT 	= 0x00000400,
			TRANSFER_READ_BIT 	= 0x00000800,
			TRANSFER_WRITE_BIT 	= 0x00001000,
			HOST_READ_BIT 	= 0x00002000,
			HOST_WRITE_BIT 	= 0x00004000,
			MEMORY_READ_BIT 	= 0x00008000,
			MEMORY_WRITE_BIT 	= 0x00010000,
		} 
		alias VkAccessFlags = VkBitFlags!VkAccessFlagBits; 
		
		alias VkDependencyFlagBits = VK_DEPENDENCY_; 
		enum VK_DEPENDENCY_
		{BY_REGION_BIT = 0x00000001, } 
		alias VkDependencyFlags = VkBitFlags!VkDependencyFlagBits; 
		
		struct VkSubpassDependency
		{
			uint32_t srcSubpass; 
			uint32_t dstSubpass; 
			VkPipelineStageFlags srcStageMask; 
			VkPipelineStageFlags dstStageMask; 
			VkAccessFlags srcAccessMask; 
			VkAccessFlags dstAccessMask; 
			VkDependencyFlags dependencyFlags; 
		} 
		struct VkRenderPassCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.RENDER_PASS_CREATE_INFO; 
			const(void)* pNext; 
			VkRenderPassCreateFlags flags; 
			uint32_t attachmentCount; 
			const(VkAttachmentDescription)* pAttachments; 
			uint32_t subpassCount; 
			const(VkSubpassDescription)* pSubpasses; 
			uint32_t dependencyCount; 
			const(VkSubpassDependency)* pDependencies; 
		} 
		enum VkCommandPoolCreateFlagBits
		{
			VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x00000001,
			VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002,
		} 
		alias VkCommandPoolCreateFlags = VkFlags; 
		struct VkCommandPoolCreateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.COMMAND_POOL_CREATE_INFO; 
			const(void)* pNext; 
			VkCommandPoolCreateFlags flags; 
			uint32_t queueFamilyIndex; 
		} 
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkCommandPool}); 
		enum VkCommandPoolResetFlagBits
		{ VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001, } 
		alias VkCommandPoolResetFlags = VkFlags; 
		
		alias VkCommandBufferLevel = VK_COMMAND_BUFFER_LEVEL_; 
		enum VK_COMMAND_BUFFER_LEVEL_
		{
			PRIMARY = 0,
			SECONDARY = 1,
		} 
		
		struct VkCommandBufferAllocateInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.COMMAND_BUFFER_ALLOCATE_INFO; 
			const(void)* pNext; 
			VkCommandPool commandPool; 
			VkCommandBufferLevel level; 
			uint32_t commandBufferCount; 
		} 
		
		alias VkCommandBufferUsageFlagBits = VK_COMMAND_BUFFER_USAGE_; 
		enum VK_COMMAND_BUFFER_USAGE_
		{
			ONE_TIME_SUBMIT_BIT = 0x00000001,
			RENDER_PASS_CONTINUE_BIT = 0x00000002,
			SIMULTANEOUS_USE_BIT = 0x00000004,
		} 
		alias VkCommandBufferUsageFlags = VkBitFlags!VkCommandBufferUsageFlagBits; 
		
		enum VkQueryControlFlagBits
		{ VK_QUERY_CONTROL_PRECISE_BIT = 0x00000001, } 
		alias VkQueryControlFlags = VkFlags; 
		
		struct VkCommandBufferInheritanceInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.COMMAND_BUFFER_INHERITANCE_INFO; 
			const(void)* pNext; 
			VkRenderPass renderPass; 
			uint32_t subpass; 
			VkFramebuffer framebuffer; 
			VkBool32 occlusionQueryEnable; 
			VkQueryControlFlags queryFlags; 
			VkQueryPipelineStatisticFlags pipelineStatistics; 
		} 
		
		struct VkCommandBufferBeginInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.COMMAND_BUFFER_BEGIN_INFO; 
			const(void)* pNext; 
			VkCommandBufferUsageFlags flags; 
			const(VkCommandBufferInheritanceInfo)* pInheritanceInfo; 
		} 
		
		enum VkCommandBufferResetFlagBits
		{ VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001, } 
		alias VkCommandBufferResetFlags = VkFlags; 
		enum VkStencilFaceFlagBits
		{
			VK_STENCIL_FACE_FRONT_BIT = 0x00000001,
			VK_STENCIL_FACE_BACK_BIT = 0x00000002,
			VK_STENCIL_FRONT_AND_BACK = 0x00000003,
		} 
		alias VkStencilFaceFlags = VkFlags; 
		
		alias VkIndexType = VK_INDEX_TYPE_; 
		enum VK_INDEX_TYPE_
		{
			UINT16 = 0,
			UINT32 = 1,
		} 
		
		struct VkBufferCopy
		{
			VkDeviceSize srcOffset; 
			VkDeviceSize dstOffset; 
			VkDeviceSize size; 
		} 
		struct VkImageSubresourceLayers
		{
			VkImageAspectFlags aspectMask; 
			uint32_t mipLevel; 
			uint32_t baseArrayLayer; 
			uint32_t layerCount; 
		} 
		struct VkImageCopy
		{
			VkImageSubresourceLayers srcSubresource; 
			VkOffset3D srcOffset; 
			VkImageSubresourceLayers dstSubresource; 
			VkOffset3D dstOffset; 
			VkExtent3D extent; 
		} 
		struct VkImageBlit
		{
			VkImageSubresourceLayers srcSubresource; 
			VkOffset3D[2] srcOffsets; 
			VkImageSubresourceLayers dstSubresource; 
			VkOffset3D[2] dstOffsets; 
		} 
		struct VkBufferImageCopy
		{
			VkDeviceSize bufferOffset; 
			uint32_t bufferRowLength; 
			uint32_t bufferImageHeight; 
			VkImageSubresourceLayers imageSubresource; 
			VkOffset3D imageOffset; 
			VkExtent3D imageExtent; 
		} 
		union VkClearColorValue
		{
			float[4] float32; 
			int32_t[4] int32; 
			uint32_t[4] uint32; 
		} 
		struct VkClearDepthStencilValue
		{
			float depth; 
			uint32_t stencil; 
		} 
		union VkClearValue
		{
			VkClearColorValue color; 
			VkClearDepthStencilValue depthStencil; 
		} 
		struct VkClearAttachment
		{
			VkImageAspectFlags aspectMask; 
			uint32_t colorAttachment; 
			VkClearValue clearValue; 
		} 
		struct VkClearRect
		{
			VkRect2D rect; 
			uint32_t baseArrayLayer; 
			uint32_t layerCount; 
		} 
		struct VkImageResolve
		{
			VkImageSubresourceLayers srcSubresource; 
			VkOffset3D srcOffset; 
			VkImageSubresourceLayers dstSubresource; 
			VkOffset3D dstOffset; 
			VkExtent3D extent; 
		} 
		struct VkMemoryBarrier
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.MEMORY_BARRIER; 
			const(void)* pNext; 
			VkAccessFlags srcAccessMask; 
			VkAccessFlags dstAccessMask; 
		} 
		struct VkBufferMemoryBarrier
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.BUFFER_MEMORY_BARRIER; 
			const(void)* pNext; 
			VkAccessFlags srcAccessMask; 
			VkAccessFlags dstAccessMask; 
			uint32_t srcQueueFamilyIndex; 
			uint32_t dstQueueFamilyIndex; 
			VkBuffer buffer; 
			VkDeviceSize offset; 
			VkDeviceSize size; 
		} 
		
		struct VkImageMemoryBarrier
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.IMAGE_MEMORY_BARRIER; 
			const(void)* pNext; 
			VkAccessFlags srcAccessMask; 
			VkAccessFlags dstAccessMask; 
			VkImageLayout oldLayout; 
			VkImageLayout newLayout; 
			uint32_t srcQueueFamilyIndex; 
			uint32_t dstQueueFamilyIndex; 
			VkImage image; 
			VkImageSubresourceRange subresourceRange; 
		} 
		
		struct VkRenderPassBeginInfo
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.RENDER_PASS_BEGIN_INFO; 
			const(void)* pNext; 
			VkRenderPass renderPass; 
			VkFramebuffer framebuffer; 
			VkRect2D renderArea; 
			uint32_t clearValueCount; 
			const(VkClearValue)* pClearValues; 
		} 
		
		alias VkSubpassContents = VK_SUBPASS_CONTENTS_; 
		enum VK_SUBPASS_CONTENTS_
		{
			INLINE = 0,
			SECONDARY_COMMAND_BUFFERS = 1,
		} 
		
		struct VkDispatchIndirectCommand
		{
			uint32_t x; 
			uint32_t y; 
			uint32_t z; 
		} 
		struct VkDrawIndexedIndirectCommand
		{
			uint32_t indexCount; 
			uint32_t instanceCount; 
			uint32_t firstIndex; 
			int32_t vertexOffset; 
			uint32_t firstInstance; 
		} struct VkDrawIndirectCommand
		{
			uint32_t vertexCount; 
			uint32_t instanceCount; 
			uint32_t firstVertex; 
			uint32_t firstInstance; 
		} 
	}
}
version(/+$DIDE_REGION+/all)
{
	version(DVulkan_VK_KHR_surface)
	{
		enum VK_KHR_SURFACE_SPEC_VERSION = 25; 
		enum VK_KHR_SURFACE_EXTENSION_NAME = "VK_KHR_surface"; 
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkSurfaceKHR}); 
		
		alias VkSurfaceTransformFlagBitsKHR = VK_SURFACE_TRANSFORM_; 
		enum VK_SURFACE_TRANSFORM_
		{
			IDENTITY_BIT_KHR = 0x00000001,
			ROTATE_90_BIT_KHR = 0x00000002,
			ROTATE_180_BIT_KHR = 0x00000004,
			ROTATE_270_BIT_KHR = 0x00000008,
			HORIZONTAL_MIRROR_BIT_KHR = 0x00000010,
			HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0x00000020,
			HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x00000040,
			HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x00000080,
			INHERIT_BIT_KHR = 0x00000100,
		} 
		alias VkSurfaceTransformFlagsKHR = VkBitFlags!VK_SURFACE_TRANSFORM_; 
		
		alias VkCompositeAlphaFlagBitsKHR = VK_COMPOSITE_ALPHA_; 
		enum VK_COMPOSITE_ALPHA_
		{
			OPAQUE_BIT_KHR = 0x00000001,
			PRE_MULTIPLIED_BIT_KHR = 0x00000002,
			POST_MULTIPLIED_BIT_KHR = 0x00000004,
			INHERIT_BIT_KHR = 0x00000008,
		} 
		alias VkCompositeAlphaFlagsKHR = VkBitFlags!VkCompositeAlphaFlagBitsKHR; 
		
		struct VkSurfaceCapabilitiesKHR
		{
			uint32_t minImageCount; 
			uint32_t maxImageCount; 
			VkExtent2D currentExtent; 
			VkExtent2D minImageExtent; 
			VkExtent2D maxImageExtent; 
			uint32_t maxImageArrayLayers; 
			VkSurfaceTransformFlagsKHR supportedTransforms; 
			VkSurfaceTransformFlagBitsKHR currentTransform; 
			VkCompositeAlphaFlagsKHR supportedCompositeAlpha; 
			VkImageUsageFlags supportedUsageFlags; 
		} 
		
		alias VkColorSpaceKHR = VK_COLOR_SPACE_; 
		enum VK_COLOR_SPACE_
		{SRGB_NONLINEAR_KHR = 0} 
		
		struct VkSurfaceFormatKHR
		{
			VkFormat format; 
			VkColorSpaceKHR colorSpace; 
		} 
		
		alias VkPresentModeKHR = VK_PRESENT_MODE_; 
		enum VK_PRESENT_MODE_
		{
			IMMEDIATE_KHR = 0,
			MAILBOX_KHR = 1,
			FIFO_KHR = 2,
			FIFO_RELAXED_KHR = 3,
		} 
	}
	
	//het
	version(DVulkan_VK_KHR_win32_surface)
	{
		alias VkWin32SurfaceCreateFlagsKHR = VkFlags; 
		
		import core.sys.windows.windef : HINSTANCE, HWND; 
		
		struct VkWin32SurfaceCreateInfoKHR
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.WIN32_SURFACE_CREATE_INFO_KHR; 
			const void* pNext; 
			VkWin32SurfaceCreateFlagsKHR flags; 
			HINSTANCE hinstance; 
			HWND hwnd; 
		} 
	}
	
	version(DVulkan_VK_KHR_swapchain)
	{
		enum VK_KHR_SWAPCHAIN_SPEC_VERSION = 68; 
		enum VK_KHR_SWAPCHAIN_EXTENSION_NAME = "VK_KHR_swapchain"; 
		alias VkSwapchainCreateFlagsKHR = VkFlags; 
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkSwapchainKHR}); 
		struct VkSwapchainCreateInfoKHR
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.SWAPCHAIN_CREATE_INFO_KHR; 
			const(void)* pNext; 
			VkSwapchainCreateFlagsKHR flags; 
			VkSurfaceKHR surface; 
			uint32_t minImageCount; 
			VkFormat imageFormat; 
			VkColorSpaceKHR imageColorSpace; 
			VkExtent2D imageExtent; 
			uint32_t imageArrayLayers; 
			VkImageUsageFlags imageUsage; 
			VkSharingMode imageSharingMode; 
			uint32_t queueFamilyIndexCount; 
			const(uint32_t)* pQueueFamilyIndices; 
			VkSurfaceTransformFlagBitsKHR preTransform; 
			VkCompositeAlphaFlagBitsKHR compositeAlpha; 
			VkPresentModeKHR presentMode; 
			VkBool32 clipped; 
			VkSwapchainKHR oldSwapchain; 
		} 
		struct VkPresentInfoKHR
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.PRESENT_INFO_KHR; 
			const(void)* pNext; 
			uint32_t waitSemaphoreCount; 
			const(VkSemaphore)* pWaitSemaphores; 
			uint32_t swapchainCount; 
			const(VkSwapchainKHR)* pSwapchains; 
			const(uint32_t)* pImageIndices; 
			VkResult* pResults; 
		} 
	}
	version(DVulkan_VK_KHR_display)
	{
		enum VkDisplayPlaneAlphaFlagBitsKHR
		{
			VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
			VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 0x00000002,
			VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 0x00000004,
			VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x00000008,
		} 
		alias VkDisplayPlaneAlphaFlagsKHR = VkFlags; 
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkDisplayKHR}); 
		struct VkDisplayPropertiesKHR
		{
			VkDisplayKHR display; 
			const(char)* displayName; 
			VkExtent2D physicalDimensions; 
			VkExtent2D physicalResolution; 
			VkSurfaceTransformFlagsKHR supportedTransforms; 
			VkBool32 planeReorderPossible; 
			VkBool32 persistentContent; 
		} 
		struct VkDisplayModeParametersKHR
		{
			VkExtent2D visibleRegion; 
			uint32_t refreshRate; 
		} 
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkDisplayModeKHR}); 
		struct VkDisplayModePropertiesKHR
		{
			VkDisplayModeKHR displayMode; 
			VkDisplayModeParametersKHR parameters; 
		} 
		alias VkDisplayModeCreateFlagsKHR = VkFlags; 
		struct VkDisplayModeCreateInfoKHR
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.DISPLAY_MODE_CREATE_INFO_KHR; 
			const(void)* pNext; 
			VkDisplayModeCreateFlagsKHR flags; 
			VkDisplayModeParametersKHR parameters; 
		} 
		struct VkDisplayPlaneCapabilitiesKHR
		{
			VkDisplayPlaneAlphaFlagsKHR supportedAlpha; 
			VkOffset2D minSrcPosition; 
			VkOffset2D maxSrcPosition; 
			VkExtent2D minSrcExtent; 
			VkExtent2D maxSrcExtent; 
			VkOffset2D minDstPosition; 
			VkOffset2D maxDstPosition; 
			VkExtent2D minDstExtent; 
			VkExtent2D maxDstExtent; 
		} 
		struct VkDisplayPlanePropertiesKHR
		{
			VkDisplayKHR currentDisplay; 
			uint32_t currentStackIndex; 
		} 
		alias VkDisplaySurfaceCreateFlagsKHR = VkFlags; 
		struct VkDisplaySurfaceCreateInfoKHR
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.DISPLAY_SURFACE_CREATE_INFO_KHR; 
			const(void)* pNext; 
			VkDisplaySurfaceCreateFlagsKHR flags; 
			VkDisplayModeKHR displayMode; 
			uint32_t planeIndex; 
			uint32_t planeStackIndex; 
			VkSurfaceTransformFlagBitsKHR transform; 
			float globalAlpha; 
			VkDisplayPlaneAlphaFlagBitsKHR alphaMode; 
			VkExtent2D imageExtent; 
		} 
		enum VK_KHR_DISPLAY_SPEC_VERSION = 21; 
		enum VK_KHR_DISPLAY_EXTENSION_NAME = "VK_KHR_display"; 
	}
	version(DVulkan_VK_KHR_display_swapchain)
	{
		struct VkDisplayPresentInfoKHR
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.DISPLAY_PRESENT_INFO_KHR; 
			const(void)* pNext; 
			VkRect2D srcRect; 
			VkRect2D dstRect; 
			VkBool32 persistent; 
		} 
		enum VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION = 9; 
		enum VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME = "VK_KHR_display_swapchain"; 
	}
	version(DVulkan_VK_KHR_sampler_mirror_clamp_to_edge)
	{
		enum VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION = 1; 
		enum VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME = "VK_KHR_sampler_mirror_clamp_to_edge"; 
	}
	version(DVulkan_VK_ANDROID_native_buffer)
	{
		enum VK_ANDROID_NATIVE_BUFFER_SPEC_VERSION = 4; 
		enum VK_ANDROID_NATIVE_BUFFER_NUMBER = 11; 
		enum VK_ANDROID_NATIVE_BUFFER_NAME = "VK_ANDROID_native_buffer"; 
	}
	version(DVulkan_VK_EXT_debug_report)
	{
		enum VkDebugReportObjectTypeEXT
		{
			VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
			VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
			VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
			VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
			VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
			VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
			VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
			VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
			VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
			VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
			VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
			VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
			VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
			VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
			VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
			VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
			VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
			VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
			VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
			VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
			VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
			VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
			VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
			VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
			VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
			VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
			VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
			VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
			VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = 28,
		} 
		enum VkDebugReportErrorEXT
		{
			VK_DEBUG_REPORT_ERROR_NONE_EXT = 0,
			VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT = 1,
		} 
		enum VK_EXT_DEBUG_REPORT_SPEC_VERSION = 2; 
		enum VK_EXT_DEBUG_REPORT_EXTENSION_NAME = "VK_EXT_debug_report"; 
		enum VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_.DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT; 
		enum VkDebugReportFlagBitsEXT
		{
			VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 0x00000001,
			VK_DEBUG_REPORT_WARNING_BIT_EXT = 0x00000002,
			VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x00000004,
			VK_DEBUG_REPORT_ERROR_BIT_EXT = 0x00000008,
			VK_DEBUG_REPORT_DEBUG_BIT_EXT = 0x00000010,
		} 
		alias VkDebugReportFlagsEXT = VkFlags; 
		alias PFN_vkDebugReportCallbackEXT = VkBool32 function(
			VkDebugReportFlagsEXT	                 flags,
			VkDebugReportObjectTypeEXT	                 objectType,
			uint64_t	                 object,
			size_t	                 location,
			int32_t	                 messageCode,
			const char*																	 pLayerPrefix,
			const char*																	 pMessage,
			void*	                 pUserData
		); 
		struct VkDebugReportCallbackCreateInfoEXT
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT; 
			const(void)* pNext; 
			VkDebugReportFlagsEXT flags; 
			PFN_vkDebugReportCallbackEXT pfnCallback; 
			void* pUserData; 
		} 
		mixin(VK_DEFINE_NON_DISPATCHABLE_HANDLE!q{VkDebugReportCallbackEXT}); 
	}
	version(DVulkan_VK_NV_glsl_shader)
	{
		enum VK_NV_GLSL_SHADER_SPEC_VERSION = 1; 
		enum VK_NV_GLSL_SHADER_EXTENSION_NAME = "VK_NV_glsl_shader"; 
	}
	version(DVulkan_VK_NV_extension_1)
	{
		enum VK_NV_EXTENSION_1_SPEC_VERSION = 0; 
		enum VK_NV_EXTENSION_1_EXTENSION_NAME = "VK_NV_extension_1"; 
	}
	version(DVulkan_VK_IMG_filter_cubic)
	{
		enum VK_IMG_FILTER_CUBIC_SPEC_VERSION = 1; 
		enum VK_IMG_FILTER_CUBIC_EXTENSION_NAME = "VK_IMG_filter_cubic"; 
	}
	version(DVulkan_VK_AMD_extension_1)
	{
		enum VK_AMD_EXTENSION_1_SPEC_VERSION = 0; 
		enum VK_AMD_EXTENSION_1_EXTENSION_NAME = "VK_AMD_extension_1"; 
	}
	version(DVulkan_VK_AMD_extension_2)
	{
		enum VK_AMD_EXTENSION_2_SPEC_VERSION = 0; 
		enum VK_AMD_EXTENSION_2_EXTENSION_NAME = "VK_AMD_extension_2"; 
	}
	version(DVulkan_VK_AMD_rasterization_order)
	{
		enum VkRasterizationOrderAMD
		{
			VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
			VK_RASTERIZATION_ORDER_RELAXED_AMD = 1,
		} 
		struct VkPipelineRasterizationStateRasterizationOrderAMD
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD; 
			const(void)* pNext; 
			VkRasterizationOrderAMD rasterizationOrder; 
		} 
		enum VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION = 1; 
		enum VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME = "VK_AMD_rasterization_order"; 
	}
	version(DVulkan_VK_AMD_extension_4)
	{
		enum VK_AMD_EXTENSION_4_SPEC_VERSION = 0; 
		enum VK_AMD_EXTENSION_4_EXTENSION_NAME = "VK_AMD_extension_4"; 
	}
	version(DVulkan_VK_AMD_extension_5)
	{
		enum VK_AMD_EXTENSION_5_SPEC_VERSION = 0; 
		enum VK_AMD_EXTENSION_5_EXTENSION_NAME = "VK_AMD_extension_5"; 
	}
	version(DVulkan_VK_AMD_extension_6)
	{
		enum VK_AMD_EXTENSION_6_SPEC_VERSION = 0; 
		enum VK_AMD_EXTENSION_6_EXTENSION_NAME = "VK_AMD_extension_6"; 
	}
	version(DVulkan_VK_EXT_debug_marker)
	{
		struct VkDebugMarkerObjectNameInfoEXT
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.DEBUG_MARKER_OBJECT_NAME_INFO_EXT; 
			const(void)* pNext; 
			VkDebugReportObjectTypeEXT objectType; 
			uint64_t object; 
			const(char)* pObjectName; 
		} 
		struct VkDebugMarkerObjectTagInfoEXT
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.DEBUG_MARKER_OBJECT_TAG_INFO_EXT; 
			const(void)* pNext; 
			VkDebugReportObjectTypeEXT objectType; 
			uint64_t object; 
			uint64_t tagName; 
			size_t tagSize; 
			const(void)* pTag; 
		} 
		struct VkDebugMarkerMarkerInfoEXT
		{
			VkStructureType sType = VK_STRUCTURE_TYPE_.DEBUG_MARKER_MARKER_INFO_EXT; 
			const(void)* pNext; 
			const(char)* pMarkerName; 
			float[4] color; 
		} 
		enum VK_EXT_DEBUG_MARKER_SPEC_VERSION = 3; 
		enum VK_EXT_DEBUG_MARKER_EXTENSION_NAME = "VK_EXT_debug_marker"; 
	}
	
}extern(System) @nogc nothrow
{
	/// Struct containing function pointers to all Vulkan functions.
	struct VulkanFunctions
	{
		/// The instance that the functions were loaded from, if applicable.
		VkInstance instance; 
		/// The device that the functions were loaded from, if applicable.
		VkDevice device; 
		
		/// Loads the following functions, by calling the passed in vkGetInstanceProcAddr function:
		/// vkGetInstanceProcAddr (copies the one passed in),
		/// vkEnumerateInstanceExtensionProperties,
		/// vkEnumerateInstanceLayerProperties, and
		/// vkCreateInstance
		void loadInitializationFunctions(PFN_vkGetInstanceProcAddr getProcAddr)
		{
			vkGetInstanceProcAddr = getProcAddr; 
			vkEnumerateInstanceExtensionProperties = cast(PFN_vkEnumerateInstanceExtensionProperties) vkGetInstanceProcAddr(null, "vkEnumerateInstanceExtensionProperties"); 
			vkEnumerateInstanceLayerProperties = cast(PFN_vkEnumerateInstanceLayerProperties) vkGetInstanceProcAddr(null, "vkEnumerateInstanceLayerProperties"); 
			vkCreateInstance = cast(PFN_vkCreateInstance) vkGetInstanceProcAddr(null, "vkCreateInstance"); 
		} 
		
		/// Loads all functions from an instance (except functions loaded by loadInitializationFunctions).
		/// The functions may be used with any device created from this instance (but will have a slight dispatching overhead).
		/// Sets `instance` to the passed in instance.
		void loadInstanceFunctions(VkInstance instance)
		{
			assert(this.vkGetInstanceProcAddr, "loadInstanceFunctions called without vkGetInstanceProcAddr set"); 
			
			enum shouldLoad(string name) =
				 name.startsWith("vk") &&
				 staticIndexOf!(
				name,
								"vkGetInstanceProcAddr",
								"vkEnumerateInstanceExtensionProperties",
								"vkEnumerateInstanceLayerProperties",
								"vkCreateInstance",
			) == -1; 
			alias funcsToLoad = Filter!(shouldLoad, AllFuncs); 
			
			this.instance = instance; 
			foreach(string name; funcsToLoad)
			{
				__traits(getMember, this, name) = cast(typeof(__traits(getMember, VulkanFunctions, name)))
					vkGetInstanceProcAddr(instance, name); 
			}
		} 
		
		/// Loads functions specific for a device.
		/// This loads all Vulkan functions that take a VkDevice, VkQueue, or VkCommandBuffer as their first argument.
		/// The functions may only be used with the passed-in device, and should be free of dispatching overhead.
		/// Sets `device` to the passed-in device.
		void loadDeviceFunctions(VkDevice device)
		{
			assert(this.vkGetDeviceProcAddr, "loadInstanceFunctions called without vkGetDeviceProcAddr set"); 
			
			enum shouldLoad(string name) =
				 Parameters!(__traits(getMember, VulkanFunctions, "PFN_"~name)).length > 0 &&
				 staticIndexOf!(Parameters!(__traits(getMember, VulkanFunctions, "PFN_"~name))[0], VkDevice, VkQueue, VkCommandBuffer) != -1; 
			alias funcsToLoad = Filter!(shouldLoad, AllFuncs); 
			
			this.device = device; 
			foreach(string name; funcsToLoad)
			{
				__traits(getMember, this, name) = cast(typeof(__traits(getMember, VulkanFunctions, name)))
					vkGetDeviceProcAddr(device, name); 
			}
		} 
		
		private enum IsVKFunc(string name) = name.startsWith("vk"); 
		package alias AllFuncs = Filter!(IsVKFunc, __traits(allMembers, VulkanFunctions)); 
		
		//Todo: A candidate for table based programming:
		version(none)
		static _FUN(string name, string params)
		{ return q{alias PFN_vk$ = void function(%); PFN_vk$ vk$; }.replace("$", name).replace("%", params); } 
		
		version(DVulkan_VK_VERSION_1_0)
		{
			alias PFN_vkCreateInstance = VkResult function(const(VkInstanceCreateInfo)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkInstance* pInstance); 	
			PFN_vkCreateInstance vkCreateInstance; 
			alias PFN_vkDestroyInstance = void function(VkInstance instance,const(VkAllocationCallbacks)* pAllocator); 	
			PFN_vkDestroyInstance vkDestroyInstance; 
			alias PFN_vkEnumeratePhysicalDevices = VkResult function(VkInstance instance,uint32_t* pPhysicalDeviceCount,VkPhysicalDevice* pPhysicalDevices); 	
			PFN_vkEnumeratePhysicalDevices vkEnumeratePhysicalDevices; 
			alias PFN_vkGetPhysicalDeviceFeatures = void function(VkPhysicalDevice physicalDevice,VkPhysicalDeviceFeatures* pFeatures); 	
			PFN_vkGetPhysicalDeviceFeatures vkGetPhysicalDeviceFeatures; 
			alias PFN_vkGetPhysicalDeviceFormatProperties = void function(VkPhysicalDevice physicalDevice,VkFormat format,VkFormatProperties* pFormatProperties); 	
			PFN_vkGetPhysicalDeviceFormatProperties vkGetPhysicalDeviceFormatProperties; 
			alias PFN_vkGetPhysicalDeviceImageFormatProperties = VkResult function(VkPhysicalDevice physicalDevice,VkFormat format,VkImageType type,VkImageTiling tiling,VkImageUsageFlags usage,VkImageCreateFlags flags,VkImageFormatProperties* pImageFormatProperties); 	
			PFN_vkGetPhysicalDeviceImageFormatProperties vkGetPhysicalDeviceImageFormatProperties; 
			alias PFN_vkGetPhysicalDeviceProperties = void function(VkPhysicalDevice physicalDevice,VkPhysicalDeviceProperties* pProperties); 	
			PFN_vkGetPhysicalDeviceProperties vkGetPhysicalDeviceProperties; 
			alias PFN_vkGetPhysicalDeviceQueueFamilyProperties = void function(VkPhysicalDevice physicalDevice,uint32_t* pQueueFamilyPropertyCount,VkQueueFamilyProperties* pQueueFamilyProperties); 	
			PFN_vkGetPhysicalDeviceQueueFamilyProperties vkGetPhysicalDeviceQueueFamilyProperties; 
			alias PFN_vkGetPhysicalDeviceMemoryProperties = void function(VkPhysicalDevice physicalDevice,VkPhysicalDeviceMemoryProperties* pMemoryProperties); 	
			PFN_vkGetPhysicalDeviceMemoryProperties vkGetPhysicalDeviceMemoryProperties; 
			alias PFN_vkGetInstanceProcAddr = PFN_vkVoidFunction function(VkInstance instance,const(char)* pName); 	
			PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr; 
			alias PFN_vkGetDeviceProcAddr = PFN_vkVoidFunction function(VkDevice device,const(char)* pName); 	
			PFN_vkGetDeviceProcAddr vkGetDeviceProcAddr; 
			alias PFN_vkCreateDevice = VkResult function(VkPhysicalDevice physicalDevice,const(VkDeviceCreateInfo)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkDevice* pDevice); 	
			PFN_vkCreateDevice vkCreateDevice; 
			alias PFN_vkDestroyDevice = void function(VkDevice device,const(VkAllocationCallbacks)* pAllocator); 	
			PFN_vkDestroyDevice vkDestroyDevice; 
			alias PFN_vkEnumerateInstanceExtensionProperties = VkResult function(const(char)* pLayerName,uint32_t* pPropertyCount,VkExtensionProperties* pProperties); 
			PFN_vkEnumerateInstanceExtensionProperties vkEnumerateInstanceExtensionProperties; 
			alias PFN_vkEnumerateDeviceExtensionProperties = VkResult function(VkPhysicalDevice physicalDevice,const(char)* pLayerName,uint32_t* pPropertyCount,VkExtensionProperties* pProperties); 
			PFN_vkEnumerateDeviceExtensionProperties vkEnumerateDeviceExtensionProperties; 
			alias PFN_vkEnumerateInstanceLayerProperties = VkResult function(uint32_t* pPropertyCount,VkLayerProperties* pProperties); 
			PFN_vkEnumerateInstanceLayerProperties vkEnumerateInstanceLayerProperties; 
			alias PFN_vkEnumerateDeviceLayerProperties = VkResult function(VkPhysicalDevice physicalDevice,uint32_t* pPropertyCount,VkLayerProperties* pProperties); 
			PFN_vkEnumerateDeviceLayerProperties vkEnumerateDeviceLayerProperties; 
			alias PFN_vkGetDeviceQueue = void function(VkDevice device,uint32_t queueFamilyIndex,uint32_t queueIndex,VkQueue* pQueue); 
			PFN_vkGetDeviceQueue vkGetDeviceQueue; 
			alias PFN_vkQueueSubmit = VkResult function(VkQueue queue,uint32_t submitCount,const(VkSubmitInfo)* pSubmits,VkFence fence); 
			PFN_vkQueueSubmit vkQueueSubmit; 
			alias PFN_vkQueueWaitIdle = VkResult function(VkQueue queue); 
			PFN_vkQueueWaitIdle vkQueueWaitIdle; 
			alias PFN_vkDeviceWaitIdle = VkResult function(VkDevice device); 
			PFN_vkDeviceWaitIdle vkDeviceWaitIdle; 
			alias PFN_vkAllocateMemory = VkResult function(VkDevice device,const(VkMemoryAllocateInfo)* pAllocateInfo,const(VkAllocationCallbacks)* pAllocator,VkDeviceMemory* pMemory); 
			PFN_vkAllocateMemory vkAllocateMemory; 
			alias PFN_vkFreeMemory = void function(VkDevice device,VkDeviceMemory memory,const(VkAllocationCallbacks)* pAllocator); 
			PFN_vkFreeMemory vkFreeMemory; 
			alias PFN_vkMapMemory = VkResult function(VkDevice device,VkDeviceMemory memory,VkDeviceSize offset,VkDeviceSize size,VkMemoryMapFlags flags,void** ppData); 
			PFN_vkMapMemory vkMapMemory; 
			alias PFN_vkUnmapMemory = void function(VkDevice device,VkDeviceMemory memory); 
			PFN_vkUnmapMemory vkUnmapMemory; 
			alias PFN_vkFlushMappedMemoryRanges = VkResult function(VkDevice device,uint32_t memoryRangeCount,const(VkMappedMemoryRange)* pMemoryRanges); 
			PFN_vkFlushMappedMemoryRanges vkFlushMappedMemoryRanges; 
			alias PFN_vkInvalidateMappedMemoryRanges = VkResult function(VkDevice device,uint32_t memoryRangeCount,const(VkMappedMemoryRange)* pMemoryRanges); 
			PFN_vkInvalidateMappedMemoryRanges vkInvalidateMappedMemoryRanges; 
			alias PFN_vkGetDeviceMemoryCommitment = void function(VkDevice device,VkDeviceMemory memory,VkDeviceSize* pCommittedMemoryInBytes); 
			PFN_vkGetDeviceMemoryCommitment vkGetDeviceMemoryCommitment; 
			alias PFN_vkBindBufferMemory = VkResult function(VkDevice device,VkBuffer buffer,VkDeviceMemory memory,VkDeviceSize memoryOffset); 
			PFN_vkBindBufferMemory vkBindBufferMemory; 
			alias PFN_vkBindImageMemory = VkResult function(VkDevice device,VkImage image,VkDeviceMemory memory,VkDeviceSize memoryOffset); 
			PFN_vkBindImageMemory vkBindImageMemory; 
			alias PFN_vkGetBufferMemoryRequirements = void function(VkDevice device,VkBuffer buffer,VkMemoryRequirements* pMemoryRequirements); 
			PFN_vkGetBufferMemoryRequirements vkGetBufferMemoryRequirements; 
			alias PFN_vkGetImageMemoryRequirements = void function(VkDevice device,VkImage image,VkMemoryRequirements* pMemoryRequirements); 
			PFN_vkGetImageMemoryRequirements vkGetImageMemoryRequirements; 
			alias PFN_vkGetImageSparseMemoryRequirements = void function(VkDevice device,VkImage image,uint32_t* pSparseMemoryRequirementCount,VkSparseImageMemoryRequirements* pSparseMemoryRequirements); 
			PFN_vkGetImageSparseMemoryRequirements vkGetImageSparseMemoryRequirements; 
			alias PFN_vkGetPhysicalDeviceSparseImageFormatProperties = void function(VkPhysicalDevice physicalDevice,VkFormat format,VkImageType type,VkSampleCountFlagBits samples,VkImageUsageFlags usage,VkImageTiling tiling,uint32_t* pPropertyCount,VkSparseImageFormatProperties* pProperties); 
			PFN_vkGetPhysicalDeviceSparseImageFormatProperties vkGetPhysicalDeviceSparseImageFormatProperties; 
			alias PFN_vkQueueBindSparse = VkResult function(VkQueue queue,uint32_t bindInfoCount,const(VkBindSparseInfo)* pBindInfo,VkFence fence); 
			PFN_vkQueueBindSparse vkQueueBindSparse; 
			alias PFN_vkCreateFence = VkResult function(VkDevice device,const(VkFenceCreateInfo)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkFence* pFence); 
			PFN_vkCreateFence vkCreateFence; 
			alias PFN_vkDestroyFence = void function(VkDevice device,VkFence fence,const(VkAllocationCallbacks)* pAllocator); 
			PFN_vkDestroyFence vkDestroyFence; 
			alias PFN_vkResetFences = VkResult function(VkDevice device,uint32_t fenceCount,const(VkFence)* pFences); 
			PFN_vkResetFences vkResetFences; 
			alias PFN_vkGetFenceStatus = VkResult function(VkDevice device,VkFence fence); 
			PFN_vkGetFenceStatus vkGetFenceStatus; 
			alias PFN_vkWaitForFences = VkResult function(VkDevice device,uint32_t fenceCount,const(VkFence)* pFences,VkBool32 waitAll,uint64_t timeout); 
			PFN_vkWaitForFences vkWaitForFences; 
			alias PFN_vkCreateSemaphore = VkResult function(VkDevice device,const(VkSemaphoreCreateInfo)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkSemaphore* pSemaphore); 
			PFN_vkCreateSemaphore vkCreateSemaphore; 
			alias PFN_vkDestroySemaphore = void function(VkDevice device,VkSemaphore semaphore,const(VkAllocationCallbacks)* pAllocator); 
			PFN_vkDestroySemaphore vkDestroySemaphore; 
			alias PFN_vkCreateEvent = VkResult function(VkDevice device,const(VkEventCreateInfo)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkEvent* pEvent); 
			PFN_vkCreateEvent vkCreateEvent; 
			alias PFN_vkDestroyEvent = void function(VkDevice device,VkEvent event,const(VkAllocationCallbacks)* pAllocator); 
			PFN_vkDestroyEvent vkDestroyEvent; 
			alias PFN_vkGetEventStatus = VkResult function(VkDevice device,VkEvent event); 
			PFN_vkGetEventStatus vkGetEventStatus; 
			alias PFN_vkSetEvent = VkResult function(VkDevice device,VkEvent event); 
			PFN_vkSetEvent vkSetEvent; 
			alias PFN_vkResetEvent = VkResult function(VkDevice device,VkEvent event); 
			PFN_vkResetEvent vkResetEvent; 
			alias PFN_vkCreateQueryPool = VkResult function(VkDevice device,const(VkQueryPoolCreateInfo)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkQueryPool* pQueryPool); 
			PFN_vkCreateQueryPool vkCreateQueryPool; 
			alias PFN_vkDestroyQueryPool = void function(VkDevice device,VkQueryPool queryPool,const(VkAllocationCallbacks)* pAllocator); 
			PFN_vkDestroyQueryPool vkDestroyQueryPool; 
			alias PFN_vkGetQueryPoolResults = VkResult function(VkDevice device,VkQueryPool queryPool,uint32_t firstQuery,uint32_t queryCount,size_t dataSize,void* pData,VkDeviceSize stride,VkQueryResultFlags flags); 
			PFN_vkGetQueryPoolResults vkGetQueryPoolResults; 
			alias PFN_vkCreateBuffer = VkResult function(VkDevice device,const(VkBufferCreateInfo)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkBuffer* pBuffer); 
			PFN_vkCreateBuffer vkCreateBuffer; 
			alias PFN_vkDestroyBuffer = void function(VkDevice device,VkBuffer buffer,const(VkAllocationCallbacks)* pAllocator); 
			PFN_vkDestroyBuffer vkDestroyBuffer; 
			alias PFN_vkCreateBufferView = VkResult function(VkDevice device,const(VkBufferViewCreateInfo)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkBufferView* pView); 
			PFN_vkCreateBufferView vkCreateBufferView; 
			alias PFN_vkDestroyBufferView = void function(VkDevice device,VkBufferView bufferView,const(VkAllocationCallbacks)* pAllocator); 
			PFN_vkDestroyBufferView vkDestroyBufferView; 
			alias PFN_vkCreateImage = VkResult function(VkDevice device,const(VkImageCreateInfo)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkImage* pImage); 
			PFN_vkCreateImage vkCreateImage; 
			alias PFN_vkDestroyImage = void function(VkDevice device,VkImage image,const(VkAllocationCallbacks)* pAllocator); 
			PFN_vkDestroyImage vkDestroyImage; 
			alias PFN_vkGetImageSubresourceLayout = void function(VkDevice device,VkImage image,const(VkImageSubresource)* pSubresource,VkSubresourceLayout* pLayout); 
			PFN_vkGetImageSubresourceLayout vkGetImageSubresourceLayout; 
			alias PFN_vkCreateImageView = VkResult function(VkDevice device,const(VkImageViewCreateInfo)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkImageView* pView); 
			PFN_vkCreateImageView vkCreateImageView; 
			alias PFN_vkDestroyImageView = void function(VkDevice device,VkImageView imageView,const(VkAllocationCallbacks)* pAllocator); 
			PFN_vkDestroyImageView vkDestroyImageView; 
			alias PFN_vkCreateShaderModule = VkResult function(VkDevice device,const(VkShaderModuleCreateInfo)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkShaderModule* pShaderModule); 
			PFN_vkCreateShaderModule vkCreateShaderModule; 
			alias PFN_vkDestroyShaderModule = void function(VkDevice device,VkShaderModule shaderModule,const(VkAllocationCallbacks)* pAllocator); 
			PFN_vkDestroyShaderModule vkDestroyShaderModule; 
			alias PFN_vkCreatePipelineCache = VkResult function(VkDevice device,const(VkPipelineCacheCreateInfo)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkPipelineCache* pPipelineCache); 
			PFN_vkCreatePipelineCache vkCreatePipelineCache; 
			alias PFN_vkDestroyPipelineCache = void function(VkDevice device,VkPipelineCache pipelineCache,const(VkAllocationCallbacks)* pAllocator); 
			PFN_vkDestroyPipelineCache vkDestroyPipelineCache; 
			alias PFN_vkGetPipelineCacheData = VkResult function(VkDevice device,VkPipelineCache pipelineCache,size_t* pDataSize,void* pData); 
			PFN_vkGetPipelineCacheData vkGetPipelineCacheData; 
			alias PFN_vkMergePipelineCaches = VkResult function(VkDevice device,VkPipelineCache dstCache,uint32_t srcCacheCount,const(VkPipelineCache)* pSrcCaches); 
			PFN_vkMergePipelineCaches vkMergePipelineCaches; 
			alias PFN_vkCreateGraphicsPipelines = VkResult function(VkDevice device,VkPipelineCache pipelineCache,uint32_t createInfoCount,const(VkGraphicsPipelineCreateInfo)* pCreateInfos,const(VkAllocationCallbacks)* pAllocator,VkPipeline* pPipelines); 
			PFN_vkCreateGraphicsPipelines vkCreateGraphicsPipelines; 
			alias PFN_vkCreateComputePipelines = VkResult function(VkDevice device,VkPipelineCache pipelineCache,uint32_t createInfoCount,const(VkComputePipelineCreateInfo)* pCreateInfos,const(VkAllocationCallbacks)* pAllocator,VkPipeline* pPipelines); 
			PFN_vkCreateComputePipelines vkCreateComputePipelines; 
			alias PFN_vkDestroyPipeline = void function(VkDevice device,VkPipeline pipeline,const(VkAllocationCallbacks)* pAllocator); 
			PFN_vkDestroyPipeline vkDestroyPipeline; 
			alias PFN_vkCreatePipelineLayout = VkResult function(VkDevice device,const(VkPipelineLayoutCreateInfo)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkPipelineLayout* pPipelineLayout); 
			PFN_vkCreatePipelineLayout vkCreatePipelineLayout; 
			alias PFN_vkDestroyPipelineLayout = void function(VkDevice device,VkPipelineLayout pipelineLayout,const(VkAllocationCallbacks)* pAllocator); 
			PFN_vkDestroyPipelineLayout vkDestroyPipelineLayout; 
			alias PFN_vkCreateSampler = VkResult function(VkDevice device,const(VkSamplerCreateInfo)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkSampler* pSampler); 
			PFN_vkCreateSampler vkCreateSampler; 
			alias PFN_vkDestroySampler = void function(VkDevice device,VkSampler sampler,const(VkAllocationCallbacks)* pAllocator); 
			PFN_vkDestroySampler vkDestroySampler; 
			alias PFN_vkCreateDescriptorSetLayout = VkResult function(VkDevice device,const(VkDescriptorSetLayoutCreateInfo)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkDescriptorSetLayout* pSetLayout); 
			PFN_vkCreateDescriptorSetLayout vkCreateDescriptorSetLayout; 
			alias PFN_vkDestroyDescriptorSetLayout = void function(VkDevice device,VkDescriptorSetLayout descriptorSetLayout,const(VkAllocationCallbacks)* pAllocator); 
			PFN_vkDestroyDescriptorSetLayout vkDestroyDescriptorSetLayout; 
			alias PFN_vkCreateDescriptorPool = VkResult function(VkDevice device,const(VkDescriptorPoolCreateInfo)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkDescriptorPool* pDescriptorPool); 
			PFN_vkCreateDescriptorPool vkCreateDescriptorPool; 
			alias PFN_vkDestroyDescriptorPool = void function(VkDevice device,VkDescriptorPool descriptorPool,const(VkAllocationCallbacks)* pAllocator); 
			PFN_vkDestroyDescriptorPool vkDestroyDescriptorPool; 
			alias PFN_vkResetDescriptorPool = VkResult function(VkDevice device,VkDescriptorPool descriptorPool,VkDescriptorPoolResetFlags flags); 
			PFN_vkResetDescriptorPool vkResetDescriptorPool; 
			alias PFN_vkAllocateDescriptorSets = VkResult function(VkDevice device,const(VkDescriptorSetAllocateInfo)* pAllocateInfo,VkDescriptorSet* pDescriptorSets); 
			PFN_vkAllocateDescriptorSets vkAllocateDescriptorSets; 
			alias PFN_vkFreeDescriptorSets = VkResult function(VkDevice device,VkDescriptorPool descriptorPool,uint32_t descriptorSetCount,const(VkDescriptorSet)* pDescriptorSets); 
			PFN_vkFreeDescriptorSets vkFreeDescriptorSets; 
			alias PFN_vkUpdateDescriptorSets = void function(VkDevice device,uint32_t descriptorWriteCount,const(VkWriteDescriptorSet)* pDescriptorWrites,uint32_t descriptorCopyCount,const(VkCopyDescriptorSet)* pDescriptorCopies); 
			PFN_vkUpdateDescriptorSets vkUpdateDescriptorSets; 
			alias PFN_vkCreateFramebuffer = VkResult function(VkDevice device,const(VkFramebufferCreateInfo)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkFramebuffer* pFramebuffer); 
			PFN_vkCreateFramebuffer vkCreateFramebuffer; 
			alias PFN_vkDestroyFramebuffer = void function(VkDevice device,VkFramebuffer framebuffer,const(VkAllocationCallbacks)* pAllocator); 
			PFN_vkDestroyFramebuffer vkDestroyFramebuffer; 
			alias PFN_vkCreateRenderPass = VkResult function(VkDevice device,const(VkRenderPassCreateInfo)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkRenderPass* pRenderPass); 
			PFN_vkCreateRenderPass vkCreateRenderPass; 
			alias PFN_vkDestroyRenderPass = void function(VkDevice device,VkRenderPass renderPass,const(VkAllocationCallbacks)* pAllocator); 
			PFN_vkDestroyRenderPass vkDestroyRenderPass; 
			alias PFN_vkGetRenderAreaGranularity = void function(VkDevice device,VkRenderPass renderPass,VkExtent2D* pGranularity); 
			PFN_vkGetRenderAreaGranularity vkGetRenderAreaGranularity; 
			alias PFN_vkCreateCommandPool = VkResult function(VkDevice device,const(VkCommandPoolCreateInfo)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkCommandPool* pCommandPool); 
			PFN_vkCreateCommandPool vkCreateCommandPool; 
			alias PFN_vkDestroyCommandPool = void function(VkDevice device,VkCommandPool commandPool,const(VkAllocationCallbacks)* pAllocator); 
			PFN_vkDestroyCommandPool vkDestroyCommandPool; 
			alias PFN_vkResetCommandPool = VkResult function(VkDevice device,VkCommandPool commandPool,VkCommandPoolResetFlags flags); 
			PFN_vkResetCommandPool vkResetCommandPool; 
			alias PFN_vkAllocateCommandBuffers = VkResult function(VkDevice device,const(VkCommandBufferAllocateInfo)* pAllocateInfo,VkCommandBuffer* pCommandBuffers); 
			PFN_vkAllocateCommandBuffers vkAllocateCommandBuffers; 
			alias PFN_vkFreeCommandBuffers = void function(VkDevice device,VkCommandPool commandPool,uint32_t commandBufferCount,const(VkCommandBuffer)* pCommandBuffers); 
			PFN_vkFreeCommandBuffers vkFreeCommandBuffers; 
			alias PFN_vkBeginCommandBuffer = VkResult function(VkCommandBuffer commandBuffer,const(VkCommandBufferBeginInfo)* pBeginInfo); 
			PFN_vkBeginCommandBuffer vkBeginCommandBuffer; 
			alias PFN_vkEndCommandBuffer = VkResult function(VkCommandBuffer commandBuffer); 
			PFN_vkEndCommandBuffer vkEndCommandBuffer; 
			alias PFN_vkResetCommandBuffer = VkResult function(VkCommandBuffer commandBuffer,VkCommandBufferResetFlags flags); 
			PFN_vkResetCommandBuffer vkResetCommandBuffer; 
			alias PFN_vkCmdBindPipeline = void function(VkCommandBuffer commandBuffer,VkPipelineBindPoint pipelineBindPoint,VkPipeline pipeline); 
			PFN_vkCmdBindPipeline vkCmdBindPipeline; 
			alias PFN_vkCmdSetViewport = void function(VkCommandBuffer commandBuffer,uint32_t firstViewport,uint32_t viewportCount,const(VkViewport)* pViewports); 
			PFN_vkCmdSetViewport vkCmdSetViewport; 
			alias PFN_vkCmdSetScissor = void function(VkCommandBuffer commandBuffer,uint32_t firstScissor,uint32_t scissorCount,const(VkRect2D)* pScissors); 
			PFN_vkCmdSetScissor vkCmdSetScissor; 
			alias PFN_vkCmdSetLineWidth = void function(VkCommandBuffer commandBuffer,float lineWidth); 
			PFN_vkCmdSetLineWidth vkCmdSetLineWidth; 
			alias PFN_vkCmdSetDepthBias = void function(VkCommandBuffer commandBuffer,float depthBiasConstantFactor,float depthBiasClamp,float depthBiasSlopeFactor); 
			PFN_vkCmdSetDepthBias vkCmdSetDepthBias; 
			alias PFN_vkCmdSetBlendConstants = void function(VkCommandBuffer commandBuffer,const float[4] blendConstants); 
			PFN_vkCmdSetBlendConstants vkCmdSetBlendConstants; 
			alias PFN_vkCmdSetDepthBounds = void function(VkCommandBuffer commandBuffer,float minDepthBounds,float maxDepthBounds); 
			PFN_vkCmdSetDepthBounds vkCmdSetDepthBounds; 
			alias PFN_vkCmdSetStencilCompareMask = void function(VkCommandBuffer commandBuffer,VkStencilFaceFlags faceMask,uint32_t compareMask); 
			PFN_vkCmdSetStencilCompareMask vkCmdSetStencilCompareMask; 
			alias PFN_vkCmdSetStencilWriteMask = void function(VkCommandBuffer commandBuffer,VkStencilFaceFlags faceMask,uint32_t writeMask); 
			PFN_vkCmdSetStencilWriteMask vkCmdSetStencilWriteMask; 
			alias PFN_vkCmdSetStencilReference = void function(VkCommandBuffer commandBuffer,VkStencilFaceFlags faceMask,uint32_t reference); 
			PFN_vkCmdSetStencilReference vkCmdSetStencilReference; 
			alias PFN_vkCmdBindDescriptorSets = void function(VkCommandBuffer commandBuffer,VkPipelineBindPoint pipelineBindPoint,VkPipelineLayout layout,uint32_t firstSet,uint32_t descriptorSetCount,const(VkDescriptorSet)* pDescriptorSets,uint32_t dynamicOffsetCount,const(uint32_t)* pDynamicOffsets); 
			PFN_vkCmdBindDescriptorSets vkCmdBindDescriptorSets; 
			alias PFN_vkCmdBindIndexBuffer = void function(VkCommandBuffer commandBuffer,VkBuffer buffer,VkDeviceSize offset,VkIndexType indexType); 
			PFN_vkCmdBindIndexBuffer vkCmdBindIndexBuffer; 
			alias PFN_vkCmdBindVertexBuffers = void function(VkCommandBuffer commandBuffer,uint32_t firstBinding,uint32_t bindingCount,const(VkBuffer)* pBuffers,const(VkDeviceSize)* pOffsets); 
			PFN_vkCmdBindVertexBuffers vkCmdBindVertexBuffers; 
			alias PFN_vkCmdDraw = void function(VkCommandBuffer commandBuffer,uint32_t vertexCount,uint32_t instanceCount,uint32_t firstVertex,uint32_t firstInstance); 
			PFN_vkCmdDraw vkCmdDraw; 
			alias PFN_vkCmdDrawIndexed = void function(VkCommandBuffer commandBuffer,uint32_t indexCount,uint32_t instanceCount,uint32_t firstIndex,int32_t vertexOffset,uint32_t firstInstance); 
			PFN_vkCmdDrawIndexed vkCmdDrawIndexed; 
			alias PFN_vkCmdDrawIndirect = void function(VkCommandBuffer commandBuffer,VkBuffer buffer,VkDeviceSize offset,uint32_t drawCount,uint32_t stride); 
			PFN_vkCmdDrawIndirect vkCmdDrawIndirect; 
			alias PFN_vkCmdDrawIndexedIndirect = void function(VkCommandBuffer commandBuffer,VkBuffer buffer,VkDeviceSize offset,uint32_t drawCount,uint32_t stride); 
			PFN_vkCmdDrawIndexedIndirect vkCmdDrawIndexedIndirect; 
			alias PFN_vkCmdDispatch = void function(VkCommandBuffer commandBuffer,uint32_t x,uint32_t y,uint32_t z); 
			PFN_vkCmdDispatch vkCmdDispatch; 
			alias PFN_vkCmdDispatchIndirect = void function(VkCommandBuffer commandBuffer,VkBuffer buffer,VkDeviceSize offset); 
			PFN_vkCmdDispatchIndirect vkCmdDispatchIndirect; 
			alias PFN_vkCmdCopyBuffer = void function(VkCommandBuffer commandBuffer,VkBuffer srcBuffer,VkBuffer dstBuffer,uint32_t regionCount,const(VkBufferCopy)* pRegions); 
			PFN_vkCmdCopyBuffer vkCmdCopyBuffer; 
			alias PFN_vkCmdCopyImage = void function(VkCommandBuffer commandBuffer,VkImage srcImage,VkImageLayout srcImageLayout,VkImage dstImage,VkImageLayout dstImageLayout,uint32_t regionCount,const(VkImageCopy)* pRegions); 
			PFN_vkCmdCopyImage vkCmdCopyImage; 
			alias PFN_vkCmdBlitImage = void function(VkCommandBuffer commandBuffer,VkImage srcImage,VkImageLayout srcImageLayout,VkImage dstImage,VkImageLayout dstImageLayout,uint32_t regionCount,const(VkImageBlit)* pRegions,VkFilter filter); 
			PFN_vkCmdBlitImage vkCmdBlitImage; 
			alias PFN_vkCmdCopyBufferToImage = void function(VkCommandBuffer commandBuffer,VkBuffer srcBuffer,VkImage dstImage,VkImageLayout dstImageLayout,uint32_t regionCount,const(VkBufferImageCopy)* pRegions); 
			PFN_vkCmdCopyBufferToImage vkCmdCopyBufferToImage; 
			alias PFN_vkCmdCopyImageToBuffer = void function(VkCommandBuffer commandBuffer,VkImage srcImage,VkImageLayout srcImageLayout,VkBuffer dstBuffer,uint32_t regionCount,const(VkBufferImageCopy)* pRegions); 
			PFN_vkCmdCopyImageToBuffer vkCmdCopyImageToBuffer; 
			alias PFN_vkCmdUpdateBuffer = void function(VkCommandBuffer commandBuffer,VkBuffer dstBuffer,VkDeviceSize dstOffset,VkDeviceSize dataSize,const(uint32_t)* pData); 
			PFN_vkCmdUpdateBuffer vkCmdUpdateBuffer; 
			alias PFN_vkCmdFillBuffer = void function(VkCommandBuffer commandBuffer,VkBuffer dstBuffer,VkDeviceSize dstOffset,VkDeviceSize size,uint32_t data); 
			PFN_vkCmdFillBuffer vkCmdFillBuffer; 
			alias PFN_vkCmdClearColorImage = void function(VkCommandBuffer commandBuffer,VkImage image,VkImageLayout imageLayout,const(VkClearColorValue)* pColor,uint32_t rangeCount,const(VkImageSubresourceRange)* pRanges); 
			PFN_vkCmdClearColorImage vkCmdClearColorImage; 
			alias PFN_vkCmdClearDepthStencilImage = void function(VkCommandBuffer commandBuffer,VkImage image,VkImageLayout imageLayout,const(VkClearDepthStencilValue)* pDepthStencil,uint32_t rangeCount,const(VkImageSubresourceRange)* pRanges); 
			PFN_vkCmdClearDepthStencilImage vkCmdClearDepthStencilImage; 
			alias PFN_vkCmdClearAttachments = void function(VkCommandBuffer commandBuffer,uint32_t attachmentCount,const(VkClearAttachment)* pAttachments,uint32_t rectCount,const(VkClearRect)* pRects); 
			PFN_vkCmdClearAttachments vkCmdClearAttachments; 
			alias PFN_vkCmdResolveImage = void function(VkCommandBuffer commandBuffer,VkImage srcImage,VkImageLayout srcImageLayout,VkImage dstImage,VkImageLayout dstImageLayout,uint32_t regionCount,const(VkImageResolve)* pRegions); 
			PFN_vkCmdResolveImage vkCmdResolveImage; 
			alias PFN_vkCmdSetEvent = void function(VkCommandBuffer commandBuffer,VkEvent event,VkPipelineStageFlags stageMask); 
			PFN_vkCmdSetEvent vkCmdSetEvent; 
			alias PFN_vkCmdResetEvent = void function(VkCommandBuffer commandBuffer,VkEvent event,VkPipelineStageFlags stageMask); 
			PFN_vkCmdResetEvent vkCmdResetEvent; 
			alias PFN_vkCmdWaitEvents = void function(
				VkCommandBuffer commandBuffer,uint32_t eventCount,const(VkEvent)* pEvents,VkPipelineStageFlags srcStageMask,VkPipelineStageFlags dstStageMask,uint32_t memoryBarrierCount,
				const(VkMemoryBarrier)* pMemoryBarriers,uint32_t bufferMemoryBarrierCount,const(VkBufferMemoryBarrier)* pBufferMemoryBarriers,uint32_t imageMemoryBarrierCount,const(VkImageMemoryBarrier)* pImageMemoryBarriers
			); 
			PFN_vkCmdWaitEvents vkCmdWaitEvents; 
			alias PFN_vkCmdPipelineBarrier = void function(
				VkCommandBuffer commandBuffer,VkPipelineStageFlags srcStageMask,VkPipelineStageFlags dstStageMask,VkDependencyFlags dependencyFlags,uint32_t memoryBarrierCount,
				const(VkMemoryBarrier)* pMemoryBarriers,uint32_t bufferMemoryBarrierCount,const(VkBufferMemoryBarrier)* pBufferMemoryBarriers,uint32_t imageMemoryBarrierCount,const(VkImageMemoryBarrier)* pImageMemoryBarriers
			); 
			PFN_vkCmdPipelineBarrier vkCmdPipelineBarrier; 
			alias PFN_vkCmdBeginQuery = void function(VkCommandBuffer commandBuffer,VkQueryPool queryPool,uint32_t query,VkQueryControlFlags flags); 
			PFN_vkCmdBeginQuery vkCmdBeginQuery; 
			alias PFN_vkCmdEndQuery = void function(VkCommandBuffer commandBuffer,VkQueryPool queryPool,uint32_t query); 
			PFN_vkCmdEndQuery vkCmdEndQuery; 
			alias PFN_vkCmdResetQueryPool = void function(VkCommandBuffer commandBuffer,VkQueryPool queryPool,uint32_t firstQuery,uint32_t queryCount); 
			PFN_vkCmdResetQueryPool vkCmdResetQueryPool; 
			alias PFN_vkCmdWriteTimestamp = void function(VkCommandBuffer commandBuffer,VkPipelineStageFlagBits pipelineStage,VkQueryPool queryPool,uint32_t query); 
			PFN_vkCmdWriteTimestamp vkCmdWriteTimestamp; 
			alias PFN_vkCmdCopyQueryPoolResults = void function(VkCommandBuffer commandBuffer,VkQueryPool queryPool,uint32_t firstQuery,uint32_t queryCount,VkBuffer dstBuffer,VkDeviceSize dstOffset,VkDeviceSize stride,VkQueryResultFlags flags); 
			PFN_vkCmdCopyQueryPoolResults vkCmdCopyQueryPoolResults; 
			alias PFN_vkCmdPushConstants = void function(VkCommandBuffer commandBuffer,VkPipelineLayout layout,VkShaderStageFlags stageFlags,uint32_t offset,uint32_t size,const(void)* pValues); 
			PFN_vkCmdPushConstants vkCmdPushConstants; 
			alias PFN_vkCmdBeginRenderPass = void function(VkCommandBuffer commandBuffer,const(VkRenderPassBeginInfo)* pRenderPassBegin,VkSubpassContents contents); 
			PFN_vkCmdBeginRenderPass vkCmdBeginRenderPass; 
			alias PFN_vkCmdNextSubpass = void function(VkCommandBuffer commandBuffer,VkSubpassContents contents); 
			PFN_vkCmdNextSubpass vkCmdNextSubpass; 
			alias PFN_vkCmdEndRenderPass = void function(VkCommandBuffer commandBuffer); 
			PFN_vkCmdEndRenderPass vkCmdEndRenderPass; 
			alias PFN_vkCmdExecuteCommands = void function(VkCommandBuffer commandBuffer,uint32_t commandBufferCount,const(VkCommandBuffer)* pCommandBuffers); 
			PFN_vkCmdExecuteCommands vkCmdExecuteCommands; 
		}
		version(DVulkan_VK_KHR_surface)
		{
			alias PFN_vkDestroySurfaceKHR = void function(VkInstance instance,VkSurfaceKHR surface,const(VkAllocationCallbacks)* pAllocator); 
			PFN_vkDestroySurfaceKHR vkDestroySurfaceKHR; 
			alias PFN_vkGetPhysicalDeviceSurfaceSupportKHR = VkResult function(VkPhysicalDevice physicalDevice,uint32_t queueFamilyIndex,VkSurfaceKHR surface,VkBool32* pSupported); 
			PFN_vkGetPhysicalDeviceSurfaceSupportKHR vkGetPhysicalDeviceSurfaceSupportKHR; 
			alias PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = VkResult function(VkPhysicalDevice physicalDevice,VkSurfaceKHR surface,VkSurfaceCapabilitiesKHR* pSurfaceCapabilities); 
			PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR vkGetPhysicalDeviceSurfaceCapabilitiesKHR; 
			alias PFN_vkGetPhysicalDeviceSurfaceFormatsKHR = VkResult function(VkPhysicalDevice physicalDevice,VkSurfaceKHR surface,uint32_t* pSurfaceFormatCount,VkSurfaceFormatKHR* pSurfaceFormats); 
			PFN_vkGetPhysicalDeviceSurfaceFormatsKHR vkGetPhysicalDeviceSurfaceFormatsKHR; 
			alias PFN_vkGetPhysicalDeviceSurfacePresentModesKHR = VkResult function(VkPhysicalDevice physicalDevice,VkSurfaceKHR surface,uint32_t* pPresentModeCount,VkPresentModeKHR* pPresentModes); 
			PFN_vkGetPhysicalDeviceSurfacePresentModesKHR vkGetPhysicalDeviceSurfacePresentModesKHR; 
		}
		
		//het
		version(DVulkan_VK_KHR_win32_surface)
		{
			alias PFN_vkCreateWin32SurfaceKHR = VkResult function(VkInstance instance, const(VkWin32SurfaceCreateInfoKHR)* pCreateInfo, const(VkAllocationCallbacks)* pAllocator, VkSurfaceKHR* pSurface); 
			PFN_vkCreateWin32SurfaceKHR vkCreateWin32SurfaceKHR; 
		}
		
		version(DVulkan_VK_KHR_swapchain)
		{
			alias PFN_vkCreateSwapchainKHR = VkResult function(VkDevice device,const(VkSwapchainCreateInfoKHR)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkSwapchainKHR* pSwapchain); 
			PFN_vkCreateSwapchainKHR vkCreateSwapchainKHR; 
			alias PFN_vkDestroySwapchainKHR = void function(VkDevice device,VkSwapchainKHR swapchain,const(VkAllocationCallbacks)* pAllocator); 
			PFN_vkDestroySwapchainKHR vkDestroySwapchainKHR; 
			alias PFN_vkGetSwapchainImagesKHR = VkResult function(VkDevice device,VkSwapchainKHR swapchain,uint32_t* pSwapchainImageCount,VkImage* pSwapchainImages); 
			PFN_vkGetSwapchainImagesKHR vkGetSwapchainImagesKHR; 
			alias PFN_vkAcquireNextImageKHR = VkResult function(VkDevice device,VkSwapchainKHR swapchain,uint64_t timeout,VkSemaphore semaphore,VkFence fence,uint32_t* pImageIndex); 
			PFN_vkAcquireNextImageKHR vkAcquireNextImageKHR; 
			alias PFN_vkQueuePresentKHR = VkResult function(VkQueue queue,const(VkPresentInfoKHR)* pPresentInfo); 
			PFN_vkQueuePresentKHR vkQueuePresentKHR; 
		}
		version(DVulkan_VK_KHR_display)
		{
			alias PFN_vkGetPhysicalDeviceDisplayPropertiesKHR = VkResult function(VkPhysicalDevice physicalDevice,uint32_t* pPropertyCount,VkDisplayPropertiesKHR* pProperties); 
			PFN_vkGetPhysicalDeviceDisplayPropertiesKHR vkGetPhysicalDeviceDisplayPropertiesKHR; 
			alias PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = VkResult function(VkPhysicalDevice physicalDevice,uint32_t* pPropertyCount,VkDisplayPlanePropertiesKHR* pProperties); 
			PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR vkGetPhysicalDeviceDisplayPlanePropertiesKHR; 
			alias PFN_vkGetDisplayPlaneSupportedDisplaysKHR = VkResult function(VkPhysicalDevice physicalDevice,uint32_t planeIndex,uint32_t* pDisplayCount,VkDisplayKHR* pDisplays); 
			PFN_vkGetDisplayPlaneSupportedDisplaysKHR vkGetDisplayPlaneSupportedDisplaysKHR; 
			alias PFN_vkGetDisplayModePropertiesKHR = VkResult function(VkPhysicalDevice physicalDevice,VkDisplayKHR display,uint32_t* pPropertyCount,VkDisplayModePropertiesKHR* pProperties); 
			PFN_vkGetDisplayModePropertiesKHR vkGetDisplayModePropertiesKHR; 
			alias PFN_vkCreateDisplayModeKHR = VkResult function(VkPhysicalDevice physicalDevice,VkDisplayKHR display,const(VkDisplayModeCreateInfoKHR)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkDisplayModeKHR* pMode); 
			PFN_vkCreateDisplayModeKHR vkCreateDisplayModeKHR; 
			alias PFN_vkGetDisplayPlaneCapabilitiesKHR = VkResult function(VkPhysicalDevice physicalDevice,VkDisplayModeKHR mode,uint32_t planeIndex,VkDisplayPlaneCapabilitiesKHR* pCapabilities); 
			PFN_vkGetDisplayPlaneCapabilitiesKHR vkGetDisplayPlaneCapabilitiesKHR; 
			alias PFN_vkCreateDisplayPlaneSurfaceKHR = VkResult function(VkInstance instance,const(VkDisplaySurfaceCreateInfoKHR)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkSurfaceKHR* pSurface); 
			PFN_vkCreateDisplayPlaneSurfaceKHR vkCreateDisplayPlaneSurfaceKHR; 
		}
		version(DVulkan_VK_KHR_display_swapchain)
		{
			alias PFN_vkCreateSharedSwapchainsKHR = VkResult function(VkDevice device,uint32_t swapchainCount,const(VkSwapchainCreateInfoKHR)* pCreateInfos,const(VkAllocationCallbacks)* pAllocator,VkSwapchainKHR* pSwapchains); 
			PFN_vkCreateSharedSwapchainsKHR vkCreateSharedSwapchainsKHR; 
		}
		version(DVulkan_VK_EXT_debug_report)
		{
			alias PFN_vkCreateDebugReportCallbackEXT = VkResult function(VkInstance instance,const(VkDebugReportCallbackCreateInfoEXT)* pCreateInfo,const(VkAllocationCallbacks)* pAllocator,VkDebugReportCallbackEXT* pCallback); 
			PFN_vkCreateDebugReportCallbackEXT vkCreateDebugReportCallbackEXT; 
			alias PFN_vkDestroyDebugReportCallbackEXT = void function(VkInstance instance,VkDebugReportCallbackEXT callback,const(VkAllocationCallbacks)* pAllocator); 
			PFN_vkDestroyDebugReportCallbackEXT vkDestroyDebugReportCallbackEXT; 
			alias PFN_vkDebugReportMessageEXT = void function(VkInstance instance,VkDebugReportFlagsEXT flags,VkDebugReportObjectTypeEXT objectType,uint64_t object,size_t location,int32_t messageCode,const(char)* pLayerPrefix,const(char)* pMessage); 
			PFN_vkDebugReportMessageEXT vkDebugReportMessageEXT; 
		}
		version(DVulkan_VK_EXT_debug_marker)
		{
			alias PFN_vkDebugMarkerSetObjectTagEXT = VkResult function(VkDevice device,VkDebugMarkerObjectTagInfoEXT* pTagInfo); 
			PFN_vkDebugMarkerSetObjectTagEXT vkDebugMarkerSetObjectTagEXT; 
			alias PFN_vkDebugMarkerSetObjectNameEXT = VkResult function(VkDevice device,VkDebugMarkerObjectNameInfoEXT* pNameInfo); 
			PFN_vkDebugMarkerSetObjectNameEXT vkDebugMarkerSetObjectNameEXT; 
			alias PFN_vkCmdDebugMarkerBeginEXT = void function(VkCommandBuffer commandBuffer,VkDebugMarkerMarkerInfoEXT* pMarkerInfo); 
			PFN_vkCmdDebugMarkerBeginEXT vkCmdDebugMarkerBeginEXT; 
			alias PFN_vkCmdDebugMarkerEndEXT = void function(VkCommandBuffer commandBuffer); 
			PFN_vkCmdDebugMarkerEndEXT vkCmdDebugMarkerEndEXT; 
			alias PFN_vkCmdDebugMarkerInsertEXT = void function(VkCommandBuffer commandBuffer,VkDebugMarkerMarkerInfoEXT* pMarkerInfo); 
			PFN_vkCmdDebugMarkerInsertEXT vkCmdDebugMarkerInsertEXT; 
		}
		/+
			Note: The following higher level helper functions are working with dynamic arrays 
			and having error handling.
		+/
		
		auto enumeratePhysicalDevices()
		{
			uint numDevices; 
			vkEnumeratePhysicalDevices(instance, &numDevices, null).vkEnforce; 
			
			auto devices = new VkPhysicalDevice[numDevices]; 
			vkEnumeratePhysicalDevices(instance, &numDevices, devices.ptr).vkEnforce; 
			
			return devices; 
		} 
		
		auto getPhysicalDeviceProperties(VkPhysicalDevice device)
		{
			VkPhysicalDeviceProperties props; 
			vkGetPhysicalDeviceProperties(device, &props); 
			return props; 
		} 
		
		auto enumeratePhysicalDeviceQueueFamilyProperties(VkPhysicalDevice device)
		{
			// Check queue families
			uint cnt; 
			vkGetPhysicalDeviceQueueFamilyProperties(device, &cnt, null); 
			auto props = new VkQueueFamilyProperties[cnt]; 
			if(props.length)
			vkGetPhysicalDeviceQueueFamilyProperties(device, &cnt, props.ptr); 
			return props; 
		} 
		
		auto enumerateInstanceExtensionProperties(string layerName)
		{
			uint extensionCount; 
			vkEnumerateInstanceExtensionProperties(layerName.toPChar, &extensionCount, null).vkEnforce; 
			
			auto data = new VkExtensionProperties[extensionCount]; 
			if(extensionCount)
			vkEnumerateInstanceExtensionProperties(layerName.toPChar, &extensionCount, data.ptr).vkEnforce; 
			return data; 
		} 
		
		auto enumerateInstanceLayerProperties()
		{
			uint numLayerProps; 
			vkEnumerateInstanceLayerProperties(&numLayerProps, null).vkEnforce; 
			auto layerProps = new VkLayerProperties[numLayerProps]; 
			vkEnumerateInstanceLayerProperties(&numLayerProps, layerProps.ptr).vkEnforce; 
			return layerProps; 
		} 
		
		auto enumerateDeviceLayerProperties(VkPhysicalDevice device)
		{
			uint numLayerProps; 
			vkEnumerateDeviceLayerProperties(device, &numLayerProps, null).vkEnforce; 
			auto layerProps = new VkLayerProperties[numLayerProps]; 
			vkEnumerateDeviceLayerProperties(device, &numLayerProps, layerProps.ptr).vkEnforce; 
			return layerProps; 
		} 
		
		VkSurfaceCapabilitiesKHR getPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface)
		{
			VkSurfaceCapabilitiesKHR surfaceCapabilities; 
			vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, &surfaceCapabilities)
				.vkEnforce("failed to acquire presentation surface capabilities"); 
			return surfaceCapabilities; 
		} 
		
		VkSurfaceFormatKHR[] getPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface)
		{
			uint formatCount; 
			vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, &formatCount, null)
				.vkEnforce("failed to get number of supported surface formats"); 
			
			auto surfaceFormats = new VkSurfaceFormatKHR[formatCount]; 
			vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, &formatCount, surfaceFormats.ptr)
				.vkEnforce("failed to get supported surface formats"); 
			
			return surfaceFormats; 
		} 
		
		VkPresentModeKHR[] getPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface)
		{
			uint presentModeCount; 
			vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, &presentModeCount, null)
				.vkEnforce("failed to get number of supported presentation modes"); 
			enforce(presentModeCount, "failed to get number of supported presentation modes (0)"); 
			
			auto presentModes = new VkPresentModeKHR[presentModeCount]; 
			vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, &presentModeCount, presentModes.ptr)
				.vkEnforce("failed to get supported presentation modes"); 
			
			return presentModes; 
		} 
		
		VkImage[] getSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapChain)
		{
			uint actualImageCount; 
			vkGetSwapchainImagesKHR(device, swapChain, &actualImageCount, null)
				.vkEnforce("failed to acquire number of swap chain images"); 
			enforce(actualImageCount, "failed to acquire number of swap chain images (0)"); 
			
			auto swapChainImages = new VkImage[actualImageCount]; 
			vkGetSwapchainImagesKHR(device, swapChain, &actualImageCount, swapChainImages.ptr)
				.vkEnforce("failed to acquire swap chain images"); 
			
			return swapChainImages; 
		} 
	} 
} 
version(/+$DIDE_REGION Vulkan classes+/all)
{
	version(/+$DIDE_REGION+/all)
	{
		public import het;  //From here it uses hetlib.
		
		private __gshared VulkanFunctions vkInitializationFunctions; 
		
		bool vulkanInstalled()
		{ return vkInitializationFunctions.vkCreateInstance !is null; } 
		
		shared static this()
		{
			//try to access Vulkan Initialization Functions
			ignoreExceptions(
				{
					VulkanFunctions.PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr; 
					loadLibrary("vulkan-1.dll").getProcAddress!vkGetInstanceProcAddr; 
					vkInitializationFunctions.loadInitializationFunctions(vkGetInstanceProcAddr); 
				}
			); 
		} 
		
		auto vkEnforce(string file = __FILE__, int line = __LINE__)(VkResult r, string s="")
		{ if(r!=VK_SUCCESS) throw new Exception(only(r.text, s).filter!"a!=``".join(": "), file, line); } 
		
		class VulkanExtension
		{
			mixin SmartClass!q{
				@PARENT VulkanExtensions 	owner,
				VkExtensionProperties 	properties
			}; 
			
			alias properties this; 
			string name; 
			
			void _construct()
			{ name = properties.extensionName.toStr; }  void _destruct()
			{} 
			
			override string toString() const
			{ return format!"%s (%s)"(name, specVersion); } 
		} 
		
		class VulkanExtensions
		{
			mixin SmartClassParent!q{const string layerName=""};  //note, this is a Root parent.
			
			VulkanExtension[] items; alias items this; 
			VulkanExtension[string] byName; 
			
			void _construct()
			{
				if(vulkanInstalled)
				items = 	vkInitializationFunctions.enumerateInstanceExtensionProperties(layerName)
					.map!(a=>new VulkanExtension(this, a)).array; 
				byName = assocArray(items.map!"a.name", items); 
			} 
			
			void _destruct()
			{} 
			
			override string toString() const
			{
				return 	(
					layerName=="" 	? "Instance Extensions" 
						: "Layer Extensions "~layerName.quoted
				)	~ ":\n"
					~ items.map!(a=>"  "~a.text~"\n").join; 
			} 
			
			auto opBinary(string op : "in")(string b)
			{ return b in byName; } 
			
			auto names()
			{ return items.map!"a.extensionName"; } 
		} 
		
		class VulkanLayer
		{
			mixin SmartClass!q{
				@PARENT VulkanLayers 	owner, 
				VkLayerProperties 	properties
			}; 
			
			alias properties this; 
			string name; 
			string description; 
			
			void _construct()
			{
				name = properties.layerName.toStr; 
				description = properties.description.toStr; //mostly empty
			}  void _destruct()
			{} 
			
			override string toString() const
			{ return format!"%-40s - %s"(name, description); } 
			
			private VulkanExtensions _extensions; 
			@property extensions()
			{
				if(!_extensions)
				{ _extensions = new VulkanExtensions(name); }
				return _extensions; 
			} 
		} 
		
		class VulkanLayers
		{
			mixin SmartClassParent!q{
				VulkanPhysicalDevice physicalDevice=null /+
					Note: It's not a parent reference! 
					It can be null too.
				+/
			}; 
			
			VulkanLayer[] items; alias items this; 
			VulkanLayer[string] byName; 
			
			void _construct()
			{
				if(vulkanInstalled)
				items = 	(
					physicalDevice
					? physicalDevice.instance.enumerateDeviceLayerProperties(physicalDevice.handle) 
					: vkInitializationFunctions.enumerateInstanceLayerProperties
				)
					.map!(a=>new VulkanLayer(this, a)).array; 
				byName = assocArray(items.map!"a.name", items); 
			} 
			void _destruct() {} 
			
			override string toString() const
			{
				return 	(
					physicalDevice is null	? "Instance Layers" 
						: "PhysicalDevice Layers "~physicalDevice.name.quoted
				) ~ ":\n"
					~ items.map!(a=>"  "~a.text~"\n").join; 
			} 
			
			auto opBinary(string op : "in")(string b)
			{ return b in byName; } 
			
			auto names()
			{ return items.map!"a.name"; } 
		} 
		
		class VulkanQueueFamily
		{
			mixin SmartClass!q{
				@PARENT VulkanPhysicalDevice 	physicalDevice, 
				int 	index, 
				VkQueueFamilyProperties 	properties
			}; 
			
			alias properties this; 
			
			void _construct()
			{} void _destruct()
			{} 
			
			override string toString() const
			{ return format!"%s: %sx %s)"(index, queueCount, queueFlags); } 
		} 
		
		class VulkanQueueFamilies
		{
			mixin SmartClassParent!q{@PARENT VulkanPhysicalDevice physicalDevice}; 
			
			VulkanQueueFamily[] items; 
			alias items this; 
			
			void _construct()
			{
				int i; 
				items = physicalDevice.instance.enumeratePhysicalDeviceQueueFamilyProperties(physicalDevice.handle)
				.map!(a=>new VulkanQueueFamily(physicalDevice, i++, a)).array; 
			} 
			void _destruct() {} 
			
			override string toString() const
			{ return format!"Queue Families:\n" ~ items.map!(a=>"  "~a.text~"\n").join; } 
		} 
		
		class VulkanMemoryProperties
		{
			mixin SmartClass!q{ @PARENT VulkanPhysicalDevice physicalDevice }; 
			
			VkPhysicalDeviceMemoryProperties properties; alias properties this; 
			
			void _construct()
			{ physicalDevice.instance.vkGetPhysicalDeviceMemoryProperties(physicalDevice.handle, &properties); } 
			
			void _destruct()
			{} 
			
			auto heaps() const
			{ return memoryHeaps[0..memoryHeapCount]; } 
			
			auto types() const
			{ return memoryTypes[0..memoryTypeCount]; } 
			
			override string toString() const
			{ return chain(types.map!text, heaps.map!text).join('\n')~'\n'; } 
			
			//Find device memory that is supported by the requirements (typeBits) and meets the desired properties
			bool getMemoryType(uint typeBits, VkMemoryPropertyFlags props, uint* typeIndex)
			{
				/+
					Todo: Upgrade this algo according to the docs.
					/+
						Link: https://registry.khronos.org/vulkan/specs/1.3-extensions
						/man/html/VkPhysicalDeviceMemoryProperties.html
					+/
				+/
				
				foreach(i; 0..32)
				{
					if(typeBits.getBit(i) && (memoryTypes[i].propertyFlags & props)==props)
					{ *typeIndex = i; return true; }
				}
				return false; 
			} 
		} 
		
		class VulkanPhysicalDevice
		{
			mixin SmartClassParent!(
				q{
					@PARENT VulkanInstance 	instance,
					VkPhysicalDevice 	handle,
					int 	index
				}
			); 
			
			VkPhysicalDeviceProperties properties; alias properties this; 
			string name; 
			
			void _construct()
			{
				instance.vkGetPhysicalDeviceProperties(handle, &properties); 
				name = properties.deviceName.toStr; 
			} 
			
			void _destruct()
			{/+It's just a handle, nothing to destroy here.+/} 
			
			override string toString() const
			{ return name; } 
			
			private VulkanQueueFamilies _queueFamilies; 
			@property queueFamilies()
			{
				if(!_queueFamilies)
				{ _queueFamilies = new VulkanQueueFamilies(this); }
				return _queueFamilies; 
			} 
			
			private VulkanLayers _layers; 
			@property layers()
			{
				if(!_layers)
				{ _layers = new VulkanLayers(this); }
				return _layers; 
			} 
			
			private VulkanMemoryProperties _memoryProperties; 
			@property memoryProperties()
			{
				if(!_memoryProperties)
				_memoryProperties = new VulkanMemoryProperties(this); 
				return _memoryProperties; 
			} 
			
			auto graphicsQueueFamilies()
			{ return queueFamilies.items.filter!(qf=>qf.queueCount>0 && qf.queueFlags.GRAPHICS_BIT); } 
			auto computeQueueFamilies()
			{ return queueFamilies.items.filter!(qf=>qf.queueCount>0 && qf.queueFlags.COMPUTE_BIT); } 
			auto transferQueueFamilies()
			{ return queueFamilies.items.filter!(qf=>qf.queueCount>0 && qf.queueFlags.TRANSFER_BIT); } 
			auto graphicsAndComputeQueueFamilies()
			{ return computeQueueFamilies.filter!(qf=>qf.queueFlags.GRAPHICS_BIT); } 
			
			auto dedicatedComputeQueueFamilies()
			{ return computeQueueFamilies.filter!(qf=>!qf.queueFlags.GRAPHICS_BIT); } 
			auto dedicatedTransferQueueFamilies()
			{
				return computeQueueFamilies.filter!(
					qf=>	!qf.queueFlags.GRAPHICS_BIT && 
						!qf.queueFlags.COMPUTE_BIT
				); 
			} 
			
			auto requireComputeQueueFamily()
			{
				return 	dedicatedComputeQueueFamilies
					.frontOr(computeQueueFamilies.frontOrNull)
					.enforce("No compute queue family found."); 
			} 
			
			auto requireTransferQueueFamily()
			{
				return 	dedicatedTransferQueueFamilies
					.frontOr(transferQueueFamilies.frontOrNull)
					.enforce("No transfer queue family found."); 
			} 
		} 
		
		class VulkanPhysicalDevices
		{
			mixin SmartClass!(q{VulkanPhysicalDevice[] items}); alias items this; 
			void _construct() {} void _destruct() {} 
			
			override string toString() const
			{
				return 	"Physical Devices:\n"
					~ items.map!(a=>format!"  %s: %s \n"(a.index, a.name)).join; 
			} 
		} 
		
		class VulkanQueue
		{
			mixin SmartClassParent!q{
				@PARENT VulkanDevice 	device, 
				VulkanQueueFamily 	queueFamily, 
				float 	priority,
				VkQueue	handle
			}; 
			
			void _construct()
			{
				enforce(priority.inRange(0, 1), "VulkanQuery priority out of range."); 
				enforce(handle, "Must be a valid VkQueue handle."); 
			} 
			
			void _destruct()
			{
				handle = null; 
				/+queue handle is implicitly destroyed by VkDevice+/
			} 
			
			override string toString() const
			{ return format!"VulkanQueue(familyIndex=%d, priority=%.2f)"(queueFamily.index, priority); } 
			
			auto createCommandPool()
			{ return new VulkanCommandPool(device, queueFamily); } 
			
			private VulkanCommandPool mainCommandPool_; 
			auto mainCommandPool()
			{
				if(!mainCommandPool_) mainCommandPool_ = createCommandPool; 
				return mainCommandPool_; 
			} 
			
			void submit(Args...)(Args args)
			{
				VkCommandBuffer[] buf; 
				VkSemaphore[] waits, signals; 
				VkPipelineStageFlags[] waitsFlags; 
				//Opt: this is not fast but simple.  Should measure performance...  Should process this in CT
				
				void addFlags(VkPipelineStageFlags f)
				{
					if(waitsFlags.length==waits.length)	waitsFlags.back |= f; 
					else if(waitsFlags.length+1==waits.length)	waitsFlags ~= f; 
					else raise("VkPipelineStageFlags submit inconsistency"); 
				} 
				
				static foreach(i, arg; args)
				{
					{
						alias T = Unqual!(Args[i]); 
						static if(is(T==VkCommandBuffer))	buf ~= arg; 
						else static if(is(T==VkCommandBuffer[]))	buf ~= arg; 
						else static if(is(T==VulkanCommandBuffer))	buf ~= arg.handle; 
						else static if(is(T==VulkanSemaphore))	(buf.length ? signals : waits) ~= arg.handle; 
						else static if(is(T==VkSemaphore))	(buf.length ? signals : waits) ~= arg; 
						else static if(is(T==VkPipelineStageFlags))	addFlags(arg); 
						else static if(is(T==VkPipelineStageFlagBits))	addFlags(VkPipelineStageFlags(arg)); 
						else static assert(0, "Unhandled T:"~T.stringof); 
					}
				}
				enforce(waits.length==waitsFlags.length, "wait signal stage mismatch"); //should be a compile time check
				
				VkSubmitInfo submitInfo = {
					waitSemaphoreCount	: waits.length.to!uint,
					pWaitSemaphores	: waits.ptr,
					pWaitDstStageMask	: waitsFlags.ptr,
					commandBufferCount 	: buf.length.to!uint,
					pCommandBuffers 	: buf.ptr,
					signalSemaphoreCount	: signals.length.to!uint,
					pSignalSemaphores	: signals.ptr
				}; 
				
				device.vkQueueSubmit(handle, 1, &submitInfo, null).vkEnforce; 
			} 
			
			/+
				This is cool, but ".submit()" is more readable.
				auto opBinary(string op : "<<")(VkCommandBuffer b) { submit(b); return this; } 
				auto opBinary(string op : "<<")(VkCommandBuffer[] b) { submit(b); return this; } 
			+/
			
			void waitIdle()
			{ device.vkQueueWaitIdle(handle).vkEnforce; } 
			
			auto present(VulkanSemaphore[] renderingFinishedSemaphores, VulkanSwapchain swapchain, uint imageIndex)
			{
				auto semaphoreHandles = renderingFinishedSemaphores.map!"a.handle".array; 
				auto presentInfo = 
				(mixin(!((VkPresentInfoKHR),q{
					waitSemaphoreCount 	: semaphoreHandles.length.to!uint,
					pWaitSemaphores 	: semaphoreHandles.ptr,
					swapchainCount 	: 1,
					pSwapchains 	: &swapchain.handle,
					pImageIndices 	: &imageIndex,
				}))); 
				return device.vkQueuePresentKHR(handle, &presentInfo); 
			} 
			auto present(VulkanSemaphore renderingFinishedSemaphore, VulkanSwapchain swapchain, uint imageIndex)
			{ return present([renderingFinishedSemaphore], swapchain, imageIndex); } 
		} 
		
		
		class VulkanSurface
		{
			mixin SmartClass!(
				q{
					@PARENT VulkanInstance 	instance, 
					HWND 	hwnd, 
					HINSTANCE 	hinst = null 
				}
			); 
			
			VkSurfaceKHR handle; 
			
			void _construct()
			{
				if(!hinst) hinst = GetModuleHandle(null); 
				VkWin32SurfaceCreateInfoKHR sci = {
					hwnd 	: hwnd, 
					hinstance 	: hinst
				}; 
				instance.vkCreateWin32SurfaceKHR(instance.handle, &sci, null, &handle).vkEnforce; 
			} 
			
			void _destruct()
			{ instance.vkDestroySurfaceKHR(instance.handle, handle, null); handle = null; } 
			
			auto findGraphicsPresenterQueueFamily(VulkanPhysicalDevice physicalDevice)
			{
				foreach(qf; physicalDevice.graphicsQueueFamilies)
				{
					VkBool32 presentSupport; 
					physicalDevice.instance.vkGetPhysicalDeviceSurfaceSupportKHR
						(physicalDevice.handle, qf.index, this.handle, &presentSupport).vkEnforce; 
					if(presentSupport) return qf; 
				}
				return null; 
			} 
			
			auto requireGraphicsPresenterQueueFamily(VulkanPhysicalDevice physicalDevice)
			{
				return 	findGraphicsPresenterQueueFamily(physicalDevice)
					.enforce("No graphics and queue family found for surface."); 
			} 
			
			int findGraphicsPresenterQueueFamilyIndex(VulkanPhysicalDevice physicalDevice)
			{
				auto qf = findGraphicsPresenterQueueFamily(physicalDevice); 
				return qf ? qf.index : -1; 
			} 
		} 
		
		class VulkanSwapchain
		{
			mixin SmartClass!(
				q{
					@PARENT VulkanDevice 	device, 
					VulkanSurface 	surface, 
					ivec2	requiredSize
				}
			); 
			
			//These lists only discovered once.
			VkSurfaceCapabilitiesKHR surfaceCapabilities; 
			VkSurfaceFormatKHR[] availableSurfaceFormats; 
			VkPresentModeKHR[] availablePresentModes; 
			
			
			VkSurfaceFormatKHR surfaceFormat; 
			@property format() const { return surfaceFormat.format; } 
			VkExtent2D extent; //it's the windows's size
			VkPresentModeKHR presentMode; 
			
			VkSwapchainKHR handle; alias handle this; 
			VulkanImage[] images; 
			VulkanImageView[] imageViews; 
			
			void _construct()
			{
				{
					auto pdh = device.physicalDevice.handle, sh = surface.handle; 
					availableSurfaceFormats	= device.getPhysicalDeviceSurfaceFormatsKHR	(pdh, sh),
					availablePresentModes	= device.getPhysicalDeviceSurfacePresentModesKHR	(pdh, sh); 
				}
				recreate(requiredSize); 
			} 
			
			void destroyImageViews()
			{ foreach(ref imv; imageViews) imv.destroy; imageViews = null; } 
			
			void destroyImages()
			{
				destroyImageViews; 
				foreach(ref im; images) im.destroy; images = null; 
				//Note: It also destroys the views, because image is the parent of the views.
			} 
			
			void _destruct()
			{
				destroyImages; 
				
				//Note: This implicitly destroys images (in fact, we're not allowed to do that explicitly)
				device.vkDestroySwapchainKHR(device.handle, handle, null); handle = null; 
			} 
			
			private static
			{
				auto chooseSurfaceFormat(in VkSurfaceFormatKHR[] availableFormats)
				{
					// We can either choose any format
					if(availableFormats.length==1 && availableFormats[0].format==(mixin(!((VK_FORMAT_),q{UNDEFINED}))))
					return VkSurfaceFormatKHR((mixin(!((VK_FORMAT_),q{R8G8B8A8_UNORM}))), (mixin(!((VK_COLOR_SPACE_),q{SRGB_NONLINEAR_KHR})))); 
					
					// Or go with the standard format - if available
					foreach(const availableSurfaceFormat; availableFormats)
					if(availableSurfaceFormat.format==(mixin(!((VK_FORMAT_),q{R8G8B8A8_UNORM}))))
					return availableSurfaceFormat; 
					
					// Or fall back to the first available one
					return availableFormats[0]; 
				} 
				
				auto chooseSwapExtent(in VkSurfaceCapabilitiesKHR surfaceCapabilities, ivec2 clientSize)
				{
					if(surfaceCapabilities.currentExtent.width==-1)
					{
						with(surfaceCapabilities)
						{
							const mi = ivec2(minImageExtent.width, minImageExtent.height); 
							const ma = ivec2(maxImageExtent.width, maxImageExtent.height); 
							with(clientSize.clamp(mi, ma)) return VkExtent2D(x, y); 
						}
					}
					else
					return surfaceCapabilities.currentExtent; 
				} 
				
				auto choosePresentMode(VkPresentModeKHR[] presentModes)
				{
					enum canTripleBuffer = false; 
					
					/+
						Todo: V-Sync On: FIFO_RELAXED, if not supported, then FIFO .
						V-Sync Off: IMMEDIATE.
					+/
					static if(1)
					{
						static if(canTripleBuffer)
						{
							/+
								Link: https://www.intel.com/content/www/us/en/developer/articles/training/
								api-without-secrets-introduction-to-vulkan-part-2.html
							+/
							//mailbox is required for triple buffering, but not all devices supporting it.
							return ((presentModes.canFind((mixin(!((VK_PRESENT_MODE_),q{MAILBOX_KHR}))))) ?((mixin(!((VK_PRESENT_MODE_),q{MAILBOX_KHR})))):((mixin(!((VK_PRESENT_MODE_),q{FIFO_KHR}))))); 
						}
						else
						{
							//Todo: relaxed fifo
							//FIFO is always supported
							return (mixin(!((VK_PRESENT_MODE_),q{FIFO_KHR}))); 
						}
					}
					else
					{ return (mixin(!((VK_PRESENT_MODE_),q{IMMEDIATE_KHR}))); }
				} 
			} 
			
			void recreate(ivec2 requiredSize)
			{
				this.requiredSize = requiredSize; 
				auto previousHandle = handle; 
				
				destroyImages; 
				
				{
					auto pdh = device.physicalDevice.handle, sh = surface.handle; 
					surfaceCapabilities = device.getPhysicalDeviceSurfaceCapabilitiesKHR(pdh, sh); 
					/+
						/+Code: surfaceCapabilities+/ must be reevaluated every time, not just at the start.
						Luckily it is very fast.
					+/
				}
				
				// Determine number of images for swap chain.  Aiming for doublebuffer
				uint imageCount = max(surfaceCapabilities.minImageCount, 2); 
				if(surfaceCapabilities.maxImageCount)
				imageCount.minimize(surfaceCapabilities.maxImageCount); 
				
				// Select a surface format
				surfaceFormat = chooseSurfaceFormat(availableSurfaceFormats); 
				
				// Select swap chain size
				extent = chooseSwapExtent(surfaceCapabilities, requiredSize); 
				
				// Determine transformation to use (preferring no transform)
				const surfaceTransform = ((surfaceCapabilities.supportedTransforms.IDENTITY_BIT_KHR) ?((mixin(!((VK_SURFACE_TRANSFORM_),q{IDENTITY_BIT_KHR})))):(surfaceCapabilities.currentTransform)); 
				
				// Choose presentation mode (preferring MAILBOX ~= triple buffering)
				presentMode = choosePresentMode(availablePresentModes); 
				
				// Finally, create the swap chain
				const createInfo = 
				(mixin(!((VkSwapchainCreateInfoKHR),q{
					surface	: this.surface.handle,
					minImageCount	: imageCount,
					imageFormat	: this.surfaceFormat.format,
					imageColorSpace	: this.surfaceFormat.colorSpace,
					imageExtent	: this.extent,
					imageArrayLayers	: 1,
					imageUsage	: (mixin(!((VK_IMAGE_USAGE_),q{COLOR_ATTACHMENT_BIT}))),
					imageSharingMode	: (mixin(!((VK_SHARING_MODE_),q{EXCLUSIVE}))),
					queueFamilyIndexCount 	: 0,
					pQueueFamilyIndices	: null,
					preTransform	: surfaceTransform,
					compositeAlpha	: (mixin(!((VK_COMPOSITE_ALPHA_),q{OPAQUE_BIT_KHR}))),
					presentMode	: this.presentMode,
					clipped	: VK_TRUE,
					oldSwapchain	: previousHandle,
				}))); 
				
				device.vkCreateSwapchainKHR(device.handle, &createInfo, null, &handle)
					.vkEnforce("Failed to create swapchain."); 
				
				if(previousHandle)
				device.vkDestroySwapchainKHR(device.handle, previousHandle, null); 
				
				// Store the images used by the swap chain
				// Note: these are the images that swap chain image indices refer to
				// Note: actual number of images may differ from requested number, since it's a lower bound
				images = device.getSwapchainImagesKHR(device.handle, handle)
					.map!((im){
					auto vulkanImage = new VulkanImage(device, im); 
					vulkanImage.automaticallyDestroyed = true; 
					return vulkanImage; 
				}).array; 
				
				// create imageViews
				imageViews = images.map!
					(
					im=>im.createView
					(
						(mixin(!((VK_IMAGE_VIEW_TYPE),q{_2D}))),
						format,
						(mixin(!((VkComponentMapping),q{
							r 	: (mixin(!((VK_COMPONENT_SWIZZLE_),q{IDENTITY}))), g 	: (mixin(!((VK_COMPONENT_SWIZZLE_),q{IDENTITY}))), 
							b 	: (mixin(!((VK_COMPONENT_SWIZZLE_),q{IDENTITY}))), a 	: (mixin(!((VK_COMPONENT_SWIZZLE_),q{IDENTITY}))),
						}))),
						(mixin(!((VkImageSubresourceRange),q{
							aspectMask 	: (mixin(!((VK_IMAGE_ASPECT_),q{COLOR_BIT}))),
							baseMipLevel 	: 0, levelCount 	: 1,
							baseArrayLayer 	: 0, layerCount 	: 1,
						})))
					)
				).array; 
			} 
			
			uint imageIndex; 
			
			bool acquireNextImage(
				VulkanSemaphore imageAvailableSemaphore, 
				void delegate() onWindowSizeChanged
			)
			{
				imageIndex = -1; 
				auto res = device.vkAcquireNextImageKHR(
					device.handle, this.handle, 3_000_000_000/+Note: ns+/, 
					imageAvailableSemaphore, null, &imageIndex
				); 
				if(res==VK_ERROR_OUT_OF_DATE_KHR)
				{ onWindowSizeChanged(); return false; }
				else if(!res.among(VK_SUCCESS, VK_SUBOPTIMAL_KHR))
				{ res.vkEnforce("vkAcquireNextImageKHR failed."); }
				return true; 
			} 
			
			bool present(
				VulkanQueue queue, VulkanSemaphore renderingFinishedSemaphore, 
				void delegate() onWindowSizeChanged
			)
			{
				enforce(imageIndex<images.length, "VulkanSwapchain.present: invalid imageIndex"); 
				auto res = queue.present(renderingFinishedSemaphore, this, imageIndex); 
				if(res.among(VK_ERROR_OUT_OF_DATE_KHR, VK_SUBOPTIMAL_KHR))
				{ onWindowSizeChanged(); return false; }
				else if(res != VK_SUCCESS)
				{ res.vkEnforce("vkQueuePresentKHR failed."); }
				return true; 
			} 
			
			bool acquireAndPresent(
				VulkanQueue queue, 
				VulkanSemaphore imageAvailableSemaphore,
				VulkanSemaphore renderingFinishedSemaphore,
				void delegate() onDraw,
				void delegate() onWindowSizeChanged
			)
			{
				if(acquireNextImage(imageAvailableSemaphore, onWindowSizeChanged))
				{
					onDraw(); 
					return present(queue, renderingFinishedSemaphore, onWindowSizeChanged); 
				}
				return false; 
			} 
		} 
		
		
		class VulkanDevice
		{
			mixin SmartClassParent!q{
				@PARENT VulkanPhysicalDevice 	physicalDevice,
				string[] 	requiredExtensions,
				VkPhysicalDeviceFeatures	features,
				VulkanDevice.QueueItem[]	queueItems
			}; 
			
			VkDevice handle; 
			VulkanFunctions functions; alias functions this; 
			
			@property queues() { return queueItems.map!"a.queue"; } 
			
			static struct QueueItem
			{
				VulkanQueueFamily queueFamily; 
				float priority = 1; 
				
				VulkanQueue queue; 
				VulkanQueue* queueRef; //optional output
			} 
			
			void waitIdle()
			{ vkDeviceWaitIdle(handle).vkEnforce; } 
			
			void _construct()
			{
				//remove empty extensions. ("" is a valid input), remove duplicates.
				requiredExtensions = requiredExtensions.filter!"a.length".array.sort.uniq.array; 
				
				//choose a single physicalDevice
				enforce(queueItems.length, "Empty VulkanQueue[]"); 
				physicalDevice = queueItems.front.queueFamily.physicalDevice; 
				enforce(
					queueItems.map!(q=>q.queueFamily.physicalDevice==physicalDevice).all, 
					"Only one physicalDevice supported at the moment across VulkanQueues."
				); 
				
				//make DeviceQueueCreateInfo structures
				static makeDeviceQueueCreateInfo(R)(R queueItems)
				{
					auto priorities = queueItems.map!(a=>a.priority).array; 
					return (mixin(!((VkDeviceQueueCreateInfo),q{
						queueFamilyIndex 	: queueItems.front.queueFamily.index, 
						queueCount	: priorities.length.to!uint, 
						pQueuePriorities	: priorities.ptr
					}))); 
				} 
				
				auto deviceQueueCreateInfos =
					queueItems	.splitWhen!((a, b)=>a.queueFamily.index!=b.queueFamily.index)
						.map!(fam=>makeDeviceQueueCreateInfo(fam)).array; 
				
				auto sorteddeviceQueueFamilies = 
					deviceQueueCreateInfos.map!"a.queueFamilyIndex"
					.array.sort.array; 
				enforce(
					equal(sorteddeviceQueueFamilies, sorteddeviceQueueFamilies.uniq), 
					"VulkanQueue[] inconsistent familyIndices. Must be grouped by familyIndices."
				); 
				
				//Create the device
				auto pExtensions = requiredExtensions.map!toPChar.array; 
				auto deviceCreateInfo = 
					(mixin(!((VkDeviceCreateInfo),q{
					queueCreateInfoCount 	: deviceQueueCreateInfos.length.to!uint,
					pQueueCreateInfos 	: deviceQueueCreateInfos.ptr,
					enabledExtensionCount	: pExtensions.length.to!uint,
					ppEnabledExtensionNames 	: pExtensions.ptr,
					pEnabledFeatures	: &features
				}))); 
				
				auto vk = physicalDevice.instance; 
				vk.vkCreateDevice(physicalDevice.handle, &deviceCreateInfo, null, &handle)
					.vkEnforce("vkCreateDevice fail"); 
				
				//got the device, now load its optional function table.
				functions = physicalDevice.instance.functions; 
				loadDeviceFunctions(handle); 
				
				{
					//retrieve the queue handles
					int dstQueueindex; 
					foreach(ref dqci; deviceQueueCreateInfos)
					{
						auto queueFamily = physicalDevice.queueFamilies.get(dqci.queueFamilyIndex); 
						enforce(queueFamily, "vkGetDeviceQueue fatal error 1"); 
						enforce(queueFamily.index==dqci.queueFamilyIndex, "vkGetDeviceQueue fatal error 2"); 
						foreach(i; 0..dqci.queueCount)
						{
							enforce(dstQueueindex.inRange(queueItems), "vkGetDeviceQueue fatal error 3"); 
							auto item = &queueItems[dstQueueindex]; 
							enforce(item.queueFamily is queueFamily, "vkGetDeviceQueue fatal error 4"); 
							
							VkQueue queueHandle; 
							vkGetDeviceQueue(handle, queueFamily.index, i.to!int, &queueHandle); 
							enforce(queueHandle, format!"Error creating VulkanQueue %d:%d."(queueFamily.index, i)); 
							
							item.queue = new VulkanQueue(this, queueFamily, item.priority, queueHandle); 
							if(item.queueRef)
							{
								/+Pass queue to the external reference variable.+/
								*item.queueRef = item.queue; 
							}
							
							dstQueueindex++; //advance
						}
					}
					enforce(dstQueueindex==queues.length, "vkGetDeviceQueue fatal error 3"); 
				}
			} 
			
			void _destruct()
			{
				/+
					Note: Prior to destroying a device, an application is responsible for destroying/freeing any 
					Vulkan objects that were created using that device as the first parameter of the 
					corresponding vkCreate* or vkAllocate* command.
					
					Before _destruct(), all the childObjects are destroyed. -> _thisParentDestroying()
					And then this object's parent is automatically notofied. -> _thisChildDestroying()
				+/
				//Todo: Verify the destruction order
				waitIdle; 
				vkDestroyDevice(handle, null); handle = null; 
			} 
			auto createDescriptorSetLayout(Args...)(in Args args)
			{
				VkDescriptorSetLayoutBinding[] layoutBindings; 
				
				static foreach(i, arg; args)
				{
					{
						alias T = Unqual!(Args[i]); 
						static if(is(T==VkDescriptorSetLayoutBinding))	layoutBindings ~= arg; 
						else static if(is(T==VkDescriptorSetLayoutBinding*))	layoutBindings ~= arg; 
						else static if(is(T==VkDescriptorSetLayoutBinding[]))	layoutBindings ~= arg; 
						else static assert(0, "Unhandled T:"~T.stringof); 
					}
				}
				
				return new VulkanDescriptorSetLayout(this, layoutBindings); 
			} 
			
			auto createPipelineLayout(Args...)(Args args)
			{
				VulkanDescriptorSetLayout[] sets; 
				VkPushConstantRange[] pcRanges; 
				
				static foreach(i, arg; args)
				{
					{
						alias T = Unqual!(Args[i]); 
						
						static if(is(T==VulkanDescriptorSetLayout))	sets ~= arg; 
						else static if(is(T==VulkanDescriptorSetLayout[]))	sets ~= arg; 
						else static if(is(T==VkPushConstantRange))	pcRanges ~= arg; 
						else static if(is(T==VkPushConstantRange[]))	pcRanges ~= arg; 
						else static assert(0, "Unhandled T:"~T.stringof); 
					}
				}
				
				return new VulkanPipelineLayout(this, sets, pcRanges); 
			} 
			
			auto createShaderModule(File f)
			{
				return new VulkanShaderModule(
					this, f.read(true)
					/+
						Todo: This throws memory error 
						when file not found.
						console app, headless.
					+/
				); 
			} 
			
			auto createRenderPass(
				VkAttachmentDescription[] attachmentDescriptions, 
				VulkanSubpassDescription[] subpassDescriptions,
				VulkanSwapchain swapchain=null /+attribute0 only+/
			)
			{
				auto vkSubpassDescriptions = subpassDescriptions.map!"a.toVkSubpassDescription".array; 
				auto createInfo = 	(mixin(!((VkRenderPassCreateInfo),q{
					attachmentCount 	: attachmentDescriptions.length.to!uint, 
					pAttachments 	: attachmentDescriptions.ptr,
					subpassCount 	: vkSubpassDescriptions.length.to!uint,
					pSubpasses 	: vkSubpassDescriptions.ptr,
				}))); 
				//Todo: verify subpass attachment indices
				
				VkRenderPass renderPassHandle; 
				vkCreateRenderPass(handle, &createInfo, null, &renderPassHandle)
					.vkEnforce("failed to create render pass"); 
				
				return new VulkanRenderPass(this, renderPassHandle); 
			} 
			
			auto createDescriptorPool(Args...)(Args args)
			{
				VkDescriptorPoolCreateInfo ci; 
				VkDescriptorPoolSize[] sizes; 
				
				static foreach(i, arg; args)
				{
					{
						alias T = Unqual!(Args[i]); 
						static if(is(T==VkDescriptorPoolSize))	sizes ~= arg; 
						else static if(is(T==VkDescriptorPoolSize[]))	sizes ~= arg; 
						else static if(is(T==VkDescriptorPoolCreateFlags))	ci.flags |= arg; 
						else static if(is(T==VkDescriptorPoolCreateFlagBits))	ci.flags |= arg; 
						else static if(isIntegral!T)	ci.maxSets = arg.to!uint; 
						else static assert(0, "Unhandled T:"~T.stringof); 
					}
				}
				
				ci.poolSizeCount 	= sizes.length.to!uint,
				ci.pPoolSizes	= sizes.ptr; 
				
				VkDescriptorPool poolHandle; 
				vkCreateDescriptorPool(handle, &ci, null, &poolHandle)
					.vkEnforce("Failed to create descriptor pool."); 
				
				return new VulkanDescriptorPool(this, poolHandle); 
			} 
			
			auto createBuffer(Args...)(VkDeviceSize size, Args args)
			{
				VkBufferCreateInfo ci; 
				uint[] queueFamilyIndices; 
				
				ci.size = size; 
				
				static foreach(i, arg; args)
				{
					{
						alias T = Unqual!(Args[i]); 
						static if(is(T==VkBufferCreateFlags))	ci.flags |= arg; 
						else static if(is(T==VkBufferCreateFlagBits))	ci.flags |= arg; 
						else static if(is(T==VkBufferUsageFlags))	ci.usage |= arg; 
						else static if(is(T==VkBufferUsageFlagBits))	ci.usage |= arg; 
						else static if(is(T==VkSharingMode))	ci.sharingMode = arg; 
						else static if(is(T==VulkanQueueFamily))	queueFamilyIndices ~= arg.index; 
						else static if(is(T==VulkanQueueFamily[]))	queueFamilyIndices ~= arg.map!"a.index".array; 
						else static if(is(T==uint[])||is(T==int[]))	queueFamilyIndices ~= cast(uint[])arg; 
						else static assert(0, "Unhandled T:"~T.stringof); 
					}
				}
				
				ci.queueFamilyIndexCount 	= queueFamilyIndices.length.to!uint,
				ci.pQueueFamilyIndices 	= queueFamilyIndices.ptr; 
				
				VkBuffer bufferHandle; 
				vkCreateBuffer(handle, &ci, null, &bufferHandle).vkEnforce; 
				return new VulkanBuffer(this, bufferHandle, ci); 
			} 
			
			auto allocateMemory(VkMemoryAllocateInfo* memAllocInfo)
			{
				VkDeviceMemory memHandle; 
				vkAllocateMemory(handle, memAllocInfo, null, &memHandle).vkEnforce; 
				return new VulkanDeviceMemory(this, memHandle, *memAllocInfo); 
			} 
			
			auto createMemoryBuffer(MF, Args...)(VkDeviceSize size, MF memFlags_, Args bufferArgs)
			if(is(MF==VkMemoryPropertyFlags)||is(MF==VkMemoryPropertyFlagBits))
			{
				VulkanBuffer buffer; 
				VulkanDeviceMemory memory; 
				try
				{
					buffer = createBuffer(size, bufferArgs); 
					memory = buffer.allocateMemory(VkMemoryPropertyFlags(memFlags_)); 
					buffer.bind(memory); //Simple automatic 1 to 1 binding.
					return new VulkanMemoryBuffer(this, memory, buffer); 
				}
				catch(Exception e)
				{ buffer.destroy; memory.destroy; throw e; }
			} 
			
			auto createMemoryBuffer(R, Args...)(in R[] arr, Args args)
			{
				auto res = createMemoryBuffer(arr.sizeBytes, args); 
				res.write(arr); //automatic initialization is the input is an array
				return res; 
			} 
			
			version(/+$DIDE_REGION+/all)
			{
				//helper functions for newPipeline()
				
				static vertexInputState(Args...)(in Args args)
				{
					VkPipelineVertexInputStateCreateInfo ci; 
					VkVertexInputBindingDescription[] bindings; 
					VkVertexInputAttributeDescription[] attrs; 
					
					static foreach(i, arg; args)
					{
						{
							alias T = Unqual!(Args[i]); 
							static if(is(T==VkFlags))	ci.flags |= arg; 
							else static if(is(T==VkVertexInputBindingDescription))	bindings ~= arg; 
							else static if(is(T==VkVertexInputBindingDescription[]))	bindings ~= arg; 
							else static if(is(T==VkVertexInputAttributeDescription))	attrs ~= arg; 
							else static if(is(T==VkVertexInputAttributeDescription[]))	attrs ~= arg; 
							else static assert(0, "Unhandled T:"~T.stringof); 
						}
					}
					
					//Vulkan1.0: flags is reserved for future use
					
					ci.vertexBindingDescriptionCount 	= bindings.length.to!uint, 
					ci.pVertexBindingDescriptions 	= bindings.ptr, 
					ci.vertexAttributeDescriptionCount 	= attrs.length.to!uint, 
					ci.pVertexAttributeDescriptions 	= attrs.ptr; 
					
					return ci; 
				} 
				
				static viewportState(ivec2 size)
				{
					//Simple viewport for an entire windows.
					//Note: Scissor test is always enabled. Viewport is the transform, scissor is the clipping.
					return 
					(mixin(!((VkPipelineViewportStateCreateInfo),q{
						viewportCount 	: 1, 
						pViewports 	: new VkViewport(0, 0, size.x, size.y, 0, 1),
						scissorCount 	: 1, 
						pScissors 	: new VkRect2D(VkOffset2D(0, 0), VkExtent2D(size.x, size.y)),
					}))); 
				} 
				
				static viewportState(VkExtent2D size)
				{ return viewportState(ivec2(size.width, size.height)); } 
				
				auto createComputePipeline(Args...)(Args args)
				{
					enum N = 3; /+the last 3 parameters are: /+Code: (layout, null, -1)+/+/
					
					VkPipelineShaderStageCreateInfo shaderStage; 
					VkPipelineCreateFlags pcFlags; 
					static foreach(i, arg; args[0..$-N])
					{
						{
							alias T = Unqual!(Args[i]); 
							static if(is(T==VkPipelineShaderStageCreateInfo))	shaderStage = arg; 
							else static if(is(T==VkPipelineCreateFlagBits))	pcFlags |= arg; 
							else static if(is(T==VkPipelineCreateFlags))	pcFlags |= arg; 
						}
					}
					
					VkComputePipelineCreateInfo res =
					{
						flags	: pcFlags,
						stage	: shaderStage,
						layout 	: args[$-3].handle,
						basePipelineHandle 	: args[$-2],
						basePipelineIndex 	: args[$-1],
					}; 
					
					VkPipeline pipelineHandle; 
					
					//the handle creation is right here, so the pipeline object will not hold any pointers.
					vkCreateComputePipelines(handle, null/+Todo: PipelineCache+/, 1, &res, null, &pipelineHandle)
					.vkEnforce("failed to create graphics pipeline"); 
					
					return new VulkanPipeline(this, pipelineHandle); //Todo: rename res to ci
				} 
				
				auto createGraphicsPipeline(Args...)(Args args)
				{
					enum N = 5; /+the last 5 parameters are: /+Code: (layout, renderPass, 0, null, -1)+/+/
					
					VkPipelineShaderStageCreateInfo[] shaderStages; 
					VkPipelineCreateFlags pcFlags; 
					static foreach(i, arg; args[0..$-N])
					{
						{
							alias T = Unqual!(Args[i]); 
							static if(is(T==VkPipelineShaderStageCreateInfo))	shaderStages ~= arg; 
							else static if(is(T==VkPipelineShaderStageCreateInfo[]))	shaderStages ~= arg; 
							else static if(is(T==VkPipelineCreateFlagBits))	pcFlags |= arg; 
							else static if(is(T==VkPipelineCreateFlags))	pcFlags |= arg; 
						}
					}
					
					auto get(P)(ref P* ptr)
					{
						static foreach(a; args[0..$-N])
						{
							static if(__traits(compiles, ptr = a)) ptr = a; 
							else static if(__traits(compiles, ptr = [a].ptr)) ptr = [a].ptr; 
						}
					} 
					
					VkGraphicsPipelineCreateInfo res =
					{
						flags	: pcFlags,
						stageCount 	: shaderStages.length.to!uint,
						pStages	: shaderStages.ptr,
							/+Note: optional structs +/
						layout 	: args[$-5].handle,
						renderPass 	: args[$-4],
						subpass 	: args[$-3],
						basePipelineHandle 	: args[$-2],
						basePipelineIndex 	: args[$-1],
					}; {
						get(res.pVertexInputState); 
						get(res.pInputAssemblyState); 
						get(res.pTessellationState); 
						get(res.pViewportState); 
						get(res.pRasterizationState); 
						get(res.pMultisampleState); 
						get(res.pDepthStencilState); 
						get(res.pColorBlendState); 
						get(res.pDynamicState); 
					}
					
					{
						VkPipelineColorBlendAttachmentState[] colorBlendAttachments; 
						static foreach(i, arg; args[0..$-N])
						{
							{
								alias T = Unqual!(Args[i]); 
								static if(is(T==VkPipelineColorBlendAttachmentState))	colorBlendAttachments ~= arg; 
								else static if(is(T==VkPipelineColorBlendAttachmentState*))	colorBlendAttachments ~= arg; 
								else static if(is(T==VkPipelineColorBlendAttachmentState[]))	colorBlendAttachments ~= arg; 
							}
						}
						
						if(colorBlendAttachments)
						{
							with(res.pColorBlendState.enforce("VkGraphicsPipelineCreateInfo.pColorBlendState must be specified."))
							*(cast(uint*)(&(attachmentCount))) 	= colorBlendAttachments.length.to!uint,
							*(cast(void**)(&(pAttachments)))	= colorBlendAttachments.ptr; 
						}
					}
					
					VkPipeline pipelineHandle; 
					
					//the handle creation is right here, so the pipeline object will not hold any pointers.
					vkCreateGraphicsPipelines(handle, null/+Todo: PipelineCache+/, 1, &res, null, &pipelineHandle)
					.vkEnforce("failed to create graphics pipeline"); 
					
					
					
					return new VulkanPipeline(this, pipelineHandle); //Todo: rename res to ci
				} 
			}
			
			
			
			
		} 
		VulkanDevice createVulkanDevice(Args...)(Args args)
		/+
			Note: This is an intelligent constructor. 
			It's separate, because it was impossible to put Args... params into a this() constructor...
		+/
		{
			version(/+$DIDE_REGION+/all)
			{
				string[] extensions; 
				VkPhysicalDeviceFeatures features; 
				VulkanDevice.QueueItem[] queueItems; 
				
				VulkanQueueFamily actQueueFamily; 
				
				
			}/+
				Note: Alternate constructor.   Usage:
				/+
					Code: this(
						QueueFamily1,
							&queue1, 0.9/+optional priority, default=1+/, 
							&queue2, 0.6, 
						QueueFamily2, 
							&queue3
					);
				+/
			+/
			
			void addQueueRef(VulkanQueue* a)
			{
				enforce(a, "VulkanQueue reference is null."); 
				enforce(queueItems.map!"a.queueRef".countUntil(a)<0, "Duplicated VulkanQueue reference."); 
				enforce(actQueueFamily, "Must specify VulkanQueueFamily first."); 
				
				queueItems ~= VulkanDevice.QueueItem	(actQueueFamily, 1.0f, null, a); 
			} 
			
			void setPriority(float a)
			{
				enforce(queueItems.length, "Add a VulkanQueue reference before setting it's priority."); 
				enforce(a.inRange(0, 1), format!"VulkanQueue priority out of range. (%s)"(a)); 
				
				queueItems.back.priority = a; 
			} 
			
			static foreach(i, arg; args)
			{
				{
					alias T = Unqual!(Args[i]); 
					static if(is(T==VulkanQueueFamily))	actQueueFamily = arg; 
					else static if(is(T==VulkanQueue*))	addQueueRef(arg); 
					else static if(isFloatingPoint!T)	setPriority(arg); 
					else static if(isSomeString!T)	extensions ~= arg; 
					else static if(is(T==string[]))	extensions ~= arg; 
					else static if(is(T==VkPhysicalDeviceFeatures))	features = arg; 
					else static assert(0, "Unhandled T:"~T.stringof); 
				}
			}
			
			enforce(queueItems.length, "Stecify at least one VulkanQueue reference."); 
			
			return new VulkanDevice(queueItems.front.queueFamily.physicalDevice, extensions, features, queueItems); 
		} 
		
		class VulkanCommandPool
		{
			mixin SmartClassParent!q{
				@PARENT VulkanDevice 	device,
				VulkanQueueFamily	queueFamily
			}; 
			
			VkCommandPool handle; 
			
			void _construct()
			{
				enforce(
					device.physicalDevice.queueFamilies.canFind(queueFamily), 
					"VulkanQueueFamily and VulkanDevice  inconsistency."
				); 
				VkCommandPoolCreateInfo poolCreateInfo = {
					queueFamilyIndex : queueFamily.index,
					/+Todo: command pool creation flags+/
				}; 
				device.vkCreateCommandPool(device.handle, &poolCreateInfo, null, &handle).vkEnforce; 
			} 
			
			void _destruct()
			{ device.vkDestroyCommandPool(device.handle, handle, null); handle = null; } 
			
			auto createBuffer(Args...)(Args args)
			{ return new VulkanCommandBuffer(this, args); } 
		} 
		
		class VulkanBuffer
		{
			mixin SmartClass!q{
				@PARENT VulkanDevice 	device,
				VkBuffer	handle,
				VkBufferCreateInfo	info
			}; 
			
			alias handle this; 
			
			void _construct()
			{
				//already constructed in VulkanDevice
			} 
			
			void _destruct()
			{ device.vkDestroyBuffer(device.handle, handle, null); handle = null; } 
			
			auto allocateMemory(Args...)(Args args)
			{
				
				VkMemoryPropertyFlags memFlags; 
				static foreach(i, arg; args)
				{
					{
						alias T = Unqual!(Args[i]); 
						static if(is(T==VkMemoryPropertyFlags))	memFlags |= arg; 
						else static if(is(T==VkMemoryPropertyFlagBits))	memFlags |= arg; 
						else static assert(0, "Unhandled T:"~T.stringof); 
					}
				}
				
				VkMemoryRequirements memReqs; 
				device.vkGetBufferMemoryRequirements(device.handle, this.handle, &memReqs); 
				
				VkMemoryAllocateInfo allocInfo = { allocationSize : memReqs.size}; 
				device.physicalDevice.memoryProperties.getMemoryType
					(memReqs.memoryTypeBits, memFlags, &allocInfo.memoryTypeIndex)
					.enforce("Unable to find suitable memory type."); 
				
				//memReqs.LOG; memFlags.LOG; allocInfo.LOG; 
				
				return device.allocateMemory(&allocInfo); 
			} 
			
			void bind(VulkanDeviceMemory memory, VkDeviceSize offset=0)
			{ device.vkBindBufferMemory(device.handle, this, memory, offset).vkEnforce; } 
		} 
		
		class VulkanDeviceMemory
		{
			mixin SmartClass!q{
				@PARENT VulkanDevice 	device,
				VkDeviceMemory	handle,
				VkMemoryAllocateInfo	info
			}; 
			
			alias handle this; 
			
			void _construct()
			{
				//already constructed in VulkanDevice
			} 
			
			void _destruct()
			{ device.vkFreeMemory(device.handle, handle, null); handle = null; } 
			
			void* map(VkDeviceSize offset = 0, VkDeviceSize size = VK_WHOLE_SIZE)
			{
				void* data; 
				device.vkMapMemory(device.handle, handle, offset, size, 0, &data).vkEnforce; 
				return data; 
			} 
			
			void unmap()
			{ device.vkUnmapMemory(device.handle, handle); } 
			
			void flush(VkDeviceSize offset_ = 0, VkDeviceSize size_ = VK_WHOLE_SIZE)
			{
				const memRange = 	(mixin(!((VkMappedMemoryRange),q{
					memory	: handle,
					offset	: offset_,
					size	: size_
				}))); 
				device.vkFlushMappedMemoryRanges(device.handle, 1, &memRange).vkEnforce; 
			} 
			
		} 
		
		class VulkanMemoryBuffer
		{
			/+Note: This is a composition of a Buffer and a same sized DeviceMemory.+/
			mixin SmartClass!q{
				@PARENT VulkanDevice 	device,
				VulkanDeviceMemory	memory,
				VulkanBuffer	buffer
			}; 
			
			@property size() const
			{ return buffer.info.size; } 
			
			@property bufferHandle()
			{ return buffer.handle; } alias bufferHandle this; 
			/+Chained aliases are compiling but failing to work. /+Code: alias buffer this;+/+/
			
			void _construct()
			{
				enforce(
					memory.device is device && buffer.device is device, 
						"VulkanMemoryBuffer ownership inconsistency."
				); 
				/+The actual construction was done by Device.createMemorybuffer()+/
			} 
			
			void _destruct()
			{
				buffer.destroy; 
				memory.destroy; 
				/+
					The parent of these objects is Device.
					Also Device is the parent of this composite object
				+/
			} 
			
			void* map(VkDeviceSize offset = 0, VkDeviceSize size = VK_WHOLE_SIZE)
			{ return memory.map(offset, size); } 
			
			void unmap()
			{ memory.unmap; } 
			
			void flush(VkDeviceSize offset = 0, VkDeviceSize size = VK_WHOLE_SIZE)
			{ memory.flush(offset, size); } 
			
			void write(in void* src, size_t size)
			{
				memcpy(map(0, size), src, size); 
				flush; 
				/+
					Todo: what about flushing?!!! Is it required?
					/+
						Link: https://github.com/KhronosGroup/Vulkan-Docs/wiki/
						Synchronization-Examples
					+/
				+/
				/+
					Todo: Also, never unmap memory unless you're about to delete it. 
					There is no disadvantage to keeping host-visible memory mapped, 
					and mapping it is not a free operation.
					/+
						Link: https://stackoverflow.com/questions/77551915/vulkan-compute-
						shaders-most-efficient-way-to-tranfer-buffer-to-from-gpu-retrie
					+/
				+/
				unmap; 
			} 
			
			void write(A)(in A a)
			{
				static if(isDynamicArray!A)	write(a.ptr, a.sizeBytes); 
				else static if(isInputRange!A)	write(a.array); 
				else	write(&a, a.sizeBytes); 
			} 
		} 
		
		class VulkanImage
		{
			mixin SmartClassParent!q{
				@PARENT VulkanDevice 	device,
				VkImage	handle,
			}; 
			
			alias handle this; 
			
			bool automaticallyDestroyed; //if true, the destructor will not destroy this image
			
			void _construct()
			{
				//already constructed in VulkanDevice
			} 
			
			void _destruct()
			{
				if(!automaticallyDestroyed)
				device.vkDestroyImage(device.handle, handle, null); 
				handle = null; 
			} 
			
			auto createView(VkImageViewCreateInfo ci)
			{
				ci.image = handle; 
				
				VkImageView viewHandle; 
				device.vkCreateImageView(device.handle, &ci, null, &viewHandle).vkEnforce; 
				
				return new VulkanImageView(this, viewHandle); 
			} 
			
			auto createView(Args...)(Args args)
			{
				VkImageViewCreateInfo ci; 
				
				static foreach(i, arg; args)
				{
					{
						alias T = Unqual!(Args[i]); 
						static if(is(T==VkImageViewType))	ci.viewType = arg; 
						else static if(is(T==VkImageViewCreateFlags))	ci.flags |= arg; 
						else static if(is(T==VkFormat))	ci.format = arg; 
						else static if(is(T==VkComponentMapping))	ci.components = arg; 
						else static if(is(T==VkImageSubresourceRange))	ci.subresourceRange = arg; 
						else static assert(0, "Unhandled T:"~T.stringof); 
					}
				}
				
				return createView(ci); 
			} 
		} 
		
		class VulkanImageView
		{
			mixin SmartClass!q{
				@PARENT VulkanImage 	image,
				VkImageView	handle,
			}; 
			
			alias handle this; 
			
			@property device() { return image.device; } 
			
			void _construct()
			{
				//already constructed in VulkanDevice
			} 
			
			void _destruct()
			{
				device.vkDestroyImageView(device.handle, handle, null); 
				handle = null; 
			} 
		} 
		
	}
	version(/+$DIDE_REGION+/all)
	{
		class VulkanCommandBuffer
		{
			mixin SmartClass!q{
				@PARENT VulkanCommandPool 	commandPool, 
				const VkCommandBufferLevel 	level = VkCommandBufferLevel.PRIMARY 
			}; 
			
			VulkanDevice device; 
			VkCommandBuffer handle; 
			
			void _construct()
			{
				device = commandPool.device; 
				VkCommandBufferAllocateInfo cmdBufInfo = 
				{
					commandPool 	: commandPool.handle,
					level 	: level,
					commandBufferCount 	: 1, /+Opt: allocate multiple buffers at once+/
				}; 
				device.vkAllocateCommandBuffers(device.handle, &cmdBufInfo, &handle).vkEnforce; 
			} 
			
			void _destruct()
			{ device.vkFreeCommandBuffers(device.handle, commandPool.handle, 1, &handle); handle = null; } 
			
			void cmdBegin(Args...)(Args args)
			{
				VkCommandBufferBeginInfo info; 
				
				static foreach(i, arg; args)
				{
					{
						alias T = Unqual!(Args[i]); 
						static if(is(T==VkCommandBufferUsageFlags))	info.flags |= arg; 
						else static if(is(T==VkCommandBufferUsageFlagBits))	info.flags |= arg; 
						else static if(is(T==VkCommandBufferInheritanceInfo*))	info.pInheritanceInfo = arg; 
						else static assert(0, "Unhandled T:"~T.stringof); 
					}
				}
				
				device.vkBeginCommandBuffer(handle, &info).vkEnforce; 
			} 
			
			void record(Args...)(Args args)
			if(isDelegate!(Args[$-1]))
			{
				cmdBegin(args[0..$-1]); 
				args[$-1](); 
				cmdEnd; 
			} 
			
			void cmdPipelineBarrier(VkPipelineStageFlags1, VkPipelineStageFlags2, Args...)
				(VkPipelineStageFlags1 srcStageMask, VkPipelineStageFlags2 dstStageMask, Args args)
			{
				VkMemoryBarrier[] memoryBarriers; 
				VkBufferMemoryBarrier[] bufferMemoryBarriers; 
				VkImageMemoryBarrier[] imageMemoryBarriers; 
				VkDependencyFlags dependencyFlags; 
				
				static foreach(i, arg; args)
				{
					{
						alias T = Unqual!(Args[i]); 
						static if(is(T==VkDependencyFlags))	dependencyFlags |= arg; 
						else static if(is(T==VkDependencyFlagBits))	dependencyFlags |= arg; 
						else static if(is(T==VkMemoryBarrier))	memoryBarriers ~= arg; 
						else static if(is(T==VkMemoryBarrier[]))	memoryBarriers ~= arg; 
						else static if(is(T==VkBufferMemoryBarrier))	bufferMemoryBarriers ~= arg; 
						else static if(is(T==VkBufferMemoryBarrier[]))	bufferMemoryBarriers ~= arg; 
						else static if(is(T==VkImageMemoryBarrier))	imageMemoryBarriers ~= arg; 
						else static if(is(T==VkImageMemoryBarrier[]))	imageMemoryBarriers ~= arg; 
						else static assert(0, "Unhandled T:"~T.stringof); 
					}
				}
				
				device.vkCmdPipelineBarrier
					(
					handle, 
					VkPipelineStageFlags(srcStageMask), VkPipelineStageFlags(dstStageMask), 
					dependencyFlags,
					memoryBarriers	.length.to!uint, memoryBarriers	.ptr, 
					bufferMemoryBarriers	.length.to!uint, bufferMemoryBarriers	.ptr, 
					imageMemoryBarriers	.length.to!uint, imageMemoryBarriers	.ptr
				); 
			} 
			
			void cmdCopyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, in VkBufferCopy[] regions)
			{ device.vkCmdCopyBuffer(handle, srcBuffer, dstBuffer, regions.length.to!uint, regions.ptr); } 
			
			void cmdCopyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, in VkBufferCopy region)
			{ device.vkCmdCopyBuffer(handle, srcBuffer, dstBuffer, 1, &region); } 
			
			void cmdCopyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size_)
			{ cmdCopyBuffer(srcBuffer, dstBuffer, (mixin(!((VkBufferCopy),q{size : size_})))); } 
			
			void cmdCopyBuffer(VulkanMemoryBuffer src, VulkanMemoryBuffer dst)
			{
				enforce(src.size==dst.size, "VukanMemoryBuffer size mismatch."); 
				cmdCopyBuffer(src.buffer, dst.buffer, (mixin(!((VkBufferCopy),q{size : src.size })))); 
			} 
			
			void cmdEnd()
			{ device.vkEndCommandBuffer(handle).vkEnforce; } 
			
			
			version(/+$DIDE_REGION cmdRenderPass+/all)
			{
				void cmdBeginRenderPass(
					VkRenderPassBeginInfo 	info, 
					VkSubpassContents 	contents = VK_SUBPASS_CONTENTS_.INLINE
				)
				{ device.vkCmdBeginRenderPass(handle, &info, contents); } 
				
				void recordRenderPass(VkRenderPassBeginInfo info, VkSubpassContents contents, void delegate()fun)
				{ cmdBeginRenderPass(info, contents); fun(); cmdEndRenderPass; } 
				void recordRenderPass(VkRenderPassBeginInfo info, void delegate()	fun)
				{ cmdBeginRenderPass(info); fun(); cmdEndRenderPass; } 
				
				void cmdBindDescriptorSets(
					VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, 
					in VkDescriptorSet[] descriptorSets, in uint32_t[] dynamicOffsets = null
				)
				{
					device.vkCmdBindDescriptorSets(
						handle, pipelineBindPoint, layout, firstSet, 
						descriptorSets	.length.to!uint, descriptorSets	.ptr, 
						dynamicOffsets	.length.to!uint, dynamicOffsets	.ptr
					); 
				} 
				void cmdBindDescriptorSets(
					VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, 
					in VkDescriptorSet descriptorSet, uint dynamicOffset
				)
				{
					device.vkCmdBindDescriptorSets(
						handle, pipelineBindPoint, layout, firstSet, 
						1, &descriptorSet, 1, &dynamicOffset
					); 
				} 
				void cmdBindDescriptorSets(
					VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, 
					in VkDescriptorSet descriptorSet
				)
				{
					device.vkCmdBindDescriptorSets(
						handle, pipelineBindPoint, layout, firstSet, 
						1, &descriptorSet, 0, null
					); 
				} 
				void cmdBindGraphicsDescriptorSets(Args...)(Args args)
				{ cmdBindDescriptorSets(VK_PIPELINE_BIND_POINT_.GRAPHICS, args); } 
				void cmdBindComputeDescriptorSets(Args...)(Args args)
				{ cmdBindDescriptorSets(VK_PIPELINE_BIND_POINT_.COMPUTE, args); } 
				
				void cmdBindPipeline(VkPipelineBindPoint bindPoint, VkPipeline pipeline)
				{ device.vkCmdBindPipeline(handle, bindPoint, pipeline); } 
				void cmdBindGraphicsPipeline(VkPipeline pipeline)
				{ cmdBindPipeline(VK_PIPELINE_BIND_POINT_.GRAPHICS, pipeline); } 
				void cmdBindComputePipeline(VkPipeline pipeline)
				{ cmdBindPipeline(VK_PIPELINE_BIND_POINT_.COMPUTE, pipeline); } 
				
				void cmdBindVertexBuffers(uint firstBinding, in VkBuffer[] buffers, in VkDeviceSize[] offsets)
				{
					enforce(buffers.length==offsets.length, "Vertex buffers.length != offsets.length."); 
					device.vkCmdBindVertexBuffers(handle, firstBinding, 	buffers.length.to!uint, buffers.ptr, offsets.ptr); 
				} 
				void cmdBindVertexBuffers(uint firstBinding, in VkBuffer buffer, in VkDeviceSize offset=0)
				{ device.vkCmdBindVertexBuffers(handle, firstBinding, 1, &buffer, &offset); } 
				
				void cmdBindIndexBuffer(VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType)
				{ device.vkCmdBindIndexBuffer(handle, buffer, offset, indexType); } 
				void cmdBindIndexBuffer(VkBuffer buffer, VkIndexType indexType)
				{ device.vkCmdBindIndexBuffer(handle, buffer, 0, indexType); } 
				
				
				void cmdPushConstants(SSF)(VulkanPipelineLayout layout, SSF shaderStages, size_t ofs, size_t size, const(void)* values)
				{ device.vkCmdPushConstants(this.handle, layout.handle, VkShaderStageFlags(shaderStages), ofs.to!uint, size.to!uint, values); } 
				
				void cmdPushConstants(SSF, V)(VulkanPipelineLayout layout, SSF shaderStages, const ref V values)
				{ cmdPushConstants(layout, shaderStages, 0, V.sizeof.to!int, &values); } 
				
				void cmdPushConstants(SSF, V)(VulkanPipelineLayout layout, SSF shaderStages, const V values)
				{ cmdPushConstants(layout, shaderStages, 0, V.sizeof.to!int, &values); } 
				
				void cmdDrawIndexed(
					uint indexCount, 	uint 	instanceCount,	
					uint firstIndex, 	int 	vertexOffset, 	uint firstInstance
				)
				{ device.vkCmdDrawIndexed(handle, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance); } 
				
				void cmdDispatch(uint x, uint y=1, uint z=1)
				{ device.vkCmdDispatch(handle, x, y, z); } 
				
				void cmdEndRenderPass()
				{ device.vkCmdEndRenderPass(handle); } 
			}
			
		} 
		
		
		
		class VulkanSemaphore
		{
			mixin SmartClass!(q{ @PARENT VulkanDevice device }); 
			
			VkSemaphore handle;  alias handle this; 
			
			void _construct()
			{
				VkSemaphoreCreateInfo sci; 
				device.vkCreateSemaphore(device.handle, &sci, null, &handle).vkEnforce; 
			} 
			
			void _destruct()
			{ device.vkDestroySemaphore(device.handle, handle, null); handle = null; } 
		} 
		
		class VulkanDescriptorSetLayout
		{
			mixin SmartClass!(
				q{
					@PARENT VulkanDevice 	device, 
					const VkDescriptorSetLayoutBinding[] 	layoutBindings
				}
			); 
			
			VkDescriptorSetLayout handle; 
			
			void _construct()
			{
				auto descriptorLayoutCreateInfo = 	(mixin(!((VkDescriptorSetLayoutCreateInfo),q{
					bindingCount 	: layoutBindings.length.to!uint,
					pBindings 	: layoutBindings.ptr,
				}))); 
				device.vkCreateDescriptorSetLayout(device.handle, &descriptorLayoutCreateInfo, null, &handle)
					.vkEnforce("Failed to create descriptor layout."); 
			} 
			
			void _destruct()
			{ device.vkDestroyDescriptorSetLayout(device.handle, handle, null); handle = null; } 
		} 
		
		class VulkanPipelineLayout
		{
			mixin SmartClass!(
				q{
					@PARENT VulkanDevice 	device, 
					const VulkanDescriptorSetLayout[] 	layouts,/+Todo: notify destruction!+/
					const VkPushConstantRange[]	pushConstantRanges
				}
			); 
			
			VkPipelineLayout handle;  alias handle this; 
			
			void _construct()
			{
				auto sets = layouts.map!"a.handle".array; 
				auto layoutCreateInfo = (mixin(!((VkPipelineLayoutCreateInfo),q{
					setLayoutCount 	: sets.length.to!uint,
					pSetLayouts 	: sets.ptr,
					pushConstantRangeCount	: pushConstantRanges.length.to!uint,
					pPushConstantRanges	: pushConstantRanges.ptr
				}))); 
				device.vkCreatePipelineLayout(device.handle, &layoutCreateInfo, null, &handle)
					.vkEnforce("Failed to create pipeline layout."); 
			} 
			
			void _destruct()
			{ device.vkDestroyPipelineLayout(device.handle, handle, null); handle = null; } 
		} 
		
		class VulkanShaderModule
		{
			mixin SmartClass!(
				q{
					@PARENT	VulkanDevice 	device, 
					ubyte[]		rawBytes
				}
			); 
			
			VkShaderModule handle; alias handle this; 
			
			void _construct()
			{
				VkShaderModuleCreateInfo createInfo = {
					codeSize 	: rawBytes.length,
					pCode 	: (cast(uint[])rawBytes).ptr
				}; 
				device.vkCreateShaderModule(device.handle, &createInfo, null, &handle)
					.vkEnforce("Failed to create shader module."); 
				
				rawBytes = null; /+no longer needed+/
			} 
			
			void _destruct()
			{ device.vkDestroyShaderModule(device.handle, handle, null); handle = null; } 
		} 
		
		class VulkanPipeline
		{
			mixin SmartClass!(
				q{
					@PARENT	VulkanDevice 	device, 
					VkPipeline		handle
				}
			); 
			
			alias handle this; 
			
			void _construct()
			{/+this thing is just holding a handle.+/} 
			
			void _destruct()
			{ device.vkDestroyPipeline(device.handle, handle, null); handle = null; } 
		} 
		
		struct VulkanSubpassDescription
		{
			VkSubpassDescriptionFlags flags; 
			VkPipelineBindPoint pipelineBindPoint; 
			VkAttachmentReference[] inputAttachments; 
			VkAttachmentReference[] colorAttachments; 
			VkAttachmentReference[] resolveAttachments; 
			VkAttachmentReference depthStencilAttachment = { VK_ATTACHMENT_UNUSED}; 
			uint[] preserveAttachments; 
			
			auto toVkSubpassDescription()
			{
				enforce(
					resolveAttachments.length.among(0, colorAttachments.length), 
					`Inconsistent colorAttachments - resolveAttachments.`
				); 
				return
				(mixin(!((VkSubpassDescription),q{
					flags	: this.flags,
					pipelineBindPoint	: this.pipelineBindPoint,
					inputAttachmentCount	: inputAttachments.length.to!uint,
					pInputAttachments	: inputAttachments.ptr,
					colorAttachmentCount	: colorAttachments.length.to!uint,
					pColorAttachments	: colorAttachments.ptr,
					pResolveAttachments 	: resolveAttachments.ptr,
					pDepthStencilAttachment	: ((depthStencilAttachment.attachment!=VK_ATTACHMENT_UNUSED) ?(&depthStencilAttachment):(null)),
					preserveAttachmentCount 	: preserveAttachments.length.to!uint,
					pPreserveAttachments	: preserveAttachments.ptr,
				}))); 
			} 
		} 
		
		class VulkanRenderPass
		{
			mixin SmartClassParent!(
				q{
					@PARENT VulkanDevice 	device, 
					VkRenderPass	handle
				}
			); 
			
			alias handle this; 
			
			VulkanFramebuffer[] framebuffers; //attachment 0 only
			
			void _construct()
			{/+this thing is just holding a handle.+/} 
			
			void destroyFramebuffers()
			{
				foreach(ref fb; framebuffers) fb.destroy; 
				framebuffers = null; 
			} 
			
			void _destruct()
			{
				framebuffers = null; //they are children, they are already destroyed.
				device.vkDestroyRenderPass(device.handle, handle, null); handle = null; 
			} 
			
			void createFramebuffers(VulkanSwapchain swapchain)
			{
				destroyFramebuffers; 
				try
				{
					foreach(imv; swapchain.imageViews)
					{
						auto ci = (mixin(!((VkFramebufferCreateInfo),q{
							renderPass 	: this.handle,
							attachmentCount 	: 1,
							pAttachments 	: &imv.handle,
							width 	: swapchain.extent.width,
							height 	: swapchain.extent.height,
							layers 	: 1,
						}))); 
						VkFramebuffer fbHandle; 
						device.vkCreateFramebuffer(device.handle, &ci, null, &fbHandle).vkEnforce; 
						framebuffers ~= new VulkanFramebuffer(this, fbHandle); 
					}
				}
				catch(Exception e)
				{
					destroyFramebuffers; 
					throw e; 
				}
			} 
		} 
		
		class VulkanFramebuffer
		{
			mixin SmartClass!(
				q{
					@PARENT VulkanRenderPass 	renderPass, 
					VkFramebuffer	handle
				}
			); 
			
			alias handle this; 
			
			@property device() { return renderPass.device; } 
			
			void _construct()
			{/+this thing is just holding a handle.+/} 
			
			void _destruct()
			{ device.vkDestroyFramebuffer(device.handle, handle, null); handle = null; } 
		} 
		
		
		
		
		class VulkanDescriptorPool
		{
			mixin SmartClassParent!(
				q{
					@PARENT VulkanDevice 	device, 
					VkDescriptorPool	handle
				}
			); 
			
			alias handle this; 
			
			void _construct()
			{/+this thing is just holding a handle.+/} 
			
			void _destruct()
			{ device.vkDestroyDescriptorPool(device.handle, handle, null); handle = null; } 
			
			alias allocate = allocateDescriptorSet; 
			auto allocateDescriptorSet(VulkanDescriptorSetLayout descriptorSetLayout)
			{
				auto allocInfo = 
					(mixin(!((VkDescriptorSetAllocateInfo),q{
					descriptorPool 	: this.handle,
					descriptorSetCount 	: 1, //Opt: multiple allocation at once
					pSetLayouts 	: &descriptorSetLayout.handle,
				}))); 
				
				VkDescriptorSet descriptorSetHandle; 
				device.vkAllocateDescriptorSets(device.handle, &allocInfo, &descriptorSetHandle)
					.vkEnforce("failed to create descriptor set"); 
				
				return new VulkanDescriptorSet(this, descriptorSetHandle); 
			} 
		} 
		
		class VulkanDescriptorSet
		{
			mixin SmartClass!(
				q{
					@PARENT VulkanDescriptorPool 	pool, 
					VkDescriptorSet	handle
				}
			); 
			
			alias handle this; 
			
			auto device()
			{ return pool.device; } 
			
			void _construct()
			{/+this thing is just holding a handle.+/} 
			
			void _destruct()
			{
				device.vkFreeDescriptorSets(device.handle, pool.handle, 1, &handle)
					.vkEnforce("failed to create descriptor set"); 
				handle = null; 
				
				/+
					Note: It seems OK in 1.0, but in VK_VERSION_1_2: 
					VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT
					/+Link: https://github.com/KhronosGroup/Vulkan-Hpp/issues/929+/
				+/
			} 
			
			deprecated 
			void updateWriteUniformBuffer(
				VkBuffer 	uniformBuffer, 
				VkDeviceSize 	ofs = 0, 
				VkDeviceSize 	siz = VK_WHOLE_SIZE
			)
			{
				// Update descriptor set with uniform binding
				auto descriptorBufferInfo = 
					(mixin(!((VkDescriptorBufferInfo),q{
					buffer 	: uniformBuffer,
					offset 	: ofs,
					range 	: siz,
				}))); 
				auto writeDescriptorSet = 
					(mixin(!((VkWriteDescriptorSet),q{
					dstSet 	: this.handle,
					dstBinding	: 0, /+Todo: way too specific!!!+/
					descriptorCount 	: 1,
					descriptorType 	: (mixin(!((VK_DESCRIPTOR_TYPE_),q{UNIFORM_BUFFER}))),
					pBufferInfo 	: &descriptorBufferInfo
				}))); 
				
				device.vkUpdateDescriptorSets(device.handle, 1, &writeDescriptorSet, 0, null); 
				//Opt: batch processing
				//Todo: this is way too specific
			} 
			
			void write(int bindingIdx, VulkanMemoryBuffer buf, VK_DESCRIPTOR_TYPE_ dtype)
			{
				//Todo: write partial buffer
				auto descriptorBufferInfo = 
					(mixin(!((VkDescriptorBufferInfo),q{
					buffer 	: buf.buffer.handle,
					offset 	: 0,
					range 	: VK_WHOLE_SIZE,
				}))); 
				auto writeDescriptorSet = 
					(mixin(!((VkWriteDescriptorSet),q{
					dstSet 	: this.handle,
					dstBinding	: bindingIdx,
					descriptorCount 	: 1,
					descriptorType 	: dtype,
					pBufferInfo 	: &descriptorBufferInfo
				}))); 
				pool.device.vkUpdateDescriptorSets(pool.device.handle, 1, &writeDescriptorSet, 0, null); 
			} 
		} 
		
		
		class VulkanInstance
		{
			mixin SmartClassParent!(
				q{
					string[] requiredExtensions, 
					string appName=""
				}
			); 
			
			static /+query stuff+/
			{
				alias extensions = Singleton!VulkanExtensions; 
				alias layers = Singleton!VulkanLayers; 
				
				void dumpBasicStuff(int deviceIndex = 0)
				{
					VulkanInstance.extensions.print; 
					VulkanInstance.layers.print; 
					VulkanInstance.layers.map!"a.extensions".each!print; 
					auto vk = new VulkanInstance([/+"VK_KHR_surface", "VK_KHR_win32_surface"+/]); 
					vk.physicalDevices.print; 
					if(auto physicalDevice = vk.physicalDevices.get(deviceIndex))
					{
						physicalDevice.queueFamilies.print; 
						physicalDevice.layers.print; 
						physicalDevice.layers.map!"a.extensions".each!print; 
						physicalDevice.memoryProperties.print; 
					}
					vk.destroy; 
				} 
			} 
			
			VulkanFunctions functions; 
			VkInstance handle; /+Same as /+Code: functions.instance+/+/
			
			alias functions this; 
			
			VulkanPhysicalDevices physicalDevices; 
			
			
			void _construct()
			{
				enforce(vulkanInstalled, "Vulkan is not installed."); 
				
				functions = vkInitializationFunctions; //copy(duplicate) the functions
				
				if(appName=="") appName = appFile.nameWithoutExt; 
				
				VkApplicationInfo appInfo = 
					{
					pApplicationName 	: appName.toPChar,
					applicationVersion	: VK_MAKE_VERSION(1, 0, 0),
					pEngineName	: "hetlib",
					engineVersion	: VK_MAKE_VERSION(1, 0, 0),
					apiVersion	: VK_MAKE_VERSION(1, 0, 0),
				}; 
				
				VkInstanceCreateInfo instInfo = { pApplicationInfo: &appInfo, }; 
				
				instInfo.enabledExtensionCount = requiredExtensions.length.to!uint; 
				instInfo.ppEnabledExtensionNames = requiredExtensions.map!toPChar.array.ptr; 
				
				vkCreateInstance(&instInfo, null, &handle).vkEnforce; 
				loadInstanceFunctions(handle); 
				
				{
					//detect physical devices
					uint idx = 0; 
					auto items = 	enumeratePhysicalDevices
						.map!(d => new VulkanPhysicalDevice(this, d, idx++)).array; 
					physicalDevices = new VulkanPhysicalDevices(items); 
				}
			} 
			
			void _destruct()
			{
				//destroyAllSurfaces; 
				vkDestroyInstance(handle, null); handle = null; 
			} 
			
			void _onChildDestroying(Object o)
			{
				LOG(typeid(o)); 
				if(auto s = cast(VulkanSurface) o) _onSurfaceDestroying(s); 
			} 
			
			version(/+$DIDE_REGION Win32 Surfaces+/all)
			{
				private VulkanSurface[HWND] surfaces_; 
				
				auto surfaces(HWND hwnd)
				{ return surfaces_.require(hwnd, new VulkanSurface(this, hwnd)); } 
				
				void _onSurfaceDestroying(VulkanSurface surface)
				{ surfaces_.remove(surface.hwnd); } 
			}
			
		} 
		class VulkanKernel(UB)
		{
			protected /+Note: Vulkan handling+/
			{
				VulkanInstance vk; 
				VulkanPhysicalDevice physicalDevice; 
				VulkanQueueFamily queueFamily; 
				VulkanQueue queue; 
				VulkanDevice device; 
				VulkanCommandPool commandPool; 
				
				void initialize()
				{
					assert(!commandPool); 
					vk = new VulkanInstance([/+extensions+/]); 
					physicalDevice = vk.physicalDevices.front; 
					queueFamily = physicalDevice.requireComputeQueueFamily; 
					device = createVulkanDevice(queueFamily, &queue); 
					commandPool = queue.createCommandPool; 
				} 
				
				VulkanDescriptorSetLayout descriptorSetLayout; 
				VulkanPipelineLayout pipelineLayout; 
				void createLayouts(VkPushConstantRange[] pushConstantRanges=null)
				{
					descriptorSetLayout = device.createDescriptorSetLayout
						(
						(mixin(!((VkDescriptorSetLayoutBinding),q{
							binding	: 0, 	descriptorType 	: (mixin(!((VK_DESCRIPTOR_TYPE_),q{UNIFORM_BUFFER}))),
							descriptorCount 	: 1, 	stageFlags 	: (mixin(!((VK_SHADER_STAGE_),q{COMPUTE_BIT}))),
						}))), 
						(mixin(!((VkDescriptorSetLayoutBinding),q{
							binding	: 1, 	descriptorType 	: (mixin(!((VK_DESCRIPTOR_TYPE_),q{STORAGE_BUFFER}))),
							descriptorCount 	: 1, 	stageFlags 	: (mixin(!((VK_SHADER_STAGE_),q{COMPUTE_BIT}))),
						})))
					); 
					pipelineLayout = device.createPipelineLayout(descriptorSetLayout, pushConstantRanges); 
				} 
				
				//support multiple shaders/pipelines
				VulkanShaderModule[File/+file ony+/] shaderModules; 
				VulkanPipeline[] pipelines; 
				protected void createPipelines(File[] kernelFiles)
				{
					foreach(kf; kernelFiles)
					{
						kf.writeln; 
						kf.queryString.names.get(0).writeln; 
						const f = kf.withoutQueryString; 
						auto sm = shaderModules.require(f, device.createShaderModule(f)); 
						pipelines ~= device.createComputePipeline
						(
							(mixin(!((VkPipelineShaderStageCreateInfo),q{
								stage 	: (mixin(!((VK_SHADER_STAGE_),q{COMPUTE_BIT}))),
								_module 	: sm,
								pName 	: kf.queryString.names.get(0).toPChar,
							}))), pipelineLayout, null, -1
						); 
					}
				} 
				
				VulkanMemoryBuffer 	uniformMemoryBuffer, 
					dataHostMemoryBuffer,
					dataDeviceMemoryBuffer; 
				const size_t bufSizeBytes; //fixed size specified in constructor
				void createBuffers()
				{
					//Todo: concurrent sharing mode: (mixin(!((VK_SHARING_MODE_),q{CONCURRENT})))
					
					uniformMemoryBuffer = device.createMemoryBuffer
						(UB.sizeof, (mixin(!((VK_MEMORY_PROPERTY_),q{HOST_VISIBLE_BIT}))), (mixin(!((VK_BUFFER_USAGE_),q{UNIFORM_BUFFER_BIT})))); 
					dataHostMemoryBuffer = device.createMemoryBuffer
						(
						bufSizeBytes, 	(mixin(!((VK_MEMORY_PROPERTY_),q{
							HOST_VISIBLE_BIT |
							HOST_CACHED_BIT
						}))), (mixin(!((VK_BUFFER_USAGE_),q{
							TRANSFER_SRC_BIT |
							TRANSFER_DST_BIT
						})))
					); 
					buf = (cast(ubyte*)dataHostMemoryBuffer.map)[0..bufSizeBytes]; 
					/+
						Todo: HOST_CACHED only needed for download buffers
						For upload buffers there is write compining, 
						and that's not a cache, must be flushed.
						/+Link: https://gpuopen.com/learn/vulkan-device-memory+/
					+/
					
					dataDeviceMemoryBuffer = device.createMemoryBuffer
						(
						bufSizeBytes, (mixin(!((VK_MEMORY_PROPERTY_),q{DEVICE_LOCAL_BIT}))), (mixin(!((VK_BUFFER_USAGE_),q{
							STORAGE_BUFFER_BIT |
							TRANSFER_SRC_BIT |
							TRANSFER_DST_BIT
						})))
					)
						/+Todo: , (mixin(!((VK_SHARING_MODE_),q{CONCURRENT})))+/; 
				} 
				
				void uploadBuffers()
				{
					uniformMemoryBuffer.write(ubuf); //ubuf is easy-peasy
					
					//buf is more complicated
					//Opt: Don't upload all the buffer, only parts that were modified!
					dataHostMemoryBuffer.flush; 
					auto cb = new VulkanCommandBuffer(commandPool); 
					with(cb)
					record(
						(mixin(!((VK_COMMAND_BUFFER_USAGE_),q{ONE_TIME_SUBMIT_BIT}))),
						{ cmdCopyBuffer(dataHostMemoryBuffer, dataDeviceMemoryBuffer); }
					); 
					queue.submit(cb); 
					queue.waitIdle; //Opt: STALL
					cb.destroy; 
				} 
				
				void downloadBuffers()
				{
					//Opt: Don't download all the buffer, only parts that are interesting!
					auto cb = new VulkanCommandBuffer(commandPool); 
					with(cb)
					record(
						(mixin(!((VK_COMMAND_BUFFER_USAGE_),q{ONE_TIME_SUBMIT_BIT}))),
						{ cmdCopyBuffer(dataDeviceMemoryBuffer, dataHostMemoryBuffer); }
					); 
					queue.submit(cb); 
					queue.waitIdle; //Opt: STALL
					cb.destroy; 
				} 
				
				VulkanDescriptorPool descriptorPool; 
				VulkanDescriptorSet descriptorSet; 
				
				void createDescriptors()
				{
					descriptorPool = device.createDescriptorPool
						(
						[
							(mixin(!((VkDescriptorPoolSize),q{type 	: (mixin(!((VK_DESCRIPTOR_TYPE_),q{UNIFORM_BUFFER}))), 	descriptorCount 	: 1}))),
							(mixin(!((VkDescriptorPoolSize),q{type 	: (mixin(!((VK_DESCRIPTOR_TYPE_),q{STORAGE_BUFFER}))), 	descriptorCount 	: 1})))
						], 1 /+maxSets+/
					); 
					descriptorSet = descriptorPool.allocate(descriptorSetLayout); 
					descriptorSet.write(0, uniformMemoryBuffer, (mixin(!((VK_DESCRIPTOR_TYPE_),q{UNIFORM_BUFFER})))); 
					descriptorSet.write(1, dataDeviceMemoryBuffer, (mixin(!((VK_DESCRIPTOR_TYPE_),q{STORAGE_BUFFER})))); 
				} 
				
				void dispatchPipeline(
					uint pipelineIdx, 
					uint groupCountX, uint groupCountY=1, uint groupCountZ=1
				)
				{
					enforce(pipelineIdx.inRange(pipelines), "Invalid pipelineIdx"); 
					
					auto cb = commandPool.createBuffer; 
					with(cb)
					{
						record
						(
							(mixin(!((VK_COMMAND_BUFFER_USAGE_),q{ONE_TIME_SUBMIT_BIT}))),
							{
								cmdBindComputePipeline(pipelines[pipelineIdx]); 
								cmdBindComputeDescriptorSets(pipelineLayout, 0, descriptorSet); 
								cmdDispatch(groupCountX, groupCountY, groupCountZ); 
							}
						); 
					}
					queue.submit(cb); 
					queue.waitIdle; //Opt: STALL
					cb.destroy; 
				} 
				
				void dispatch(uint groupCountX, uint groupCountY=1, uint groupCountZ=1)
				{ dispatchPipeline(0, groupCountX, groupCountY, groupCountZ); } 
			} 
			enum StructAlignBugFix=true; 
			
			static if(StructAlignBugFix)
			{
				protected UB* ubufPtr; 	/+Note: Uniform buffer+/
				ref ubuf() { return *ubufPtr; } 
			}
			else
			{ UB ubuf; }
			ubyte[] buf; 	/+
				Note: GPU can only address dwords, 
				so all the offsets are practically dwOffsets
			+/
			
			@property dwbuf() { return cast(uint[])buf; } 
			
			this(File[] kernelFiles /+FileName?function+/, size_t bufSizeBytes_, VkPushConstantRange[] pushConstantRanges = null)
			{
				static if(StructAlignBugFix)
				{
					ubufPtr = new UB; /+
						This exterbak alloc fixes possible access violation 
						when the struct has align(16) fields.
					+/
				}
				
				this.bufSizeBytes = bufSizeBytes_; 
				
				initialize; 
				createLayouts(pushConstantRanges); 
				createPipelines(kernelFiles); 
				createBuffers; 
				createDescriptors; 
			} 
			
			this(File kernelFile, size_t bufSizeBytes_, VkPushConstantRange[] pushConstantRanges = null)
			{ this([kernelFile], bufSizeBytes_, pushConstantRanges); } 
			
			~this()
			{
				vk.destroy; 
				version(StructAlignBugFix) ubufPtr = null; 
				/+deterministic destructor+/
			} 
			
			version(none)
			{
				/+
					Bug: StructAlignBugFix:
					When the struct has align(16), and it's placed on the surface of this class, 
					access violation can happen.
					/+Link: https://forum.dlang.org/post/cwnzgfzodjdrjyhohlqw@forum.dlang.org+/
				+/
				
				//import het; <- it's needed with LDC 1.28.1
				
				struct S
				{
					int a; 
					align(16)//<-this triggers it
					int[4] b; 
				} 
				
				class A(T)
				{
					version(none)
					{ T u; }
					else
					{
						T* p; //<- this fixes it.  (The struct is not on the class surface)
						ref u() { return *p; } 
						this() { p = new T; } 
					}
				} 
				
				class B: A!S
				{ void f() { writeln(u.text/+<-The access violation can be here+/); } } 
				
				void main()
				{
					//writeln("a"); <- this fixes it
					auto b = new B; //<-scoped! can trigger it too
					b.f; 
				} 
			}
		} 
		
		static if(VulkanWindowed)
		{
			public import het.win;  //From here it uses hetlib.win
			
			class VulkanWindow: Window
			{
				VulkanInstance vk; 
				VulkanSurface surface; 
				VulkanPhysicalDevice physicalDevice; 
				VulkanQueueFamily queueFamily; 
				
				VulkanDevice device; 
				VulkanQueue queue; 
				
				VulkanSemaphore 	imageAvailableSemaphore,
					renderingFinishedSemaphore; 
				
				VulkanCommandPool commandPool; 
				
				VulkanSwapchain swapchain; 
				VulkanRenderPass renderPass; 
				
				VulkanDescriptorSetLayout descriptorSetLayout; 
				VulkanPipeline graphicsPipeline; 
				VulkanPipelineLayout pipelineLayout; 
				
				VulkanDescriptorPool descriptorPool; 
				VulkanDescriptorSet descriptorSet; 
				
				bool windowResized; 
				
				struct UniformData
				{ mat4 transformationMatrix; } 
				UniformData uniformData; 
				VulkanMemoryBuffer uniformMemoryBuffer; 
				
				struct Vertex { vec3 pos, color; } 
				
				VkClearValue clearColor = { color: {float32: [ 0.98, 0.92, 0.96, 1.0 ]}, }; 
				
				//must fill these in update
				//Todo: these must be the already mapped VulkanMemory Staging-Buffers
				vec3 actColor; 
				Vertex[] vertices; 
				uint[] indices; 
				
				void reset()
				{
					actColor = vec3(0); 
					vertices.clear; 
					indices.clear; 
				} 
				
				
				void tri(Args...)(in Args args)
				{
					void emit(in vec3 pos)
					{
						indices ~= cast(uint)vertices.length; 
						vertices ~= Vertex(pos, actColor); 
					} 
					
					static foreach(i, A; Args)
					{
						static if(is(A==vec3)) emit(args[i]); 
						else static if(is(A==vec2)) emit(vec3(args[i], 0)); 
						else static if(is(A==RGB)) actColor = rgbToFloat(args[i]); 
					}
				} 
				
				auto createAndUploadBuffer(T)(in T[] buff, in VK_BUFFER_USAGE_ usage)
				{
					//host accessible buffer
					auto stagingBuffer = device.createMemoryBuffer
						(buff, (mixin(!((VK_MEMORY_PROPERTY_),q{HOST_VISIBLE_BIT}))), (mixin(!((VK_BUFFER_USAGE_),q{TRANSFER_SRC_BIT})))); 
					
					//gpu only buffer
					auto deviceBuffer = device.createMemoryBuffer
						(buff.sizeBytes, (mixin(!((VK_MEMORY_PROPERTY_),q{DEVICE_LOCAL_BIT}))), (mixin(!((VK_BUFFER_USAGE_),q{usage | TRANSFER_DST_BIT})))); 
					
					//Allocate command buffer for copy operation
					auto copyCommandBuffer = new VulkanCommandBuffer(commandPool); 
					
					// Now copy data from host visible buffer to gpu only buffer
					with(copyCommandBuffer)
					record(
						(mixin(!((VK_COMMAND_BUFFER_USAGE_),q{ONE_TIME_SUBMIT_BIT}))),
						{ cmdCopyBuffer(stagingBuffer, deviceBuffer); }
					); 
					
					// Submit to queue
					queue.submit(copyCommandBuffer); 
					queue.waitIdle; //Opt: STALL
					
					copyCommandBuffer.destroy; 
					stagingBuffer.destroy; 
					
					return deviceBuffer; 
				} 
				
				void createUniformBuffer()
				{
					uniformMemoryBuffer = device.createMemoryBuffer
						(uniformData.sizeBytes, (mixin(!((VK_MEMORY_PROPERTY_),q{HOST_VISIBLE_BIT}))), (mixin(!((VK_BUFFER_USAGE_),q{UNIFORM_BUFFER_BIT})))); 
					updateUniformData; 
				} 
				
				void updateUniformData()
				{
					// Rotate based on time
					
					const angle = QPS.value(10*second).fract * PIf*2; 
					
					auto modelMatrix = mat4.identity; 
					modelMatrix.rotate(vec3(0, 0, 1), angle); 
					modelMatrix.translate(vec3(0.5f, -0.5f, 0)/3); 
					
					// Set up view
					auto viewMatrix = mat4.lookAt(vec3(0, 0, 2), vec3(0), vec3(0, 1, 0)); 
					
					// Set up projection
					auto projMatrix = mat4.perspective(swapchain.extent.width, swapchain.extent.height, 45, 0.1, 10); 
					
					uniformData.transformationMatrix = projMatrix * viewMatrix * modelMatrix; 
					
					uniformMemoryBuffer.write(uniformData); 
					
					/+
						Todo: Use push constants
						/+Link: https://vkguide.dev/docs/chapter-3/push_constants+/
					+/
				} 
				
				void createRenderPass(VulkanSwapchain swapchain)
				{
					renderPass = device.createRenderPass
						(
						[
							(mixin(!((VkAttachmentDescription),q{
								format 	: swapchain.format, 	samples 	: (mixin(!((VK_SAMPLE_COUNT),q{_1_BIT}))),
								loadOp 	: (mixin(!((VK_ATTACHMENT_LOAD_OP_),q{CLEAR}))), 	storeOp 	: (mixin(!((VK_ATTACHMENT_STORE_OP_),q{STORE}))),
								stencilLoadOp 	: (mixin(!((VK_ATTACHMENT_LOAD_OP_),q{DONT_CARE}))), 	stencilStoreOp 	: (mixin(!((VK_ATTACHMENT_STORE_OP_),q{DONT_CARE}))),
								initialLayout 	: (mixin(!((VK_IMAGE_LAYOUT_),q{PRESENT_SRC_KHR}))), 	finalLayout 	: (mixin(!((VK_IMAGE_LAYOUT_),q{PRESENT_SRC_KHR}))),
							})))
						], 
						[
							(mixin(!((VulkanSubpassDescription),q{
								pipelineBindPoint	: (mixin(!((VK_PIPELINE_BIND_POINT_),q{GRAPHICS}))), 
								colorAttachments	: [
									(mixin(!((VkAttachmentReference),q{
										attachment 	: 0, //attachment index
										layout	: (mixin(!((VK_IMAGE_LAYOUT_),q{COLOR_ATTACHMENT_OPTIMAL}))),
									})))
								]
							})))
						]
					); 
					renderPass.createFramebuffers(swapchain); 
				} 
				
				void createGraphicsPipeline()
				{
					
					//Link: https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules
					auto 	vertexShaderModule 	= device.createShaderModule("helloVulkan.vert.spv".File),
						fragmentShaderModule 	= device.createShaderModule("helloVulkan.frag.spv".File); 
					
					// This is for uniform buffers and samplers
					descriptorSetLayout = device.createDescriptorSetLayout
						(
						(mixin(!((VkDescriptorSetLayoutBinding),q{
							descriptorType 	: (mixin(!((VK_DESCRIPTOR_TYPE_),q{UNIFORM_BUFFER}))),
							descriptorCount 	: 1,
							stageFlags 	: (mixin(!((VK_SHADER_STAGE_),q{VERTEX_BIT}))),
						})))
					); 
					
					// Describe pipeline layout
					// Note: this describes the mapping between memory and shader resources (descriptor sets)
					pipelineLayout = device.createPipelineLayout(descriptorSetLayout); 
					
					// Create the graphics pipeline
					graphicsPipeline = device.createGraphicsPipeline
						(
						[
							(mixin(!((VkPipelineShaderStageCreateInfo),q{
								stage 	: (mixin(!((VK_SHADER_STAGE_),q{VERTEX_BIT}))),
								_module 	: vertexShaderModule,
								pName 	: "main",
							}))), (mixin(!((VkPipelineShaderStageCreateInfo),q{
								stage 	: (mixin(!((VK_SHADER_STAGE_),q{FRAGMENT_BIT}))),
								_module 	: fragmentShaderModule,
								pName 	: "main",
							})))
						],
						
						device.vertexInputState
						(
							(mixin(!((VkVertexInputBindingDescription),q{
								binding	: 0, 
								stride	: Vertex.sizeof,
								inputRate 	: (mixin(!((VK_VERTEX_INPUT_RATE_),q{VERTEX}))),
							}))), [
								(mixin(!((VkVertexInputAttributeDescription),q{
									//vec3 position (.z is 0)
									binding	: 0, 
									location 	: 0,
									format	: (mixin(!((VK_FORMAT_),q{R32G32B32_SFLOAT}))),
									offset	: 0
								}))), (mixin(!((VkVertexInputAttributeDescription),q{
									//vec3 color
									binding	: 0,
									location 	: 1,
									format	: (mixin(!((VK_FORMAT_),q{R32G32B32_SFLOAT}))), 
									offset	: float.sizeof * 3,
								}))),
							]
						),
						
						(mixin(!((VkPipelineInputAssemblyStateCreateInfo),q{
							topology 	: (mixin(!((VK_PRIMITIVE_TOPOLOGY_),q{TRIANGLE_LIST}))),
							primitiveRestartEnable 	: false,
						}))), 
						
						device.viewportState(swapchain.extent),
						
						(mixin(!((VkPipelineRasterizationStateCreateInfo),q{
							depthClampEnable 	: false,
							rasterizerDiscardEnable 	: false,
							polygonMode 	: (mixin(!((VK_POLYGON_MODE_),q{FILL}))),
							cullMode 	: (mixin(!((VK_CULL_MODE_),q{BACK_BIT}))),
							frontFace 	: (mixin(!((VK_FRONT_FACE_),q{COUNTER_CLOCKWISE}))),
							depthBiasEnable 	: false,
							depthBiasConstantFactor 	: 0.0f,
							depthBiasClamp 	: 0.0f,
							depthBiasSlopeFactor 	: 0.0f,
							lineWidth 	: 1.0f,
						}))), (mixin(!((VkPipelineMultisampleStateCreateInfo),q{
							rasterizationSamples 	: (mixin(!((VK_SAMPLE_COUNT),q{_1_BIT}))),
							sampleShadingEnable 	: false,
							minSampleShading 	: 1.0f,
							alphaToCoverageEnable 	: false,
							alphaToOneEnable 	: false,
						}))), (mixin(!((VkPipelineColorBlendStateCreateInfo),q{
							logicOpEnable 	: false,
							logicOp 	: (mixin(!((VK_LOGIC_OP_),q{COPY}))),
							blendConstants 	: [0, 0, 0, 0]
						}))),
						
						(mixin(!((VkPipelineColorBlendAttachmentState),q{
							blendEnable 	: false,
							srcColorBlendFactor 	: (mixin(!((VK_BLEND_FACTOR_),q{ONE}))), 	dstColorBlendFactor 	: (mixin(!((VK_BLEND_FACTOR_),q{ZERO}))), 	colorBlendOp 	: (mixin(!((VK_BLEND_OP_),q{ADD}))),
							srcAlphaBlendFactor 	: (mixin(!((VK_BLEND_FACTOR_),q{ONE}))), 	dstAlphaBlendFactor 	: (mixin(!((VK_BLEND_FACTOR_),q{ZERO}))), 	alphaBlendOp 	: (mixin(!((VK_BLEND_OP_),q{ADD}))),
							colorWriteMask 	: (mixin(!((VK_COLOR_COMPONENT_),q{R_BIT | G_BIT | B_BIT | A_BIT})))
						}))),
						
						pipelineLayout, renderPass, 0, null, -1
					); 
					
					// No longer necessary
					vertexShaderModule.destroy; 
					fragmentShaderModule.destroy; 
				} 
				
				void createDescriptorPool()
				{
					// This describes how many descriptor sets we'll create from this pool for each type
					descriptorPool = device.createDescriptorPool
						(
						[
							(mixin(!((VkDescriptorPoolSize),q{
								type 	: (mixin(!((VK_DESCRIPTOR_TYPE_),q{UNIFORM_BUFFER}))),
								descriptorCount 	: 1
							})))
						],
						1 /+maxSets+/
					); 
				} 
				
				void createDescriptorSet()
				{
					// There needs to be one descriptor set per binding point in the shader
					descriptorSet = descriptorPool.allocate(descriptorSetLayout); 
					descriptorSet.updateWriteUniformBuffer(uniformMemoryBuffer.buffer); 
				} 
				
				auto createCommandBuffer(
					size_t swapchainIndex, size_t indexCount,
					VulkanMemoryBuffer vertexMemoryBuffer, 
					VulkanMemoryBuffer indexMemoryBuffer
				)
				{
					auto commandBuffer = commandPool.createBuffer; 
					with(commandBuffer)
					{
						record
						(
							(mixin(!((VK_COMMAND_BUFFER_USAGE_),q{ONE_TIME_SUBMIT_BIT}))),
							{
								cmdPipelineBarrier
									(
									(mixin(!((VK_PIPELINE_STAGE_),q{COLOR_ATTACHMENT_OUTPUT_BIT}))), 
									(mixin(!((VK_PIPELINE_STAGE_),q{COLOR_ATTACHMENT_OUTPUT_BIT}))),
									(mixin(!((VkImageMemoryBarrier),q{
										srcAccessMask 	: (mixin(!((VK_ACCESS_),q{init}))),
										dstAccessMask 	: (mixin(!((VK_ACCESS_),q{COLOR_ATTACHMENT_WRITE_BIT}))),
										oldLayout 	: (mixin(!((VK_IMAGE_LAYOUT_),q{UNDEFINED}))),
										newLayout 	: (mixin(!((VK_IMAGE_LAYOUT_),q{PRESENT_SRC_KHR}))),
										srcQueueFamilyIndex	: VK_QUEUE_FAMILY_IGNORED,
										dstQueueFamilyIndex	: VK_QUEUE_FAMILY_IGNORED,
										image	: swapchain.images[swapchainIndex],
										subresourceRange	: {
											aspectMask 	: (mixin(!((VK_IMAGE_ASPECT_),q{COLOR_BIT}))),
											baseMipLevel 	: 0, levelCount 	: 1,
											baseArrayLayer 	: 0, layerCount 	: 1,
										},
									})))
								); 
								recordRenderPass
									(
									(mixin(!((VkRenderPassBeginInfo),q{
										renderPass 	: this.renderPass,
										framebuffer 	: renderPass.framebuffers[swapchainIndex],
										renderArea 	: {
											offset 	: { x: 0, y: 0 }, 
											extent 	: swapchain.extent 
										},
										clearValueCount 	: 1,
										pClearValues 	: &clearColor //Note: AMD has FastClear if black or white
									}))), 
									{
										cmdBindGraphicsDescriptorSets(pipelineLayout, 0, descriptorSet); 
										cmdBindGraphicsPipeline(graphicsPipeline); 
										cmdBindVertexBuffers(0, vertexMemoryBuffer); 
										cmdBindIndexBuffer(indexMemoryBuffer, (mixin(!((VK_INDEX_TYPE_),q{UINT32})))); 
										cmdDrawIndexed(indexCount.to!uint, 1, 0, 0, 0); 
									}
								); 
							}
						); 
					}
					return commandBuffer; 
					/+
						Opt: Use primary AND secondary command buffers!	
						On triangle test goes from 1500 to 1300 FPS	with single use buffers.
					+/
				} 
				
				
				override void onInitializeGLWindow()
				{
					disableInternalRedraw = true /+Do nothing on WM_PAINT+/; 
					targetUpdateRate = 100000 /+No limit on minimum update interval+/; 
					
					vk	= new VulkanInstance(["VK_KHR_surface", "VK_KHR_win32_surface"]),
					physicalDevice	= vk.physicalDevices.front,
					surface	= vk.surfaces(hwnd),
					queueFamily	= surface.requireGraphicsPresenterQueueFamily(physicalDevice),
					device	= createVulkanDevice("VK_KHR_swapchain", queueFamily, &queue),
					commandPool	= queue.createCommandPool,
					imageAvailableSemaphore	= new VulkanSemaphore(device),
					renderingFinishedSemaphore 	= new VulkanSemaphore(device); 
					swapchain 	= new VulkanSwapchain(device, surface, clientSize); 
					createRenderPass(swapchain); 
					
					createUniformBuffer; 
					
					createGraphicsPipeline;  //also creates descriptorsetLayout and pipelineLayout
					
					createDescriptorPool; 
					createDescriptorSet; 	//needs: descriptorsetLayout, uniformBuffer
					
					if(0) VulkanInstance.dumpBasicStuff; 
					//print("\nGreat Success!"); 
				} 
				
				override void onFinalizeGLWindow()
				{
					device.waitIdle; 
					vk.destroy; 
				}  
				
				void onWindowSizeChanged() 
				{
					// Only recreate objects that are affected by framebuffer size changes
					device.waitIdle; 
					graphicsPipeline.destroy; 
					pipelineLayout.destroy; 
					descriptorSetLayout.destroy; 
					renderPass.destroy; 
					
					swapchain.recreate(clientSize); 
					createRenderPass(swapchain); 
					createGraphicsPipeline; 
				} 
				
				override void doUpdate()
				{
					VulkanCommandBuffer commandBuffer; 
					VulkanMemoryBuffer 	vertexMemoryBuffer,
						indexMemoryBuffer; 
					
					try
					{
						//Link: https://vulkan-tutorial.com/Drawing_a_triangle/Swap_chain_recreation#page_Fixing-a-deadlock
						/+
							Link: https://www.intel.com/content/www/us/en/developer/articles/
							training/api-without-secrets-introduction-to-vulkan-part-2.html
						+/
						swapchain.acquireAndPresent
							(
							queue, imageAvailableSemaphore, renderingFinishedSemaphore, 
							{
								reset; 
								
								internalUpdate; //this will call onUpdate()
								
								updateUniformData; 
								
								vertexMemoryBuffer 	= createAndUploadBuffer(vertices, (mixin(!((VK_BUFFER_USAGE_),q{VERTEX_BUFFER_BIT})))),
								indexMemoryBuffer 	= createAndUploadBuffer(indices, (mixin(!((VK_BUFFER_USAGE_),q{INDEX_BUFFER_BIT})))); 
								
								device.waitIdle; 
								//Opt: The waitidle is terribly slow
								
								commandBuffer = createCommandBuffer
									(
									swapchain.imageIndex, indices.length.to!uint,
									vertexMemoryBuffer, indexMemoryBuffer
								); 
								queue.submit
									(
									imageAvailableSemaphore, (mixin(!((VK_PIPELINE_STAGE_),q{TOP_OF_PIPE_BIT}))),
									commandBuffer,
									renderingFinishedSemaphore
								); 
							},
							&onWindowSizeChanged
						); 
					}
					catch(Exception e)
					{ ERR(e.simpleMsg); }
					
					commandBuffer.destroy; 
					vertexMemoryBuffer.destroy; 
					indexMemoryBuffer.destroy; 
					//Opt: These reallocations in every frame are bad.
					
					invalidate /+It means: no sleep allowed in winMain()+/; 
				} 
				
			} 
		}
	}
}